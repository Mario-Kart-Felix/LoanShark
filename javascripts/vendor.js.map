{"version":3,"file":"public/javascripts/vendor.js","sources":["bower_components/exoskeleton/exoskeleton.js","bower_components/chaplin/chaplin.js","bower_components/console-polyfill/index.js","bower_components/pouchdb/dist/pouchdb-nightly.js","bower_components/backbone-pouchdb/dist/backbone-pouch.js","node_modules/jade-brunch/runtime.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCx6DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCz5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CCnwLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A,CC7OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A","sourcesContent":["/*!\n * Exoskeleton.js 0.6.3\n * (c) 2013 Paul Miller <http://paulmillr.com>\n * Based on Backbone.js\n * (c) 2010-2013 Jeremy Ashkenas, DocumentCloud\n * Exoskeleton may be freely distributed under the MIT license.\n * For all details and documentation: <http://exosjs.com>\n */\n\n(function(root, factory) {\n  // Set up Backbone appropriately for the environment.\n  if (typeof define === 'function' && define.amd) {\n    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {\n      root.Backbone = root.Exoskeleton = factory(root, exports, _, $);\n    });\n  } else if (typeof exports !== 'undefined') {\n    var _, $;\n    try { _ = require('underscore'); } catch(e) { }\n    try { $ = require('jquery'); } catch(e) { }\n    factory(root, exports, _, $);\n  } else {\n    root.Backbone = root.Exoskeleton = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));\n  }\n\n})(this, function(root, Backbone, _, $) {\n  'use strict';\n\n  // Initial Setup\n  // -------------\n\n  // Save the previous value of the `Backbone` variable, so that it can be\n  // restored later on, if `noConflict` is used.\n  var previousBackbone = root.Backbone;\n  var previousExoskeleton = root.Exoskeleton;\n\n  // Underscore replacement.\n  var utils = Backbone.utils = _ = (_ || {});\n\n  // Hold onto a local reference to `$`. Can be changed at any point.\n  Backbone.$ = $;\n\n  // Create local references to array methods we'll want to use later.\n  var array = [];\n  var push = array.push;\n  var slice = array.slice;\n  var toString = ({}).toString;\n\n  // Current version of the library. Keep in sync with `package.json`.\n  // Backbone.VERSION = '1.0.0';\n\n  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable\n  // to its previous owner. Returns a reference to this Backbone object.\n  Backbone.noConflict = function() {\n    root.Backbone = previousBackbone;\n    root.Exoskeleton = previousExoskeleton;\n    return this;\n  };\n\n  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option\n  // will fake `\"PATCH\"`, `\"PUT\"` and `\"DELETE\"` requests via the `_method` parameter and\n  // set a `X-Http-Method-Override` header.\n  Backbone.emulateHTTP = false;\n\n  // Turn on `emulateJSON` to support legacy servers that can't deal with direct\n  // `application/json` requests ... will encode the body as\n  // `application/x-www-form-urlencoded` instead and will send the model in a\n  // form param named `model`.\n  Backbone.emulateJSON = false;\n\n  // Helpers\n  // -------\n\n  // Helper function to correctly set up the prototype chain, for subclasses.\n  // Similar to `goog.inherits`, but uses a hash of prototype properties and\n  // class properties to be extended.\n  Backbone.extend = function(protoProps, staticProps) {\n    var parent = this;\n    var child;\n\n    // The constructor function for the new subclass is either defined by you\n    // (the \"constructor\" property in your `extend` definition), or defaulted\n    // by us to simply call the parent's constructor.\n    if (protoProps && hasOwnProperty.call(protoProps, 'constructor')) {\n      child = protoProps.constructor;\n    } else {\n      child = function(){ return parent.apply(this, arguments); };\n    }\n\n    // Add static properties to the constructor function, if supplied.\n    _.extend(child, parent, staticProps);\n\n    // Set the prototype chain to inherit from `parent`, without calling\n    // `parent`'s constructor function.\n    var Surrogate = function(){ this.constructor = child; };\n    Surrogate.prototype = parent.prototype;\n    child.prototype = new Surrogate;\n\n    // Add prototype properties (instance properties) to the subclass,\n    // if supplied.\n    if (protoProps) _.extend(child.prototype, protoProps);\n\n    // Set a convenience property in case the parent's prototype is needed\n    // later.\n    child.__super__ = parent.prototype;\n\n    return child;\n  };\n\n  // Throw an error when a URL is needed, and none is supplied.\n  var urlError = function() {\n    throw new Error('A \"url\" property or function must be specified');\n  };\n\n  // Wrap an optional error callback with a fallback error event.\n  var wrapError = function(model, options) {\n    var error = options.error;\n    options.error = function(resp) {\n      if (error) error(model, resp, options);\n      model.trigger('error', model, resp, options);\n    };\n  };\n\n  // Checker for utility methods. Useful for custom builds.\n  var utilExists = function(method) {\n    return typeof _[method] === 'function';\n  };\nutils.result = function result(object, property) {\n  var value = object ? object[property] : undefined;\n  return typeof value === 'function' ? object[property]() : value;\n};\n\nutils.defaults = function defaults(obj) {\n  slice.call(arguments, 1).forEach(function(item) {\n    for (var key in item) if (obj[key] === undefined)\n      obj[key] = item[key];\n  });\n  return obj;\n};\n\nutils.extend = function extend(obj) {\n  slice.call(arguments, 1).forEach(function(item) {\n    for (var key in item) obj[key] = item[key];\n  });\n  return obj;\n};\n\nvar htmlEscapes = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;'\n};\n\nutils.escape = function escape(string) {\n  return string == null ? '' : String(string).replace(/[&<>\"']/g, function(match) {\n    return htmlEscapes[match];\n  });\n};\n\nutils.sortBy = function(obj, value, context) {\n  var iterator = typeof value === 'function' ? value : function(obj){ return obj[value]; };\n  return obj\n    .map(function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iterator.call(context, value, index, list)\n      };\n    })\n    .sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    })\n    .map(function(item) {\n      return item.value;\n    });\n};\n\n/** Used to generate unique IDs */\nvar idCounter = 0;\n\nutils.uniqueId = function uniqueId(prefix) {\n  var id = ++idCounter + '';\n  return prefix ? prefix + id : id;\n};\n\nvar eq = function(a, b, aStack, bStack) {\n  // Identical objects are equal. `0 === -0`, but they aren't identical.\n  // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n  if (a === b) return a !== 0 || 1 / a == 1 / b;\n  // A strict comparison is necessary because `null == undefined`.\n  if (a == null || b == null) return a === b;\n  // Unwrap any wrapped objects.\n  //if (a instanceof _) a = a._wrapped;\n  //if (b instanceof _) b = b._wrapped;\n  // Compare `[[Class]]` names.\n  var className = toString.call(a);\n  if (className != toString.call(b)) return false;\n  switch (className) {\n    // Strings, numbers, dates, and booleans are compared by value.\n    case '[object String]':\n      // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n      // equivalent to `new String(\"5\")`.\n      return a == String(b);\n    case '[object Number]':\n      // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n      // other numeric values.\n      return a !== +a ? b !== +b : (a === 0 ? 1 / a === 1 / b : a === +b);\n    case '[object Date]':\n    case '[object Boolean]':\n      // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n      // millisecond representations. Note that invalid dates with millisecond representations\n      // of `NaN` are not equivalent.\n      return +a == +b;\n    // RegExps are compared by their source patterns and flags.\n    case '[object RegExp]':\n      return a.source == b.source &&\n             a.global == b.global &&\n             a.multiline == b.multiline &&\n             a.ignoreCase == b.ignoreCase;\n  }\n  if (typeof a != 'object' || typeof b != 'object') return false;\n  // Assume equality for cyclic structures. The algorithm for detecting cyclic\n  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n  var length = aStack.length;\n  while (length--) {\n    // Linear search. Performance is inversely proportional to the number of\n    // unique nested structures.\n    if (aStack[length] == a) return bStack[length] == b;\n  }\n  // Objects with different constructors are not equivalent, but `Object`s\n  // from different frames are.\n  var aCtor = a.constructor, bCtor = b.constructor;\n  if (aCtor !== bCtor && !(typeof aCtor === 'function' && (aCtor instanceof aCtor) &&\n                           typeof bCtor === 'function' && (bCtor instanceof bCtor))) {\n    return false;\n  }\n  // Add the first object to the stack of traversed objects.\n  aStack.push(a);\n  bStack.push(b);\n  var size = 0, result = true;\n  // Recursively compare objects and arrays.\n  if (className === '[object Array]') {\n    // Compare array lengths to determine if a deep comparison is necessary.\n    size = a.length;\n    result = size === b.length;\n    if (result) {\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (size--) {\n        if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n      }\n    }\n  } else {\n    // Deep compare objects.\n    for (var key in a) {\n      if (hasOwnProperty.call(a, key)) {\n        // Count the expected number of properties.\n        size++;\n        // Deep compare each member.\n        if (!(result = hasOwnProperty.call(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n      }\n    }\n    // Ensure that both objects contain the same number of properties.\n    if (result) {\n      for (key in b) {\n        if (hasOwnProperty.call(b, key) && !(size--)) break;\n      }\n      result = !size;\n    }\n  }\n  // Remove the first object from the stack of traversed objects.\n  aStack.pop();\n  bStack.pop();\n  return result;\n};\n\n// Perform a deep comparison to check if two objects are equal.\nutils.isEqual = function(a, b) {\n  return eq(a, b, [], []);\n};\n// Usage:\n//   utils.matchesSelector(div, '.something');\nutils.matchesSelector = (function() {\n  if (typeof document === 'undefined') return;\n  // Suffix.\n  var sfx = 'MatchesSelector';\n  var tag = document.createElement('div');\n  var name;\n  // Detect the right suffix.\n  ['matches', 'webkit' + sfx, 'moz' + sfx, 'ms' + sfx].some(function(item) {\n    var valid = (item in tag);\n    name = item;\n    return valid;\n  });\n  if (!name) throw new Error('Element#matches is not supported');\n  return function(element, selector) {\n    return element[name](selector);\n  };\n})();\n\nutils.delegate = function(view, eventName, selector, callback) {\n  if (typeof selector === 'function') {\n    callback = selector;\n    selector = null;\n  }\n\n  if (typeof callback !== 'function') {\n    throw new TypeError('View#delegate expects callback function');\n  }\n\n  var root = view.el;\n  var bound = callback.bind(view);\n  var handler = selector ? function(event) {\n    for (var el = event.target; el && el !== root; el = el.parentNode) {\n      if (utils.matchesSelector(el, selector)) {\n        // event.currentTarget or event.target are read-only.\n        event.delegateTarget = el;\n        return bound(event);\n      }\n    }\n  } : bound;\n\n  root.addEventListener(eventName, handler, false);\n  view._handlers.push({\n    eventName: eventName, selector: selector,\n    callback: callback, handler: handler\n  });\n  return handler;\n};\n\nutils.undelegate = function(view, eventName, selector, callback) {\n  if (typeof selector === 'function') {\n    callback = selector;\n    selector = null;\n  }\n\n  var handlers = view._handlers;\n  var removeListener = function(item) {\n    view.el.removeEventListener(item.eventName, item.handler, false);\n  };\n\n  // Remove all handlers.\n  if (!eventName && !selector && !callback) {\n    handlers.forEach(removeListener);\n    view._handlers = [];\n  } else {\n    // Remove some handlers.\n    handlers\n      .filter(function(item) {\n        return item.eventName === eventName &&\n          (callback ? item.callback === callback : true) &&\n          (selector ? item.selector === selector : true);\n      })\n      .forEach(function(item) {\n        removeListener(item);\n        handlers.splice(handlers.indexOf(item), 1);\n      });\n  }\n};\n\n// Make AJAX request to the server.\n// Usage:\n//   var callback = function(error, data) {console.log('Done.', error, data);};\n//   ajax({url: 'url', type: 'PATCH', data: 'data'}, callback);\nutils.ajax = (function() {\n  var xmlRe = /^(?:application|text)\\/xml/;\n  var jsonRe = /^application\\/json/;\n\n  var getData = function(accepts, xhr) {\n    if (accepts == null) accepts = xhr.getResponseHeader('content-type');\n    if (xmlRe.test(accepts)) {\n      return xhr.responseXML;\n    } else if (jsonRe.test(accepts)) {\n      return JSON.parse(xhr.responseText);\n    } else {\n      return xhr.responseText;\n    }\n  };\n\n  var isValid = function(xhr) {\n    return (xhr.status >= 200 && xhr.status < 300) ||\n      (xhr.status === 304) ||\n      (xhr.status === 0 && window.location.protocol === 'file:')\n  };\n\n  var end = function(xhr, options, deferred) {\n    return function() {\n      if (xhr.readyState !== 4) return;\n\n      var status = xhr.status;\n      var data = getData(options.headers && options.headers.Accept, xhr);\n\n      // Check for validity.\n      if (isValid(xhr)) {\n        if (options.success) options.success(data);\n        if (deferred) deferred.resolve(data);\n      } else {\n        var error = new Error('Server responded with a status of ' + status);\n        if (options.error) options.error(xhr, status, error);\n        if (deferred) deferred.reject(xhr);\n      }\n    }\n  };\n\n  return function(options) {\n    if (options == null) throw new Error('You must provide options');\n    if (options.type == null) options.type = 'GET';\n\n    var xhr = new XMLHttpRequest();\n    var deferred = Backbone.Deferred && Backbone.Deferred();\n\n    if (options.contentType) {\n      if (options.headers == null) options.headers = {};\n      options.headers['Content-Type'] = options.contentType;\n    }\n\n    // Stringify GET query params.\n    if (options.type === 'GET' && typeof options.data === 'object') {\n      var query = '';\n      var stringifyKeyValuePair = function(key, value) {\n        return value == null ? '' :\n          '&' + encodeURIComponent(key) +\n          '=' + encodeURIComponent(value);\n      };\n      for (var key in options.data) {\n        query += stringifyKeyValuePair(key, options.data[key]);\n      }\n\n      if (query) {\n        var sep = (options.url.indexOf('?') === -1) ? '?' : '&';\n        options.url += sep + query.substring(1);\n      }\n    }\n\n    if (options.credentials) options.withCredentials = true;\n    xhr.addEventListener('readystatechange', end(xhr, options, deferred));\n    xhr.open(options.type, options.url, true);\n    if (options.headers) for (var key in options.headers) {\n      xhr.setRequestHeader(key, options.headers[key]);\n    }\n    if (options.beforeSend) options.beforeSend(xhr);\n    xhr.send(options.data);\n\n    return deferred ? deferred.promise : undefined;\n  };\n})();\n// Backbone.Events\n// ---------------\n\n// A module that can be mixed in to *any object* in order to provide it with\n// custom events. You may bind with `on` or remove with `off` callback\n// functions to an event; `trigger`-ing an event fires all callbacks in\n// succession.\n//\n//     var object = {};\n//     _.extend(object, Backbone.Events);\n//     object.on('expand', function(){ alert('expanded'); });\n//     object.trigger('expand');\n//\nvar Events = Backbone.Events = {\n\n  // Bind an event to a `callback` function. Passing `\"all\"` will bind\n  // the callback to all events fired.\n  on: function(name, callback, context) {\n    if (!eventsApi(this, 'on', name, [callback, context]) || !callback)\n      return this;\n    this._events || (this._events = {});\n    var events = this._events[name] || (this._events[name] = []);\n    events.push({callback: callback, context: context, ctx: context || this});\n    return this;\n  },\n\n  // Bind an event to only be triggered a single time. After the first time\n  // the callback is invoked, it will be removed.\n  once: function(name, callback, context) {\n    if (!eventsApi(this, 'once', name, [callback, context]) || !callback)\n      return this;\n    var self = this;\n    var ran;\n\n    var once = function() {\n      if (ran) return;\n      ran = true;\n      self.off(name, once);\n      callback.apply(this, arguments);\n    };\n    once._callback = callback;\n    return this.on(name, once, context);\n  },\n\n  // Remove one or many callbacks. If `context` is null, removes all\n  // callbacks with that function. If `callback` is null, removes all\n  // callbacks for the event. If `name` is null, removes all bound\n  // callbacks for all events.\n  off: function(name, callback, context) {\n    var retain, ev, events, names, i, l, j, k;\n    if (!this._events || !eventsApi(this, 'off', name, [callback, context]))\n      return this;\n    if (!name && !callback && !context) {\n      this._events = undefined;\n      return this;\n    }\n\n    names = name ? [name] : Object.keys(this._events);\n    for (i = 0, l = names.length; i < l; i++) {\n      name = names[i];\n      if (events = this._events[name]) {\n        this._events[name] = retain = [];\n        if (callback || context) {\n          for (j = 0, k = events.length; j < k; j++) {\n            ev = events[j];\n            if ((callback && callback !== ev.callback &&\n                callback !== ev.callback._callback) ||\n                (context && context !== ev.context)) {\n              retain.push(ev);\n            }\n          }\n        }\n        if (!retain.length) delete this._events[name];\n      }\n    }\n\n    return this;\n  },\n\n  // Trigger one or many events, firing all bound callbacks. Callbacks are\n  // passed the same arguments as `trigger` is, apart from the event name\n  // (unless you're listening on `\"all\"`, which will cause your callback to\n  // receive the true name of the event as the first argument).\n  trigger: function(name) {\n    if (!this._events) return this;\n    var args = slice.call(arguments, 1);\n    if (!eventsApi(this, 'trigger', name, args)) return this;\n    var events = this._events[name];\n    var allEvents = this._events.all;\n    if (events) triggerEvents(events, args);\n    if (allEvents) triggerEvents(allEvents, arguments);\n    return this;\n  },\n\n  // Tell this object to stop listening to either specific events ... or\n  // to every object it's currently listening to.\n  stopListening: function(obj, name, callback) {\n    var listeningTo = this._listeningTo;\n    if (!listeningTo) return this;\n    var remove = !name && !callback;\n    if (!callback && typeof name === 'object') callback = this;\n    if (obj) (listeningTo = {})[obj._listenId] = obj;\n    for (var id in listeningTo) {\n      obj = listeningTo[id];\n      obj.off(name, callback, this);\n      if (remove || !Object.keys(obj._events).length) {\n        delete this._listeningTo[id];\n      }\n    }\n    return this;\n  }\n\n};\n\n// Regular expression used to split event strings.\nvar eventSplitter = /\\s+/;\n\n// Implement fancy features of the Events API such as multiple event\n// names `\"change blur\"` and jQuery-style event maps `{change: action}`\n// in terms of the existing API.\nvar eventsApi = function(obj, action, name, rest) {\n  if (!name) return true;\n  var arr;\n\n  // Handle event maps.\n  if (typeof name === 'object') {\n    for (var key in name) {\n      arr = [key, name[key]];\n      push.apply(arr, rest);\n      obj[action].apply(obj, arr);\n    }\n    return false;\n  }\n\n  // Handle space separated event names.\n  if (eventSplitter.test(name)) {\n    var names = name.split(eventSplitter);\n    for (var i = 0, l = names.length; i < l; i++) {\n      arr = [names[i]];\n      push.apply(arr, rest);\n      obj[action].apply(obj, arr);\n    }\n    return false;\n  }\n\n  return true;\n};\n\n// A difficult-to-believe, but optimized internal dispatch function for\n// triggering events. Tries to keep the usual cases speedy (most internal\n// Backbone events have 3 arguments).\nvar triggerEvents = function(events, args) {\n  var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n  switch (args.length) {\n    case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;\n    case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;\n    case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\n    case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\n    default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);\n  }\n};\n\nvar listenMethods = {listenTo: 'on', listenToOnce: 'once'};\n\n// Inversion-of-control versions of `on` and `once`. Tell *this* object to\n// listen to an event in another object ... keeping track of what it's\n// listening to.\nObject.keys(listenMethods).forEach(function(method) {\n  var implementation = listenMethods[method];\n  Events[method] = function(obj, name, callback) {\n    var listeningTo = this._listeningTo || (this._listeningTo = {});\n    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));\n    listeningTo[id] = obj;\n    if (!callback && typeof name === 'object') callback = this;\n    obj[implementation](name, callback, this);\n    return this;\n  };\n});\n\n// Aliases for backwards compatibility.\nEvents.bind   = Events.on;\nEvents.unbind = Events.off;\n// Backbone.Model\n// --------------\n\n// Backbone **Models** are the basic data object in the framework --\n// frequently representing a row in a table in a database on your server.\n// A discrete chunk of data and a bunch of useful, related methods for\n// performing computations and transformations on that data.\n\n// Create a new model with the specified attributes. A client id (`cid`)\n// is automatically generated and assigned for you.\nvar Model = Backbone.Model = function(attributes, options) {\n  var attrs = attributes || {};\n  options || (options = {});\n  this.cid = _.uniqueId('c');\n  this.attributes = Object.create(null);\n  if (options.collection) this.collection = options.collection;\n  if (options.parse) attrs = this.parse(attrs, options) || {};\n  attrs = _.defaults({}, attrs, _.result(this, 'defaults'));\n  this.set(attrs, options);\n  this.changed = Object.create(null);\n  this.initialize.apply(this, arguments);\n};\n\n// Attach all inheritable methods to the Model prototype.\n_.extend(Model.prototype, Events, {\n\n  // A hash of attributes whose current and previous value differ.\n  changed: null,\n\n  // The value returned during the last failed validation.\n  validationError: null,\n\n  // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\n  // CouchDB users may want to set this to `\"_id\"`.\n  idAttribute: 'id',\n\n  // Initialize is an empty function by default. Override it with your own\n  // initialization logic.\n  initialize: function(){},\n\n  // Return a copy of the model's `attributes` object.\n  toJSON: function(options) {\n    return _.extend(Object.create(null), this.attributes);\n  },\n\n  // Proxy `Backbone.sync` by default -- but override this if you need\n  // custom syncing semantics for *this* particular model.\n  sync: function() {\n    return Backbone.sync.apply(this, arguments);\n  },\n\n  // Get the value of an attribute.\n  get: function(attr) {\n    return this.attributes[attr];\n  },\n\n  // Get the HTML-escaped value of an attribute.\n  escape: function(attr) {\n    return _.escape(this.get(attr));\n  },\n\n  // Returns `true` if the attribute contains a value that is not null\n  // or undefined.\n  has: function(attr) {\n    return this.get(attr) != null;\n  },\n\n  // Set a hash of model attributes on the object, firing `\"change\"`. This is\n  // the core primitive operation of a model, updating the data and notifying\n  // anyone who needs to know about the change in state. The heart of the beast.\n  set: function(key, val, options) {\n    var attr, attrs, unset, changes, silent, changing, prev, current;\n    if (key == null) return this;\n\n    // Handle both `\"key\", value` and `{key: value}` -style arguments.\n    if (typeof key === 'object') {\n      attrs = key;\n      options = val;\n    } else {\n      (attrs = {})[key] = val;\n    }\n\n    options || (options = {});\n\n    // Run validation.\n    if (!this._validate(attrs, options)) return false;\n\n    // Extract attributes and options.\n    unset           = options.unset;\n    silent          = options.silent;\n    changes         = [];\n    changing        = this._changing;\n    this._changing  = true;\n\n    if (!changing) {\n      this._previousAttributes = _.extend(Object.create(null), this.attributes);\n      this.changed = {};\n    }\n    current = this.attributes, prev = this._previousAttributes;\n\n    // Check for changes of `id`.\n    if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];\n\n    // For each `set` attribute, update or delete the current value.\n    for (attr in attrs) {\n      val = attrs[attr];\n      if (!_.isEqual(current[attr], val)) changes.push(attr);\n      if (!_.isEqual(prev[attr], val)) {\n        this.changed[attr] = val;\n      } else {\n        delete this.changed[attr];\n      }\n      unset ? delete current[attr] : current[attr] = val;\n    }\n\n    // Trigger all relevant attribute changes.\n    if (!silent) {\n      if (changes.length) this._pending = true;\n      for (var i = 0, l = changes.length; i < l; i++) {\n        this.trigger('change:' + changes[i], this, current[changes[i]], options);\n      }\n    }\n\n    // You might be wondering why there's a `while` loop here. Changes can\n    // be recursively nested within `\"change\"` events.\n    if (changing) return this;\n    if (!silent) {\n      while (this._pending) {\n        this._pending = false;\n        this.trigger('change', this, options);\n      }\n    }\n    this._pending = false;\n    this._changing = false;\n    return this;\n  },\n\n  // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\n  // if the attribute doesn't exist.\n  unset: function(attr, options) {\n    return this.set(attr, void 0, _.extend({}, options, {unset: true}));\n  },\n\n  // Clear all attributes on the model, firing `\"change\"`.\n  clear: function(options) {\n    var attrs = {};\n    for (var key in this.attributes) attrs[key] = void 0;\n    return this.set(attrs, _.extend({}, options, {unset: true}));\n  },\n\n  // Determine if the model has changed since the last `\"change\"` event.\n  // If you specify an attribute name, determine if that attribute has changed.\n  hasChanged: function(attr) {\n    if (attr == null) return !!Object.keys(this.changed).length;\n    return hasOwnProperty.call(this.changed, attr);\n  },\n\n  // Return an object containing all the attributes that have changed, or\n  // false if there are no changed attributes. Useful for determining what\n  // parts of a view need to be updated and/or what attributes need to be\n  // persisted to the server. Unset attributes will be set to undefined.\n  // You can also pass an attributes object to diff against the model,\n  // determining if there *would be* a change.\n  changedAttributes: function(diff) {\n    if (!diff) return this.hasChanged() ? _.extend(Object.create(null), this.changed) : false;\n    var val, changed = false;\n    var old = this._changing ? this._previousAttributes : this.attributes;\n    for (var attr in diff) {\n      if (_.isEqual(old[attr], (val = diff[attr]))) continue;\n      (changed || (changed = {}))[attr] = val;\n    }\n    return changed;\n  },\n\n  // Get the previous value of an attribute, recorded at the time the last\n  // `\"change\"` event was fired.\n  previous: function(attr) {\n    if (attr == null || !this._previousAttributes) return null;\n    return this._previousAttributes[attr];\n  },\n\n  // Get all of the attributes of the model at the time of the previous\n  // `\"change\"` event.\n  previousAttributes: function() {\n    return _.extend(Object.create(null), this._previousAttributes);\n  },\n\n  // Fetch the model from the server. If the server's representation of the\n  // model differs from its current attributes, they will be overridden,\n  // triggering a `\"change\"` event.\n  fetch: function(options) {\n    options = options ? _.extend({}, options) : {};\n    if (options.parse === void 0) options.parse = true;\n    var model = this;\n    var success = options.success;\n    options.success = function(resp) {\n      if (!model.set(model.parse(resp, options), options)) return false;\n      if (success) success(model, resp, options);\n      model.trigger('sync', model, resp, options);\n    };\n    wrapError(this, options);\n    return this.sync('read', this, options);\n  },\n\n  // Set a hash of model attributes, and sync the model to the server.\n  // If the server returns an attributes hash that differs, the model's\n  // state will be `set` again.\n  save: function(key, val, options) {\n    var attrs, method, xhr, attributes = this.attributes;\n\n    // Handle both `\"key\", value` and `{key: value}` -style arguments.\n    if (key == null || typeof key === 'object') {\n      attrs = key;\n      options = val;\n    } else {\n      (attrs = {})[key] = val;\n    }\n\n    options = _.extend({validate: true}, options);\n\n    // If we're not waiting and attributes exist, save acts as\n    // `set(attr).save(null, opts)` with validation. Otherwise, check if\n    // the model will be valid when the attributes, if any, are set.\n    if (attrs && !options.wait) {\n      if (!this.set(attrs, options)) return false;\n    } else {\n      if (!this._validate(attrs, options)) return false;\n    }\n\n    // Set temporary attributes if `{wait: true}`.\n    if (attrs && options.wait) {\n      this.attributes = _.extend(Object.create(null), attributes, attrs);\n    }\n\n    // After a successful server-side save, the client is (optionally)\n    // updated with the server-side state.\n    if (options.parse === void 0) options.parse = true;\n    var model = this;\n    var success = options.success;\n    options.success = function(resp) {\n      // Ensure attributes are restored during synchronous saves.\n      model.attributes = attributes;\n      var serverAttrs = model.parse(resp, options);\n      if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);\n      if (serverAttrs && typeof serverAttrs === 'object' && !model.set(serverAttrs, options)) {\n        return false;\n      }\n      if (success) success(model, resp, options);\n      model.trigger('sync', model, resp, options);\n    };\n    wrapError(this, options);\n\n    method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\n    if (method === 'patch') options.attrs = attrs;\n    xhr = this.sync(method, this, options);\n\n    // Restore attributes.\n    if (attrs && options.wait) this.attributes = attributes;\n\n    return xhr;\n  },\n\n  // Destroy this model on the server if it was already persisted.\n  // Optimistically removes the model from its collection, if it has one.\n  // If `wait: true` is passed, waits for the server to respond before removal.\n  destroy: function(options) {\n    options = options ? _.extend({}, options) : {};\n    var model = this;\n    var success = options.success;\n\n    var destroy = function() {\n      model.trigger('destroy', model, model.collection, options);\n    };\n\n    options.success = function(resp) {\n      if (options.wait || model.isNew()) destroy();\n      if (success) success(model, resp, options);\n      if (!model.isNew()) model.trigger('sync', model, resp, options);\n    };\n\n    if (this.isNew()) {\n      options.success();\n      return false;\n    }\n    wrapError(this, options);\n\n    var xhr = this.sync('delete', this, options);\n    if (!options.wait) destroy();\n    return xhr;\n  },\n\n  // Default URL for the model's representation on the server -- if you're\n  // using Backbone's restful methods, override this to change the endpoint\n  // that will be called.\n  url: function() {\n    var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();\n    if (this.isNew()) return base;\n    return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.id);\n  },\n\n  // **parse** converts a response into the hash of attributes to be `set` on\n  // the model. The default implementation is just to pass the response along.\n  parse: function(resp, options) {\n    return resp;\n  },\n\n  // Create a new model with identical attributes to this one.\n  clone: function() {\n    return new this.constructor(this.attributes);\n  },\n\n  // A model is new if it has never been saved to the server, and lacks an id.\n  isNew: function() {\n    return this.id == null;\n  },\n\n  // Check if the model is currently in a valid state.\n  isValid: function(options) {\n    return this._validate({}, _.extend(options || {}, { validate: true }));\n  },\n\n  // Run validation against the next complete set of model attributes,\n  // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\n  _validate: function(attrs, options) {\n    if (!options.validate || !this.validate) return true;\n    attrs = _.extend(Object.create(null), this.attributes, attrs);\n    var error = this.validationError = this.validate(attrs, options) || null;\n    if (!error) return true;\n    this.trigger('invalid', this, error, _.extend(options, {validationError: error}));\n    return false;\n  }\n\n});\n\nif (_.keys) {\n  // Underscore methods that we want to implement on the Model.\n  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];\n\n  // Mix in each Underscore method as a proxy to `Model#attributes`.\n  modelMethods.filter(utilExists).forEach(function(method) {\n    Model.prototype[method] = function() {\n      var args = slice.call(arguments);\n      args.unshift(this.attributes);\n      return _[method].apply(_, args);\n    };\n  });\n}\n// Backbone.Collection\n// -------------------\n\n// If models tend to represent a single row of data, a Backbone Collection is\n// more analagous to a table full of data ... or a small slice or page of that\n// table, or a collection of rows that belong together for a particular reason\n// -- all of the messages in this particular folder, all of the documents\n// belonging to this particular author, and so on. Collections maintain\n// indexes of their models, both in order, and for lookup by `id`.\n\n// Create a new **Collection**, perhaps to contain a specific type of `model`.\n// If a `comparator` is specified, the Collection will maintain\n// its models in sort order, as they're added and removed.\nvar Collection = Backbone.Collection = function(models, options) {\n  options || (options = {});\n  if (options.model) this.model = options.model;\n  if (options.comparator !== void 0) this.comparator = options.comparator;\n  this._reset();\n  this.initialize.apply(this, arguments);\n  if (models) this.reset(models, _.extend({silent: true}, options));\n};\n\n// Default options for `Collection#set`.\nvar setOptions = {add: true, remove: true, merge: true};\nvar addOptions = {add: true, remove: false};\n\n// Define the Collection's inheritable methods.\n_.extend(Collection.prototype, Events, {\n\n  // The default model for a collection is just a **Backbone.Model**.\n  // This should be overridden in most cases.\n  model: typeof Model === 'undefined' ? null : Model,\n\n  // Initialize is an empty function by default. Override it with your own\n  // initialization logic.\n  initialize: function(){},\n\n  // The JSON representation of a Collection is an array of the\n  // models' attributes.\n  toJSON: function(options) {\n    return this.map(function(model){ return model.toJSON(options); });\n  },\n\n  // Proxy `Backbone.sync` by default.\n  sync: function() {\n    return Backbone.sync.apply(this, arguments);\n  },\n\n  // Add a model, or list of models to the set.\n  add: function(models, options) {\n    return this.set(models, _.extend({merge: false}, options, addOptions));\n  },\n\n  // Remove a model, or a list of models from the set.\n  remove: function(models, options) {\n    var singular = !Array.isArray(models);\n    models = singular ? [models] : models.slice();\n    options || (options = {});\n    var i, l, index, model;\n    for (i = 0, l = models.length; i < l; i++) {\n      model = models[i] = this.get(models[i]);\n      if (!model) continue;\n      delete this._byId[model.id];\n      delete this._byId[model.cid];\n      index = this.indexOf(model);\n      this.models.splice(index, 1);\n      this.length--;\n      if (!options.silent) {\n        options.index = index;\n        model.trigger('remove', model, this, options);\n      }\n      this._removeReference(model);\n    }\n    return singular ? models[0] : models;\n  },\n\n  // Update a collection by `set`-ing a new list of models, adding new ones,\n  // removing models that are no longer present, and merging models that\n  // already exist in the collection, as necessary. Similar to **Model#set**,\n  // the core operation for updating the data contained by the collection.\n  set: function(models, options) {\n    options = _.defaults({}, options, setOptions);\n    if (options.parse) models = this.parse(models, options);\n    var singular = !Array.isArray(models);\n    models = singular ? (models ? [models] : []) : models.slice();\n    var i, l, id, model, attrs, existing, sort;\n    var at = options.at;\n    var targetModel = this.model;\n    var sortable = this.comparator && (at == null) && options.sort !== false;\n    var sortAttr = typeof this.comparator === 'string' ? this.comparator : null;\n    var toAdd = [], toRemove = [], modelMap = {};\n    var add = options.add, merge = options.merge, remove = options.remove;\n    var order = !sortable && add && remove ? [] : false;\n\n    // Turn bare objects into model references, and prevent invalid models\n    // from being added.\n    for (i = 0, l = models.length; i < l; i++) {\n      attrs = models[i];\n      if (attrs instanceof Model) {\n        id = model = attrs;\n      } else {\n        id = attrs[targetModel.prototype.idAttribute];\n      }\n\n      // If a duplicate is found, prevent it from being added and\n      // optionally merge it into the existing model.\n      if (existing = this.get(id)) {\n        if (remove) modelMap[existing.cid] = true;\n        if (merge) {\n          attrs = attrs === model ? model.attributes : attrs;\n          if (options.parse) attrs = existing.parse(attrs, options);\n          existing.set(attrs, options);\n          if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;\n        }\n        models[i] = existing;\n\n      // If this is a new, valid model, push it to the `toAdd` list.\n      } else if (add) {\n        model = models[i] = this._prepareModel(attrs, options);\n        if (!model) continue;\n        toAdd.push(model);\n\n        // Listen to added models' events, and index models for lookup by\n        // `id` and by `cid`.\n        model.on('all', this._onModelEvent, this);\n        this._byId[model.cid] = model;\n        if (model.id != null) this._byId[model.id] = model;\n      }\n      if (order) order.push(existing || model);\n    }\n\n    // Remove nonexistent models if appropriate.\n    if (remove) {\n      for (i = 0, l = this.length; i < l; ++i) {\n        if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);\n      }\n      if (toRemove.length) this.remove(toRemove, options);\n    }\n\n    // See if sorting is needed, update `length` and splice in new models.\n    if (toAdd.length || (order && order.length)) {\n      if (sortable) sort = true;\n      this.length += toAdd.length;\n      if (at != null) {\n        for (i = 0, l = toAdd.length; i < l; i++) {\n          this.models.splice(at + i, 0, toAdd[i]);\n        }\n      } else {\n        if (order) this.models.length = 0;\n        var orderedModels = order || toAdd;\n        for (i = 0, l = orderedModels.length; i < l; i++) {\n          this.models.push(orderedModels[i]);\n        }\n      }\n    }\n\n    // Silently sort the collection if appropriate.\n    if (sort) this.sort({silent: true});\n\n    // Unless silenced, it's time to fire all appropriate add/sort events.\n    if (!options.silent) {\n      for (i = 0, l = toAdd.length; i < l; i++) {\n        (model = toAdd[i]).trigger('add', model, this, options);\n      }\n      if (sort || (order && order.length)) this.trigger('sort', this, options);\n    }\n\n    // Return the added (or merged) model (or models).\n    return singular ? models[0] : models;\n  },\n\n  // When you have more items than you want to add or remove individually,\n  // you can reset the entire set with a new list of models, without firing\n  // any granular `add` or `remove` events. Fires `reset` when finished.\n  // Useful for bulk operations and optimizations.\n  reset: function(models, options) {\n    options || (options = {});\n    for (var i = 0, l = this.models.length; i < l; i++) {\n      this._removeReference(this.models[i]);\n    }\n    options.previousModels = this.models;\n    this._reset();\n    models = this.add(models, _.extend({silent: true}, options));\n    if (!options.silent) this.trigger('reset', this, options);\n    return models;\n  },\n\n  // Add a model to the end of the collection.\n  push: function(model, options) {\n    return this.add(model, _.extend({at: this.length}, options));\n  },\n\n  // Remove a model from the end of the collection.\n  pop: function(options) {\n    var model = this.at(this.length - 1);\n    this.remove(model, options);\n    return model;\n  },\n\n  // Add a model to the beginning of the collection.\n  unshift: function(model, options) {\n    return this.add(model, _.extend({at: 0}, options));\n  },\n\n  // Remove a model from the beginning of the collection.\n  shift: function(options) {\n    var model = this.at(0);\n    this.remove(model, options);\n    return model;\n  },\n\n  // Slice out a sub-array of models from the collection.\n  slice: function() {\n    return slice.apply(this.models, arguments);\n  },\n\n  // Get a model from the set by id.\n  get: function(obj) {\n    if (obj == null) return void 0;\n    return this._byId[obj.id] || this._byId[obj.cid] || this._byId[obj];\n  },\n\n  // Get the model at the given index.\n  at: function(index) {\n    return this.models[index];\n  },\n\n  // Return models with matching attributes. Useful for simple cases of\n  // `filter`.\n  where: function(attrs, first) {\n    if (!attrs || !Object.keys(attrs).length) return first ? void 0 : [];\n    return this[first ? 'find' : 'filter'](function(model) {\n      for (var key in attrs) {\n        if (attrs[key] !== model.get(key)) return false;\n      }\n      return true;\n    });\n  },\n\n  // Return the first model with matching attributes. Useful for simple cases\n  // of `find`.\n  findWhere: function(attrs) {\n    return this.where(attrs, true);\n  },\n\n  // Force the collection to re-sort itself. You don't need to call this under\n  // normal circumstances, as the set will maintain sort order as each item\n  // is added.\n  sort: function(options) {\n    if (!this.comparator) throw new Error('Cannot sort a set without a comparator');\n    options || (options = {});\n\n    // Run sort based on type of `comparator`.\n    if (typeof this.comparator === 'string' || this.comparator.length === 1) {\n      this.models = this.sortBy(this.comparator, this);\n    } else {\n      this.models.sort(this.comparator.bind(this));\n    }\n\n    if (!options.silent) this.trigger('sort', this, options);\n    return this;\n  },\n\n  // Pluck an attribute from each model in the collection.\n  pluck: function(attr) {\n    return this.models.map(function(model) {\n      return model.get(attr);\n    });\n  },\n\n  // Fetch the default set of models for this collection, resetting the\n  // collection when they arrive. If `reset: true` is passed, the response\n  // data will be passed through the `reset` method instead of `set`.\n  fetch: function(options) {\n    options = options ? _.extend({}, options) : {};\n    if (options.parse === void 0) options.parse = true;\n    var success = options.success;\n    var collection = this;\n    options.success = function(resp) {\n      var method = options.reset ? 'reset' : 'set';\n      collection[method](resp, options);\n      if (success) success(collection, resp, options);\n      collection.trigger('sync', collection, resp, options);\n    };\n    wrapError(this, options);\n    return this.sync('read', this, options);\n  },\n\n  // Create a new instance of a model in this collection. Add the model to the\n  // collection immediately, unless `wait: true` is passed, in which case we\n  // wait for the server to agree.\n  create: function(model, options) {\n    options = options ? _.extend({}, options) : {};\n    if (!(model = this._prepareModel(model, options))) return false;\n    if (!options.wait) this.add(model, options);\n    var collection = this;\n    var success = options.success;\n    options.success = function(model, resp, options) {\n      if (options.wait) collection.add(model, options);\n      if (success) success(model, resp, options);\n    };\n    model.save(null, options);\n    return model;\n  },\n\n  // **parse** converts a response into a list of models to be added to the\n  // collection. The default implementation is just to pass it through.\n  parse: function(resp, options) {\n    return resp;\n  },\n\n  // Create a new collection with an identical list of models as this one.\n  clone: function() {\n    return new this.constructor(this.models);\n  },\n\n  // Private method to reset all internal state. Called when the collection\n  // is first initialized or reset.\n  _reset: function() {\n    this.length = 0;\n    this.models = [];\n    this._byId  = Object.create(null);\n  },\n\n  // Prepare a hash of attributes (or other model) to be added to this\n  // collection.\n  _prepareModel: function(attrs, options) {\n    if (attrs instanceof Collection.prototype.model) {\n      if (!attrs.collection) attrs.collection = this;\n      return attrs;\n    }\n    options = options ? _.extend({}, options) : {};\n    options.collection = this;\n    var model = new this.model(attrs, options);\n    if (!model.validationError) return model;\n    this.trigger('invalid', this, model.validationError, options);\n    return false;\n  },\n\n  // Internal method to sever a model's ties to a collection.\n  _removeReference: function(model) {\n    if (this === model.collection) delete model.collection;\n    model.off('all', this._onModelEvent, this);\n  },\n\n  // Internal method called every time a model in the set fires an event.\n  // Sets need to update their indexes when models change ids. All other\n  // events simply proxy through. \"add\" and \"remove\" events that originate\n  // in other collections are ignored.\n  _onModelEvent: function(event, model, collection, options) {\n    if ((event === 'add' || event === 'remove') && collection !== this) return;\n    if (event === 'destroy') this.remove(model, options);\n    if (model && event === 'change:' + model.idAttribute) {\n      delete this._byId[model.previous(model.idAttribute)];\n      if (model.id != null) this._byId[model.id] = model;\n    }\n    this.trigger.apply(this, arguments);\n  }\n\n});\n\nif (utilExists('each')) {\n  // Underscore methods that we want to implement on the Collection.\n  // 90% of the core usefulness of Backbone Collections is actually implemented\n  // right here:\n  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',\n    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',\n    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',\n    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',\n    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',\n    'lastIndexOf', 'isEmpty', 'chain'];\n\n  // Mix in each Underscore method as a proxy to `Collection#models`.\n  methods.filter(utilExists).forEach(function(method) {\n    Collection.prototype[method] = function() {\n      var args = slice.call(arguments);\n      args.unshift(this.models);\n      return _[method].apply(_, args);\n    };\n  });\n\n  // Underscore methods that take a property name as an argument.\n  var attributeMethods = ['groupBy', 'countBy', 'sortBy'];\n\n  // Use attributes instead of properties.\n  attributeMethods.filter(utilExists).forEach(function(method) {\n    Collection.prototype[method] = function(value, context) {\n      var iterator = typeof value === 'function' ? value : function(model) {\n        return model.get(value);\n      };\n      return _[method](this.models, iterator, context);\n    };\n  });\n} else {\n  ['forEach', 'map', 'filter', 'some', 'every', 'reduce', 'reduceRight',\n    'indexOf', 'lastIndexOf'].forEach(function(method) {\n    Collection.prototype[method] = function(arg, context) {\n      return this.models[method](arg, context);\n    };\n  });\n\n  // Exoskeleton-specific:\n  Collection.prototype.find = function(iterator, context) {\n    var result;\n    this.some(function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Underscore methods that take a property name as an argument.\n  ['sortBy'].forEach(function(method) {\n    Collection.prototype[method] = function(value, context) {\n      var iterator = typeof value === 'function' ? value : function(model) {\n        return model.get(value);\n      };\n      return _[method](this.models, iterator, context);\n    };\n  });\n}\n// Backbone.View\n// -------------\n\n// Backbone Views are almost more convention than they are actual code. A View\n// is simply a JavaScript object that represents a logical chunk of UI in the\n// DOM. This might be a single item, an entire list, a sidebar or panel, or\n// even the surrounding frame which wraps your whole app. Defining a chunk of\n// UI as a **View** allows you to define your DOM events declaratively, without\n// having to worry about render order ... and makes it easy for the view to\n// react to specific changes in the state of your models.\n\n// Options with special meaning *(e.g. model, collection, id, className)* are\n// attached directly to the view.  See `viewOptions` for an exhaustive\n// list.\n\n// Cached regex to split keys for `delegate`.\nvar delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n\n// List of view options to be merged as properties.\nvar viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];\n\n// Creating a Backbone.View creates its initial element outside of the DOM,\n// if an existing element is not provided...\nvar View = Backbone.View = function(options) {\n  this.cid = _.uniqueId('view');\n  if (options) Object.keys(options).forEach(function(key) {\n    if (viewOptions.indexOf(key) !== -1) this[key] = options[key];\n  }, this);\n  this._handlers = [];\n  this._ensureElement();\n  this.initialize.apply(this, arguments);\n  this.delegateEvents();\n};\n\n// Set up all inheritable **Backbone.View** properties and methods.\n_.extend(View.prototype, Events, {\n  // In case you want to include jQuery with your app\n  // for *some* views and use native methods for other views.\n  useNative: false,\n\n  // The default `tagName` of a View's element is `\"div\"`.\n  tagName: 'div',\n\n  // jQuery delegate for element lookup, scoped to DOM elements within the\n  // current view. This should be preferred to global lookups where possible.\n  $: function(selector) {\n    return Backbone.$ && !this.useNative ? this.$el.find(selector) : this.findAll(selector);\n  },\n\n  // Exoskeleton-related DOM methods.\n  find: function(selector) {\n    return this.el.querySelector(selector);\n  },\n\n  findAll: function(selector) {\n    return slice.call(this.el.querySelectorAll(selector));\n  },\n\n  // Initialize is an empty function by default. Override it with your own\n  // initialization logic.\n  initialize: function(){},\n\n  // **render** is the core function that your view should override, in order\n  // to populate its element (`this.el`), with the appropriate HTML. The\n  // convention is for **render** to always return `this`.\n  render: function() {\n    return this;\n  },\n\n  // Remove this view by taking the element out of the DOM, and removing any\n  // applicable Backbone.Events listeners.\n  remove: function() {\n    var parent;\n    if (Backbone.$ && !this.useNative) {\n      this.$el.remove();\n    } else if (parent = this.el.parentNode) {\n      parent.removeChild(this.el);\n    }\n    this.stopListening();\n    return this;\n  },\n\n  // Change the view's element (`this.el` property), including event\n  // re-delegation.\n  setElement: function(element, delegate) {\n    if (Backbone.$ && !this.useNative) {\n      if (this.$el) this.undelegateEvents();\n      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);\n      this.el = this.$el[0];\n    } else {\n      if (this.el) this.undelegateEvents();\n      this.el = (typeof element === 'string') ?\n        document.querySelector(element) : element;\n    }\n    if (delegate !== false) this.delegateEvents();\n    return this;\n  },\n\n  // Set callbacks, where `this.events` is a hash of\n  //\n  // *{\"event selector\": \"callback\"}*\n  //\n  //     {\n  //       'mousedown .title':  'edit',\n  //       'click .button':     'save',\n  //       'click .open':       function(e) { ... }\n  //     }\n  //\n  // pairs. Callbacks will be bound to the view, with `this` set properly.\n  // Uses event delegation for efficiency.\n  // Omitting the selector binds the event to `this.el`.\n  // This only works for delegate-able events: not `focus`, `blur`, and\n  // not `change`, `submit`, and `reset` in Internet Explorer.\n  delegateEvents: function(events, keepOld) {\n    if (!(events || (events = _.result(this, 'events')))) return this;\n    if (!keepOld) this.undelegateEvents();\n    for (var key in events) {\n      var method = events[key];\n      if (typeof method !== 'function') method = this[events[key]];\n      // if (!method) continue;\n\n      var match = key.match(delegateEventSplitter);\n      var eventName = match[1], selector = match[2];\n\n      if (Backbone.$ && !this.useNative) {\n        eventName += '.delegateEvents' + this.cid;\n        method = method.bind(this);\n        this.$el.on(eventName, (selector ? selector : null), method);\n      } else {\n        utils.delegate(this, eventName, selector, method);\n      }\n    }\n    return this;\n  },\n\n  // Clears all callbacks previously bound to the view with `delegateEvents`.\n  // You usually don't need to use this, but may wish to if you have multiple\n  // Backbone views attached to the same DOM element.\n  undelegateEvents: function() {\n    if (Backbone.$ && !this.useNative) {\n      this.$el.off('.delegateEvents' + this.cid);\n    } else {\n      utils.undelegate(this);\n    }\n    return this;\n  },\n\n  // Ensure that the View has a DOM element to render into.\n  // If `this.el` is a string, pass it through `$()`, take the first\n  // matching element, and re-assign it to `el`. Otherwise, create\n  // an element from the `id`, `className` and `tagName` properties.\n  _ensureElement: function() {\n    if (!this.el) {\n      var attrs = _.extend({}, _.result(this, 'attributes'));\n      if (this.id) attrs.id = _.result(this, 'id');\n      if (this.className) attrs.className = _.result(this, 'className');\n      if (attrs['class']) attrs.className = attrs['class'];\n      var el = _.extend(document.createElement(_.result(this, 'tagName')), attrs);\n      this.setElement(el, false);\n    } else {\n      this.setElement(_.result(this, 'el'), false);\n    }\n  }\n\n});\n// Backbone.sync\n// -------------\n\n// Override this function to change the manner in which Backbone persists\n// models to the server. You will be passed the type of request, and the\n// model in question. By default, makes a RESTful Ajax request\n// to the model's `url()`. Some possible customizations could be:\n//\n// * Use `setTimeout` to batch rapid-fire updates into a single request.\n// * Send up the models as XML instead of JSON.\n// * Persist models via WebSockets instead of Ajax.\n//\n// Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests\n// as `POST`, with a `_method` parameter containing the true HTTP method,\n// as well as all requests with the body as `application/x-www-form-urlencoded`\n// instead of `application/json` with the model in a param named `model`.\n// Useful when interfacing with server-side languages like **PHP** that make\n// it difficult to read the body of `PUT` requests.\nBackbone.sync = function(method, model, options) {\n  var type = methodMap[method];\n\n  // Default options, unless specified.\n  _.defaults(options || (options = {}), {\n    emulateHTTP: Backbone.emulateHTTP,\n    emulateJSON: Backbone.emulateJSON\n  });\n\n  // Default JSON-request options.\n  var params = {type: type, dataType: 'json'};\n\n  // Ensure that we have a URL.\n  if (!options.url) {\n    params.url = _.result(model, 'url') || urlError();\n  }\n\n  // Ensure that we have the appropriate request data.\n  if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {\n    params.contentType = 'application/json';\n    params.data = JSON.stringify(options.attrs || model.toJSON(options));\n  }\n\n  // For older servers, emulate JSON by encoding the request into an HTML-form.\n  if (options.emulateJSON) {\n    params.contentType = 'application/x-www-form-urlencoded';\n    params.data = params.data ? {model: params.data} : {};\n  }\n\n  // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\n  // And an `X-HTTP-Method-Override` header.\n  if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {\n    params.type = 'POST';\n    if (options.emulateJSON) params.data._method = type;\n    var beforeSend = options.beforeSend;\n    options.beforeSend = function(xhr) {\n      xhr.setRequestHeader('X-HTTP-Method-Override', type);\n      if (beforeSend) return beforeSend.apply(this, arguments);\n    };\n  }\n\n  // Don't process data on a non-GET request.\n  if (params.type !== 'GET' && !options.emulateJSON) {\n    params.processData = false;\n  }\n\n  // Make the request, allowing the user to override any Ajax options.\n  var xhr = options.xhr = Backbone.ajax(_.extend(params, options));\n  model.trigger('request', model, xhr, options);\n  return xhr;\n};\n\n// Map from CRUD to HTTP for our default `Backbone.sync` implementation.\nvar methodMap = {\n  'create': 'POST',\n  'update': 'PUT',\n  'patch':  'PATCH',\n  'delete': 'DELETE',\n  'read':   'GET'\n};\n\n// Set the default implementation of `Backbone.ajax` to proxy through to `$`.\n// Override this if you'd like to use a different library.\nBackbone.ajax = Backbone.$ ? function() {\n  return Backbone.$.ajax.apply(Backbone.$, arguments);\n} : utils.ajax;\n\nif (Backbone.$) Backbone.Deferred = function() {\n  return new Backbone.$.Deferred();\n};\n// Backbone.Router\n// ---------------\n\n// Routers map faux-URLs to actions, and fire events when routes are\n// matched. Creating a new one sets its `routes` hash, if not set statically.\nvar Router = Backbone.Router = function(options) {\n  options || (options = {});\n  if (options.routes) this.routes = options.routes;\n  this._bindRoutes();\n  this.initialize.apply(this, arguments);\n};\n\n// Cached regular expressions for matching named param parts and splatted\n// parts of route strings.\nvar optionalParam = /\\((.*?)\\)/g;\nvar namedParam    = /(\\(\\?)?:\\w+/g;\nvar splatParam    = /\\*\\w+/g;\nvar escapeRegExp  = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\n\nvar isRegExp = function(value) {\n  return value ? (typeof value === 'object' && toString.call(value) === '[object RegExp]') : false;\n};\n\n// Set up all inheritable **Backbone.Router** properties and methods.\n_.extend(Router.prototype, Events, {\n\n  // Initialize is an empty function by default. Override it with your own\n  // initialization logic.\n  initialize: function(){},\n\n  // Manually bind a single named route to a callback. For example:\n  //\n  //     this.route('search/:query/p:num', 'search', function(query, num) {\n  //       ...\n  //     });\n  //\n  route: function(route, name, callback) {\n    if (!isRegExp(route)) route = this._routeToRegExp(route);\n    if (typeof name === 'function') {\n      callback = name;\n      name = '';\n    }\n    if (!callback) callback = this[name];\n    var router = this;\n    Backbone.history.route(route, function(fragment) {\n      var args = router._extractParameters(route, fragment);\n      callback && callback.apply(router, args);\n      router.trigger.apply(router, ['route:' + name].concat(args));\n      router.trigger('route', name, args);\n      Backbone.history.trigger('route', router, name, args);\n    });\n    return this;\n  },\n\n  // Simple proxy to `Backbone.history` to save a fragment into the history.\n  navigate: function(fragment, options) {\n    Backbone.history.navigate(fragment, options);\n    return this;\n  },\n\n  // Bind all defined routes to `Backbone.history`. We have to reverse the\n  // order of the routes here to support behavior where the most general\n  // routes can be defined at the bottom of the route map.\n  _bindRoutes: function() {\n    if (!this.routes) return;\n    this.routes = _.result(this, 'routes');\n    var route, routes = Object.keys(this.routes);\n    while ((route = routes.pop()) != null) {\n      this.route(route, this.routes[route]);\n    }\n  },\n\n  // Convert a route string into a regular expression, suitable for matching\n  // against the current location hash.\n  _routeToRegExp: function(route) {\n    route = route.replace(escapeRegExp, '\\\\$&')\n                 .replace(optionalParam, '(?:$1)?')\n                 .replace(namedParam, function(match, optional) {\n                   return optional ? match : '([^\\/]+)';\n                 })\n                 .replace(splatParam, '(.*?)');\n    return new RegExp('^' + route + '$');\n  },\n\n  // Given a route, and a URL fragment that it matches, return the array of\n  // extracted decoded parameters. Empty or unmatched parameters will be\n  // treated as `null` to normalize cross-browser behavior.\n  _extractParameters: function(route, fragment) {\n    var params = route.exec(fragment).slice(1);\n    return params.map(function(param) {\n      return param ? decodeURIComponent(param) : null;\n    });\n  }\n\n});\n// Backbone.History\n// ----------------\n\n// Handles cross-browser history management, based on either\n// [pushState](http://diveintohtml5.info/history.html) and real URLs, or\n// [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\n// and URL fragments.\nvar History = Backbone.History = function() {\n  this.handlers = [];\n  this.checkUrl = this.checkUrl.bind(this);\n\n  // Ensure that `History` can be used outside of the browser.\n  if (typeof window !== 'undefined') {\n    this.location = window.location;\n    this.history = window.history;\n  }\n};\n\n// Cached regex for stripping a leading hash/slash and trailing space.\nvar routeStripper = /^[#\\/]|\\s+$/g;\n\n// Cached regex for stripping leading and trailing slashes.\nvar rootStripper = /^\\/+|\\/+$/g;\n\n// Cached regex for removing a trailing slash.\nvar trailingSlash = /\\/$/;\n\n// Cached regex for stripping urls of hash and query.\nvar pathStripper = /[#].*$/;\n\n// Has the history handling already been started?\nHistory.started = false;\n\n// Set up all inheritable **Backbone.History** properties and methods.\n_.extend(History.prototype, Events, {\n\n  // Gets the true hash value. Cannot use location.hash directly due to bug\n  // in Firefox where location.hash will always be decoded.\n  getHash: function(window) {\n    var match = (window || this).location.href.match(/#(.*)$/);\n    return match ? match[1] : '';\n  },\n\n  // Get the cross-browser normalized URL fragment, either from the URL,\n  // the hash, or the override.\n  getFragment: function(fragment) {\n    if (fragment == null) {\n      if (this._wantsPushState || !this._wantsHashChange) {\n        // CHANGED: Make fragment include query string.\n        fragment = this.location.pathname + this.location.search;\n        var root = this.root.replace(trailingSlash, '');\n        if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);\n      } else {\n        fragment = this.getHash();\n      }\n    }\n    return fragment.replace(routeStripper, '');\n  },\n\n  // Start the hash change handling, returning `true` if the current URL matches\n  // an existing route, and `false` otherwise.\n  start: function(options) {\n    if (History.started) throw new Error(\"Backbone.history has already been started\");\n    History.started = true;\n\n    // Figure out the initial configuration.\n    // Is pushState desired or should we use hashchange only?\n    this.options          = _.extend({root: '/'}, this.options, options);\n    this.root             = this.options.root;\n    this._wantsHashChange = this.options.hashChange !== false;\n    this._wantsPushState  = !!this.options.pushState;\n    var fragment          = this.getFragment();\n\n    // Normalize root to always include a leading and trailing slash.\n    this.root = ('/' + this.root + '/').replace(rootStripper, '/');\n\n    // Depending on whether we're using pushState or hashes, determine how we\n    // check the URL state.\n    if (this._wantsPushState) {\n      window.addEventListener('popstate', this.checkUrl, false);\n    } else if (this._wantsHashChange) {\n      window.addEventListener('hashchange', this.checkUrl, false);\n    }\n\n    // Determine if we need to change the base url, for a pushState link\n    // opened by a non-pushState browser.\n    this.fragment = fragment;\n    var loc = this.location;\n    var atRoot = loc.pathname.replace(/[^\\/]$/, '$&/') === this.root;\n\n    // Transition from hashChange to pushState or vice versa if both are\n    // requested.\n    if (this._wantsHashChange && this._wantsPushState) {\n      // If we've started out with a hash-based route, but we're currently\n      // in a browser where it could be `pushState`-based instead...\n      if (atRoot && loc.hash) {\n        this.fragment = this.getHash().replace(routeStripper, '');\n        // CHANGED: It's no longer needed to add loc.search at the end,\n        // as query params have been already included into @fragment\n        this.history.replaceState({}, document.title, this.root + this.fragment);\n      }\n\n    }\n\n    if (!this.options.silent) return this.loadUrl();\n  },\n\n  // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\n  // but possibly useful for unit testing Routers.\n  stop: function() {\n    window.removeEventListener('popstate', this.checkUrl);\n    window.removeEventListener('hashchange', this.checkUrl);\n    History.started = false;\n  },\n\n  // Add a route to be tested when the fragment changes. Routes added later\n  // may override previous routes.\n  route: function(route, callback) {\n    this.handlers.unshift({route: route, callback: callback});\n  },\n\n  // Checks the current URL to see if it has changed, and if it has,\n  // calls `loadUrl`.\n  checkUrl: function() {\n    var current = this.getFragment();\n    if (current === this.fragment) return false;\n    this.loadUrl();\n  },\n\n  // Attempt to load the current URL fragment. If a route succeeds with a\n  // match, returns `true`. If no defined routes matches the fragment,\n  // returns `false`.\n  loadUrl: function(fragment) {\n    fragment = this.fragment = this.getFragment(fragment);\n    return this.handlers.some(function(handler) {\n      if (handler.route.test(fragment)) {\n        handler.callback(fragment);\n        return true;\n      }\n    });\n  },\n\n  // Save a fragment into the hash history, or replace the URL state if the\n  // 'replace' option is passed. You are responsible for properly URL-encoding\n  // the fragment in advance.\n  //\n  // The options object can contain `trigger: true` if you wish to have the\n  // route callback be fired (not usually desirable), or `replace: true`, if\n  // you wish to modify the current URL without adding an entry to the history.\n  navigate: function(fragment, options) {\n    if (!History.started) return false;\n    if (!options || options === true) options = {trigger: !!options};\n\n    var url = this.root + (fragment = this.getFragment(fragment || ''));\n\n    // Strip the fragment of the query and hash for matching.\n    fragment = fragment.replace(pathStripper, '');\n\n    if (this.fragment === fragment) return;\n    this.fragment = fragment;\n\n    // Don't include a trailing slash on the root.\n    if (fragment === '' && url !== '/') url = url.slice(0, -1);\n\n    // If we're using pushState we use it to set the fragment as a real URL.\n    if (this._wantsPushState) {\n      this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\n\n    // If hash changes haven't been explicitly disabled, update the hash\n    // fragment to store history.\n    } else if (this._wantsHashChange) {\n      this._updateHash(this.location, fragment, options.replace);\n    // If you've told us that you explicitly don't want fallback hashchange-\n    // based history, then `navigate` becomes a page refresh.\n    } else {\n      return this.location.assign(url);\n    }\n    if (options.trigger) return this.loadUrl(fragment);\n  },\n\n  // Update the hash location, either replacing the current entry, or adding\n  // a new one to the browser history.\n  _updateHash: function(location, fragment, replace) {\n    if (replace) {\n      var href = location.href.replace(/(javascript:|#).*$/, '');\n      location.replace(href + '#' + fragment);\n    } else {\n      // Some browsers require that `hash` contains a leading #.\n      location.hash = '#' + fragment;\n    }\n  }\n\n});\n  // !!!\n  // Init.\n  ['Model', 'Collection', 'Router', 'View', 'History'].forEach(function(name) {\n    var item = Backbone[name];\n    if (item) item.extend = Backbone.extend;\n  });\n\n  // Allow the `Backbone` object to serve as a global event bus, for folks who\n  // want global \"pubsub\" in a convenient place.\n  _.extend(Backbone, Events);\n\n  // Create the default Backbone.history.\n  Backbone.history = new History();\n  return Backbone;\n});\n","/*!\n * Chaplin 0.12.0\n *\n * Chaplin may be freely distributed under the MIT license.\n * For all details and documentation:\n * http://chaplinjs.org\n */\n\n(function(){\n\nvar loader = (function() {\n  var modules = {};\n  var cache = {};\n\n  var dummy = function() {return function() {};};\n  var initModule = function(name, definition) {\n    var module = {id: name, exports: {}};\n    definition(module.exports, dummy(), module);\n    var exports = cache[name] = module.exports;\n    return exports;\n  };\n\n  var loader = function(path) {\n    if (cache.hasOwnProperty(path)) return cache[path];\n    if (modules.hasOwnProperty(path)) return initModule(path, modules[path]);\n    throw new Error('Cannot find module \"' + path + '\"');\n  };\n\n  loader.register = function(bundle, fn) {\n    modules[bundle] = fn;\n  };\n  return loader;\n})();\n\nloader.register('chaplin/application', function(e, r, module) {\n'use strict';\n\nvar Application, Backbone, Composer, Dispatcher, EventBroker, Layout, Router, mediator, _;\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nmediator = loader('chaplin/mediator');\n\nDispatcher = loader('chaplin/dispatcher');\n\nLayout = loader('chaplin/views/layout');\n\nComposer = loader('chaplin/composer');\n\nRouter = loader('chaplin/lib/router');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nmodule.exports = Application = (function() {\n\n  Application.extend = Backbone.Model.extend;\n\n  _.extend(Application.prototype, EventBroker);\n\n  Application.prototype.title = '';\n\n  Application.prototype.dispatcher = null;\n\n  Application.prototype.layout = null;\n\n  Application.prototype.router = null;\n\n  Application.prototype.composer = null;\n\n  Application.prototype.started = false;\n\n  function Application(options) {\n    if (options == null) {\n      options = {};\n    }\n    this.initialize(options);\n  }\n\n  Application.prototype.initialize = function(options) {\n    if (options == null) {\n      options = {};\n    }\n    if (this.started) {\n      throw new Error('Application#initialize: App was already started');\n    }\n    this.initRouter(options.routes, options);\n    this.initDispatcher(options);\n    this.initLayout(options);\n    this.initComposer(options);\n    this.initMediator();\n    return this.start();\n  };\n\n  Application.prototype.initDispatcher = function(options) {\n    return this.dispatcher = new Dispatcher(options);\n  };\n\n  Application.prototype.initLayout = function(options) {\n    var _ref;\n    if (options == null) {\n      options = {};\n    }\n    if ((_ref = options.title) == null) {\n      options.title = this.title;\n    }\n    return this.layout = new Layout(options);\n  };\n\n  Application.prototype.initComposer = function(options) {\n    if (options == null) {\n      options = {};\n    }\n    return this.composer = new Composer(options);\n  };\n\n  Application.prototype.initMediator = function() {\n    return mediator.seal();\n  };\n\n  Application.prototype.initRouter = function(routes, options) {\n    this.router = new Router(options);\n    return typeof routes === \"function\" ? routes(this.router.match) : void 0;\n  };\n\n  Application.prototype.start = function() {\n    this.router.startHistory();\n    this.started = true;\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  Application.prototype.disposed = false;\n\n  Application.prototype.dispose = function() {\n    var frozen, prop, properties, _i, _len;\n    if (this.disposed) {\n      return;\n    }\n    frozen = typeof Object.isFrozen === \"function\" ? Object.isFrozen(this) : void 0;\n    properties = ['dispatcher', 'layout', 'router', 'composer'];\n    for (_i = 0, _len = properties.length; _i < _len; _i++) {\n      prop = properties[_i];\n      if (!(this[prop] != null)) {\n        continue;\n      }\n      this[prop].dispose();\n      if (!frozen) {\n        delete this[prop];\n      }\n    }\n    this.disposed = true;\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  return Application;\n\n})();\n\n});;loader.register('chaplin/mediator', function(e, r, module) {\n'use strict';\n\nvar Backbone, handlers, mediator, support, utils, _,\n  __slice = [].slice;\n\nBackbone = loader('backbone');\n\n_ = loader('underscore');\n\nsupport = loader('chaplin/lib/support');\n\nutils = loader('chaplin/lib/utils');\n\nmediator = {};\n\nmediator.subscribe = Backbone.Events.on;\n\nmediator.unsubscribe = Backbone.Events.off;\n\nmediator.publish = Backbone.Events.trigger;\n\nmediator._callbacks = null;\n\nhandlers = mediator._handlers = {};\n\nmediator.setHandler = function(name, method, instance) {\n  return handlers[name] = {\n    instance: instance,\n    method: method\n  };\n};\n\nmediator.execute = function() {\n  var args, handler, name, nameOrObj, silent;\n  nameOrObj = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n  silent = false;\n  if (typeof nameOrObj === 'object') {\n    silent = nameOrObj.silent;\n    name = nameOrObj.name;\n  } else {\n    name = nameOrObj;\n  }\n  handler = handlers[name];\n  if (handler) {\n    return handler.method.apply(handler.instance, args);\n  } else if (!silent) {\n    throw new Error(\"mediator.execute: \" + name + \" handler is not defined\");\n  }\n};\n\nmediator.removeHandlers = function(instanceOrNames) {\n  var handler, name, _i, _len;\n  if (!instanceOrNames) {\n    mediator._handlers = {};\n  }\n  if (utils.isArray(instanceOrNames)) {\n    for (_i = 0, _len = instanceOrNames.length; _i < _len; _i++) {\n      name = instanceOrNames[_i];\n      delete handlers[name];\n    }\n  } else {\n    for (name in handlers) {\n      handler = handlers[name];\n      if (handler.instance === instanceOrNames) {\n        delete handlers[name];\n      }\n    }\n  }\n};\n\nutils.readonly(mediator, 'subscribe', 'unsubscribe', 'publish', 'setHandler', 'execute', 'removeHandlers');\n\nmediator.seal = function() {\n  if (support.propertyDescriptors && Object.seal) {\n    return Object.seal(mediator);\n  }\n};\n\nutils.readonly(mediator, 'seal');\n\nmodule.exports = mediator;\n\n});;loader.register('chaplin/dispatcher', function(e, r, module) {\n'use strict';\n\nvar Backbone, Dispatcher, EventBroker, mediator, utils, _;\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nmediator = loader('chaplin/mediator');\n\nutils = loader('chaplin/lib/utils');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nmodule.exports = Dispatcher = (function() {\n\n  Dispatcher.extend = Backbone.Model.extend;\n\n  _.extend(Dispatcher.prototype, EventBroker);\n\n  Dispatcher.prototype.previousRoute = null;\n\n  Dispatcher.prototype.currentController = null;\n\n  Dispatcher.prototype.currentRoute = null;\n\n  Dispatcher.prototype.currentParams = null;\n\n  Dispatcher.prototype.currentQuery = null;\n\n  function Dispatcher() {\n    this.initialize.apply(this, arguments);\n  }\n\n  Dispatcher.prototype.initialize = function(options) {\n    if (options == null) {\n      options = {};\n    }\n    this.settings = _.defaults(options, {\n      controllerPath: 'controllers/',\n      controllerSuffix: '_controller'\n    });\n    return this.subscribeEvent('router:match', this.dispatch);\n  };\n\n  Dispatcher.prototype.dispatch = function(route, params, options) {\n    var _ref, _ref1,\n      _this = this;\n    params = params ? _.extend({}, params) : {};\n    options = options ? _.extend({}, options) : {};\n    if (!(options.query != null)) {\n      options.query = {};\n    }\n    if (options.changeURL !== false) {\n      options.changeURL = true;\n    }\n    if (options.forceStartup !== true) {\n      options.forceStartup = false;\n    }\n    if (!options.forceStartup && ((_ref = this.currentRoute) != null ? _ref.controller : void 0) === route.controller && ((_ref1 = this.currentRoute) != null ? _ref1.action : void 0) === route.action && _.isEqual(this.currentParams, params) && _.isEqual(this.currentQuery, options.query)) {\n      return;\n    }\n    return this.loadController(route.controller, function(Controller) {\n      return _this.controllerLoaded(route, params, options, Controller);\n    });\n  };\n\n  Dispatcher.prototype.loadController = function(name, handler) {\n    var fileName, moduleName,\n      _this = this;\n    fileName = name + this.settings.controllerSuffix;\n    moduleName = this.settings.controllerPath + fileName;\n    if (typeof define !== \"undefined\" && define !== null ? define.amd : void 0) {\n      return require([moduleName], handler);\n    } else {\n      return setTimeout(function() {\n        return handler(require(moduleName));\n      }, 0);\n    }\n  };\n\n  Dispatcher.prototype.controllerLoaded = function(route, params, options, Controller) {\n    var controller;\n    this.previousRoute = this.currentRoute;\n    this.currentRoute = _.extend({}, route, {\n      previous: utils.beget(this.previousRoute)\n    });\n    controller = new Controller(params, this.currentRoute, options);\n    return this.executeBeforeAction(controller, this.currentRoute, params, options);\n  };\n\n  Dispatcher.prototype.executeAction = function(controller, route, params, options) {\n    if (this.currentController) {\n      this.publishEvent('beforeControllerDispose', this.currentController);\n      this.currentController.dispose(params, route, options);\n    }\n    this.currentController = controller;\n    this.currentParams = params;\n    this.currentQuery = options.query;\n    controller[route.action](params, route, options);\n    if (controller.redirected) {\n      return;\n    }\n    this.adjustURL(route, params, options);\n    return this.publishEvent('dispatcher:dispatch', this.currentController, params, route, options);\n  };\n\n  Dispatcher.prototype.executeBeforeAction = function(controller, route, params, options) {\n    var before, executeAction, promise,\n      _this = this;\n    before = controller.beforeAction;\n    executeAction = function() {\n      if (controller.redirected || _this.currentRoute && route !== _this.currentRoute) {\n        controller.dispose();\n        return;\n      }\n      return _this.executeAction(controller, route, params, options);\n    };\n    if (!before) {\n      executeAction();\n      return;\n    }\n    if (typeof before !== 'function') {\n      throw new TypeError('Controller#beforeAction: function expected. ' + 'Old object-like form is not supported.');\n    }\n    promise = controller.beforeAction(params, route, options);\n    if (promise && promise.then) {\n      return promise.then(executeAction);\n    } else {\n      return executeAction();\n    }\n  };\n\n  Dispatcher.prototype.adjustURL = function(route, params, options) {\n    var url;\n    if (route.path == null) {\n      return;\n    }\n    url = route.path + (route.query ? \"?\" + route.query : \"\");\n    if (options.changeURL) {\n      return mediator.execute('router:changeURL', url, options);\n    }\n  };\n\n  Dispatcher.prototype.disposed = false;\n\n  Dispatcher.prototype.dispose = function() {\n    if (this.disposed) {\n      return;\n    }\n    this.unsubscribeAllEvents();\n    this.disposed = true;\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  return Dispatcher;\n\n})();\n\n});;loader.register('chaplin/composer', function(e, r, module) {\n'use strict';\n\nvar Backbone, Composer, Composition, EventBroker, mediator, utils, _;\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nmediator = loader('chaplin/mediator');\n\nutils = loader('chaplin/lib/utils');\n\nComposition = loader('chaplin/lib/composition');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nmodule.exports = Composer = (function() {\n\n  Composer.extend = Backbone.Model.extend;\n\n  _.extend(Composer.prototype, EventBroker);\n\n  Composer.prototype.compositions = null;\n\n  function Composer() {\n    this.initialize.apply(this, arguments);\n  }\n\n  Composer.prototype.initialize = function(options) {\n    if (options == null) {\n      options = {};\n    }\n    this.compositions = {};\n    mediator.setHandler('composer:compose', this.compose, this);\n    mediator.setHandler('composer:retrieve', this.retrieve, this);\n    return this.subscribeEvent('dispatcher:dispatch', this.cleanup);\n  };\n\n  Composer.prototype.compose = function(name, second, third) {\n    if (typeof second === 'function') {\n      if (third || second.prototype.dispose) {\n        if (second.prototype instanceof Composition) {\n          return this._compose(name, {\n            composition: second,\n            options: third\n          });\n        } else {\n          return this._compose(name, {\n            options: third,\n            compose: function() {\n              var autoRender, disabledAutoRender;\n              this.item = new second(this.options);\n              autoRender = this.item.autoRender;\n              disabledAutoRender = autoRender === void 0 || !autoRender;\n              if (disabledAutoRender && typeof this.item.render === 'function') {\n                return this.item.render();\n              }\n            }\n          });\n        }\n      }\n      return this._compose(name, {\n        compose: second\n      });\n    }\n    if (typeof third === 'function') {\n      return this._compose(name, {\n        compose: third,\n        options: second\n      });\n    }\n    return this._compose(name, second);\n  };\n\n  Composer.prototype._compose = function(name, options) {\n    var composition, current, isPromise, returned;\n    if (typeof options.compose !== 'function' && !(options.composition != null)) {\n      throw new Error('Composer#compose was used incorrectly');\n    }\n    if (options.composition != null) {\n      composition = new options.composition(options.options);\n    } else {\n      composition = new Composition(options.options);\n      composition.compose = options.compose;\n      if (options.check) {\n        composition.check = options.check;\n      }\n    }\n    current = this.compositions[name];\n    isPromise = false;\n    if (current && current.check(composition.options)) {\n      current.stale(false);\n    } else {\n      if (current) {\n        current.dispose();\n      }\n      returned = composition.compose(composition.options);\n      isPromise = typeof (returned != null ? returned.then : void 0) === 'function';\n      composition.stale(false);\n      this.compositions[name] = composition;\n    }\n    if (isPromise) {\n      return returned;\n    } else {\n      return this.compositions[name].item;\n    }\n  };\n\n  Composer.prototype.retrieve = function(name) {\n    var active;\n    active = this.compositions[name];\n    if (active && !active.stale()) {\n      return active.item;\n    } else {\n      return void 0;\n    }\n  };\n\n  Composer.prototype.cleanup = function() {\n    var composition, name, _ref;\n    _ref = this.compositions;\n    for (name in _ref) {\n      composition = _ref[name];\n      if (composition.stale()) {\n        composition.dispose();\n        delete this.compositions[name];\n      } else {\n        composition.stale(true);\n      }\n    }\n  };\n\n  Composer.prototype.dispose = function() {\n    var composition, name, _ref;\n    if (this.disposed) {\n      return;\n    }\n    this.unsubscribeAllEvents();\n    mediator.removeHandlers(this);\n    _ref = this.compositions;\n    for (name in _ref) {\n      composition = _ref[name];\n      composition.dispose();\n    }\n    delete this.compositions;\n    this.disposed = true;\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  return Composer;\n\n})();\n\n});;loader.register('chaplin/controllers/controller', function(e, r, module) {\n'use strict';\n\nvar Backbone, Controller, EventBroker, mediator, utils, _,\n  __slice = [].slice,\n  __hasProp = {}.hasOwnProperty;\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nutils = loader('chaplin/lib/utils');\n\nmediator = loader('chaplin/mediator');\n\nmodule.exports = Controller = (function() {\n\n  Controller.extend = Backbone.Model.extend;\n\n  _.extend(Controller.prototype, Backbone.Events);\n\n  _.extend(Controller.prototype, EventBroker);\n\n  Controller.prototype.view = null;\n\n  Controller.prototype.redirected = false;\n\n  function Controller() {\n    this.initialize.apply(this, arguments);\n  }\n\n  Controller.prototype.initialize = function() {};\n\n  Controller.prototype.beforeAction = function() {};\n\n  Controller.prototype.adjustTitle = function(subtitle) {\n    return mediator.execute('adjustTitle', subtitle);\n  };\n\n  Controller.prototype.compose = function(name) {\n    var method;\n    method = arguments.length === 1 ? 'retrieve' : 'compose';\n    return mediator.execute.apply(mediator, [\"composer:\" + method].concat(__slice.call(arguments)));\n  };\n\n  Controller.prototype.redirectTo = function(pathDesc, params, options) {\n    this.redirected = true;\n    return utils.redirectTo(pathDesc, params, options);\n  };\n\n  Controller.prototype.disposed = false;\n\n  Controller.prototype.dispose = function() {\n    var obj, prop;\n    if (this.disposed) {\n      return;\n    }\n    for (prop in this) {\n      if (!__hasProp.call(this, prop)) continue;\n      obj = this[prop];\n      if (!(obj && typeof obj.dispose === 'function')) {\n        continue;\n      }\n      obj.dispose();\n      delete this[prop];\n    }\n    this.unsubscribeAllEvents();\n    this.stopListening();\n    this.disposed = true;\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  return Controller;\n\n})();\n\n});;loader.register('chaplin/models/collection', function(e, r, module) {\n'use strict';\n\nvar Backbone, Collection, EventBroker, Model, utils, _,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nModel = loader('chaplin/models/model');\n\nutils = loader('chaplin/lib/utils');\n\nmodule.exports = Collection = (function(_super) {\n\n  __extends(Collection, _super);\n\n  function Collection() {\n    return Collection.__super__.constructor.apply(this, arguments);\n  }\n\n  _.extend(Collection.prototype, EventBroker);\n\n  Collection.prototype.model = Model;\n\n  Collection.prototype.serialize = function() {\n    return this.map(utils.serialize);\n  };\n\n  Collection.prototype.disposed = false;\n\n  Collection.prototype.dispose = function() {\n    var prop, properties, _i, _len;\n    if (this.disposed) {\n      return;\n    }\n    this.trigger('dispose', this);\n    this.reset([], {\n      silent: true\n    });\n    this.unsubscribeAllEvents();\n    this.stopListening();\n    this.off();\n    properties = ['model', 'models', '_byId', '_byCid', '_callbacks'];\n    for (_i = 0, _len = properties.length; _i < _len; _i++) {\n      prop = properties[_i];\n      delete this[prop];\n    }\n    this.disposed = true;\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  return Collection;\n\n})(Backbone.Collection);\n\n});;loader.register('chaplin/models/model', function(e, r, module) {\n'use strict';\n\nvar Backbone, EventBroker, Model, serializeAttributes, serializeModelAttributes, utils, _,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nutils = loader('chaplin/lib/utils');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nserializeAttributes = function(model, attributes, modelStack) {\n  var delegator, key, otherModel, serializedModels, value, _i, _len, _ref;\n  delegator = utils.beget(attributes);\n  if (modelStack == null) {\n    modelStack = {};\n  }\n  modelStack[model.cid] = true;\n  for (key in attributes) {\n    value = attributes[key];\n    if (value instanceof Backbone.Model) {\n      delegator[key] = serializeModelAttributes(value, model, modelStack);\n    } else if (value instanceof Backbone.Collection) {\n      serializedModels = [];\n      _ref = value.models;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        otherModel = _ref[_i];\n        serializedModels.push(serializeModelAttributes(otherModel, model, modelStack));\n      }\n      delegator[key] = serializedModels;\n    }\n  }\n  delete modelStack[model.cid];\n  return delegator;\n};\n\nserializeModelAttributes = function(model, currentModel, modelStack) {\n  var attributes;\n  if (model === currentModel || model.cid in modelStack) {\n    return null;\n  }\n  attributes = typeof model.getAttributes === 'function' ? model.getAttributes() : model.attributes;\n  return serializeAttributes(model, attributes, modelStack);\n};\n\nmodule.exports = Model = (function(_super) {\n\n  __extends(Model, _super);\n\n  function Model() {\n    return Model.__super__.constructor.apply(this, arguments);\n  }\n\n  _.extend(Model.prototype, EventBroker);\n\n  Model.prototype.getAttributes = function() {\n    return this.attributes;\n  };\n\n  Model.prototype.serialize = function() {\n    return serializeAttributes(this, this.getAttributes());\n  };\n\n  Model.prototype.disposed = false;\n\n  Model.prototype.dispose = function() {\n    var prop, properties, _i, _len;\n    if (this.disposed) {\n      return;\n    }\n    this.trigger('dispose', this);\n    this.unsubscribeAllEvents();\n    this.stopListening();\n    this.off();\n    properties = ['collection', 'attributes', 'changed', '_escapedAttributes', '_previousAttributes', '_silent', '_pending', '_callbacks'];\n    for (_i = 0, _len = properties.length; _i < _len; _i++) {\n      prop = properties[_i];\n      delete this[prop];\n    }\n    this.disposed = true;\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  return Model;\n\n})(Backbone.Model);\n\n});;loader.register('chaplin/views/layout', function(e, r, module) {\n'use strict';\n\nvar $, Backbone, EventBroker, Layout, View, mediator, utils, _,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nmediator = loader('chaplin/mediator');\n\nutils = loader('chaplin/lib/utils');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nView = loader('chaplin/views/view');\n\n$ = Backbone.$;\n\nmodule.exports = Layout = (function(_super) {\n\n  __extends(Layout, _super);\n\n  Layout.prototype.el = 'body';\n\n  Layout.prototype.keepElement = true;\n\n  Layout.prototype.title = '';\n\n  Layout.prototype.globalRegions = null;\n\n  Layout.prototype.listen = {\n    'beforeControllerDispose mediator': 'scroll'\n  };\n\n  function Layout(options) {\n    if (options == null) {\n      options = {};\n    }\n    this.openLink = __bind(this.openLink, this);\n\n    this.globalRegions = [];\n    this.title = options.title;\n    if (options.regions) {\n      this.regions = options.regions;\n    }\n    this.settings = _.defaults(options, {\n      titleTemplate: function(data) {\n        var st;\n        st = data.subtitle ? \"\" + data.subtitle + \" \\u2013 \" : '';\n        return st + data.title;\n      },\n      openExternalToBlank: false,\n      routeLinks: 'a, .go-to',\n      skipRouting: '.noscript',\n      scrollTo: [0, 0]\n    });\n    mediator.setHandler('region:show', this.showRegion, this);\n    mediator.setHandler('region:register', this.registerRegionHandler, this);\n    mediator.setHandler('region:unregister', this.unregisterRegionHandler, this);\n    mediator.setHandler('region:find', this.regionByName, this);\n    mediator.setHandler('adjustTitle', this.adjustTitle, this);\n    Layout.__super__.constructor.apply(this, arguments);\n    if (this.settings.routeLinks) {\n      this.startLinkRouting();\n    }\n  }\n\n  Layout.prototype.scroll = function() {\n    var position;\n    position = this.settings.scrollTo;\n    if (position) {\n      return window.scrollTo(position[0], position[1]);\n    }\n  };\n\n  Layout.prototype.adjustTitle = function(subtitle) {\n    var title,\n      _this = this;\n    if (subtitle == null) {\n      subtitle = '';\n    }\n    title = this.settings.titleTemplate({\n      title: this.title,\n      subtitle: subtitle\n    });\n    setTimeout(function() {\n      document.title = title;\n      return _this.publishEvent('adjustTitle', subtitle, title);\n    }, 50);\n    return title;\n  };\n\n  Layout.prototype.startLinkRouting = function() {\n    var route;\n    route = this.settings.routeLinks;\n    if (!route) {\n      return;\n    }\n    if ($) {\n      return this.$el.on('click', route, this.openLink);\n    } else {\n      return this.delegate('click', route, this.openLink);\n    }\n  };\n\n  Layout.prototype.stopLinkRouting = function() {\n    var route;\n    route = this.settings.routeLinks;\n    if ($) {\n      if (route) {\n        return this.$el.off('click', route);\n      }\n    } else {\n      return this.undelegate('click', route, this.openLink);\n    }\n  };\n\n  Layout.prototype.isExternalLink = function(link) {\n    var _ref, _ref1;\n    return link.target === '_blank' || link.rel === 'external' || ((_ref = link.protocol) !== 'http:' && _ref !== 'https:' && _ref !== 'file:') || ((_ref1 = link.hostname) !== location.hostname && _ref1 !== '');\n  };\n\n  Layout.prototype.openLink = function(event) {\n    var el, external, href, isAnchor, skipRouting, type;\n    if (utils.modifierKeyPressed(event)) {\n      return;\n    }\n    el = $ ? event.currentTarget : event.delegateTarget;\n    isAnchor = el.nodeName === 'A';\n    href = el.getAttribute('href') || el.getAttribute('data-href') || null;\n    if (!(href != null) || href === '' || href.charAt(0) === '#') {\n      return;\n    }\n    skipRouting = this.settings.skipRouting;\n    type = typeof skipRouting;\n    if (type === 'function' && !skipRouting(href, el) || type === 'string' && ($ ? $(el).is(skipRouting) : Backbone.utils.matchesSelector(el, skipRouting))) {\n      return;\n    }\n    external = isAnchor && this.isExternalLink(el);\n    if (external) {\n      if (this.settings.openExternalToBlank) {\n        event.preventDefault();\n        window.open(href);\n      }\n      return;\n    }\n    utils.redirectTo({\n      url: href\n    });\n    event.preventDefault();\n  };\n\n  Layout.prototype.registerRegionHandler = function(instance, name, selector) {\n    if (name != null) {\n      return this.registerGlobalRegion(instance, name, selector);\n    } else {\n      return this.registerGlobalRegions(instance);\n    }\n  };\n\n  Layout.prototype.registerGlobalRegion = function(instance, name, selector) {\n    this.unregisterGlobalRegion(instance, name);\n    return this.globalRegions.unshift({\n      instance: instance,\n      name: name,\n      selector: selector\n    });\n  };\n\n  Layout.prototype.registerGlobalRegions = function(instance) {\n    var name, selector, version, _i, _len, _ref;\n    _ref = utils.getAllPropertyVersions(instance, 'regions');\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      version = _ref[_i];\n      for (name in version) {\n        selector = version[name];\n        this.registerGlobalRegion(instance, name, selector);\n      }\n    }\n  };\n\n  Layout.prototype.unregisterRegionHandler = function(instance, name) {\n    if (name != null) {\n      return this.unregisterGlobalRegion(instance, name);\n    } else {\n      return this.unregisterGlobalRegions(instance);\n    }\n  };\n\n  Layout.prototype.unregisterGlobalRegion = function(instance, name) {\n    var cid, region;\n    cid = instance.cid;\n    return this.globalRegions = (function() {\n      var _i, _len, _ref, _results;\n      _ref = this.globalRegions;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        region = _ref[_i];\n        if (region.instance.cid !== cid || region.name !== name) {\n          _results.push(region);\n        }\n      }\n      return _results;\n    }).call(this);\n  };\n\n  Layout.prototype.unregisterGlobalRegions = function(instance) {\n    var region;\n    return this.globalRegions = (function() {\n      var _i, _len, _ref, _results;\n      _ref = this.globalRegions;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        region = _ref[_i];\n        if (region.instance.cid !== instance.cid) {\n          _results.push(region);\n        }\n      }\n      return _results;\n    }).call(this);\n  };\n\n  Layout.prototype.regionByName = function(name) {\n    var reg, _i, _len, _ref;\n    _ref = this.globalRegions;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      reg = _ref[_i];\n      if (reg.name === name && !reg.instance.stale) {\n        return reg;\n      }\n    }\n  };\n\n  Layout.prototype.showRegion = function(name, instance) {\n    var region;\n    region = this.regionByName(name);\n    if (!region) {\n      throw new Error(\"No region registered under \" + name);\n    }\n    return instance.container = region.selector === '' ? $ ? region.instance.$el : region.instance.el : region.instance.noWrap ? $ ? $(region.instance.container).find(region.selector) : region.instance.container.querySelector(region.selector) : region.instance[$ ? '$' : 'find'](region.selector);\n  };\n\n  Layout.prototype.dispose = function() {\n    var prop, _i, _len, _ref;\n    if (this.disposed) {\n      return;\n    }\n    this.stopLinkRouting();\n    _ref = ['globalRegions', 'title', 'route'];\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      prop = _ref[_i];\n      delete this[prop];\n    }\n    mediator.removeHandlers(this);\n    return Layout.__super__.dispose.apply(this, arguments);\n  };\n\n  return Layout;\n\n})(View);\n\n});;loader.register('chaplin/views/view', function(e, r, module) {\n'use strict';\n\nvar $, Backbone, EventBroker, View, attach, bind, mediator, setHTML, utils, _,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nmediator = loader('chaplin/mediator');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nutils = loader('chaplin/lib/utils');\n\n$ = Backbone.$;\n\nbind = (function() {\n  if (Function.prototype.bind) {\n    return function(item, ctx) {\n      return item.bind(ctx);\n    };\n  } else if (_.bind) {\n    return _.bind;\n  }\n})();\n\nsetHTML = (function() {\n  if ($) {\n    return function(elem, html) {\n      return elem.html(html);\n    };\n  } else {\n    return function(elem, html) {\n      return elem.innerHTML = html;\n    };\n  }\n})();\n\nattach = (function() {\n  if ($) {\n    return function(view) {\n      var actual;\n      actual = $(view.container);\n      if (typeof view.containerMethod === 'function') {\n        return view.containerMethod(actual, view.el);\n      } else {\n        return actual[view.containerMethod](view.el);\n      }\n    };\n  } else {\n    return function(view) {\n      var actual;\n      actual = typeof view.container === 'string' ? document.querySelector(view.container) : view.container;\n      if (typeof view.containerMethod === 'function') {\n        return view.containerMethod(actual, view.el);\n      } else {\n        return actual[view.containerMethod](view.el);\n      }\n    };\n  }\n})();\n\nmodule.exports = View = (function(_super) {\n\n  __extends(View, _super);\n\n  _.extend(View.prototype, EventBroker);\n\n  View.prototype.autoRender = false;\n\n  View.prototype.autoAttach = true;\n\n  View.prototype.container = null;\n\n  View.prototype.containerMethod = $ ? 'append' : 'appendChild';\n\n  View.prototype.regions = null;\n\n  View.prototype.region = null;\n\n  View.prototype.stale = false;\n\n  View.prototype.noWrap = false;\n\n  View.prototype.keepElement = false;\n\n  View.prototype.subviews = null;\n\n  View.prototype.subviewsByName = null;\n\n  View.prototype.optionNames = ['autoAttach', 'autoRender', 'container', 'containerMethod', 'region', 'regions', 'noWrap'];\n\n  function View(options) {\n    var optName, optValue, region, render,\n      _this = this;\n    if (options) {\n      for (optName in options) {\n        optValue = options[optName];\n        if (__indexOf.call(this.optionNames, optName) >= 0) {\n          this[optName] = optValue;\n        }\n      }\n    }\n    render = this.render;\n    this.render = function() {\n      if (_this.disposed) {\n        return false;\n      }\n      render.apply(_this, arguments);\n      if (_this.autoAttach) {\n        _this.attach.apply(_this, arguments);\n      }\n      return _this;\n    };\n    this.subviews = [];\n    this.subviewsByName = {};\n    if (this.noWrap) {\n      if (this.region) {\n        region = mediator.execute('region:find', this.region);\n        if (region != null) {\n          this.el = region.instance.container != null ? region.instance.region != null ? $(region.instance.container).find(region.selector) : region.instance.container : region.instance.$(region.selector);\n        }\n      }\n      if (this.container) {\n        this.el = this.container;\n      }\n    }\n    View.__super__.constructor.apply(this, arguments);\n    this.delegateListeners();\n    if (this.model) {\n      this.listenTo(this.model, 'dispose', this.dispose);\n    }\n    if (this.collection) {\n      this.listenTo(this.collection, 'dispose', function(subject) {\n        if (!subject || subject === _this.collection) {\n          return _this.dispose();\n        }\n      });\n    }\n    if (this.regions != null) {\n      mediator.execute('region:register', this);\n    }\n    if (this.autoRender) {\n      this.render();\n    }\n  }\n\n  View.prototype.delegate = function(eventName, second, third) {\n    var bound, event, events, handler, list, selector;\n    if (Backbone.utils) {\n      return Backbone.utils.delegate(this, eventName, second, third);\n    }\n    if (typeof eventName !== 'string') {\n      throw new TypeError('View#delegate: first argument must be a string');\n    }\n    if (arguments.length === 2) {\n      handler = second;\n    } else if (arguments.length === 3) {\n      selector = second;\n      if (typeof selector !== 'string') {\n        throw new TypeError('View#delegate: ' + 'second argument must be a string');\n      }\n      handler = third;\n    } else {\n      throw new TypeError('View#delegate: ' + 'only two or three arguments are allowed');\n    }\n    if (typeof handler !== 'function') {\n      throw new TypeError('View#delegate: ' + 'handler argument must be function');\n    }\n    list = (function() {\n      var _i, _len, _ref, _results;\n      _ref = eventName.split(' ');\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        event = _ref[_i];\n        _results.push(\"\" + event + \".delegate\" + this.cid);\n      }\n      return _results;\n    }).call(this);\n    events = list.join(' ');\n    bound = bind(handler, this);\n    this.$el.on(events, selector || null, bound);\n    return bound;\n  };\n\n  View.prototype._delegateEvents = function(events) {\n    var bound, eventName, handler, key, match, selector, value;\n    if (Backbone.View.prototype.delegateEvents.length === 2) {\n      return Backbone.View.prototype.delegateEvents.call(this, events, true);\n    }\n    for (key in events) {\n      value = events[key];\n      handler = typeof value === 'function' ? value : this[value];\n      if (!handler) {\n        throw new Error(\"Method '\" + handler + \"' does not exist\");\n      }\n      match = key.match(/^(\\S+)\\s*(.*)$/);\n      eventName = \"\" + match[1] + \".delegateEvents\" + this.cid;\n      selector = match[2];\n      bound = bind(handler, this);\n      this.$el.on(eventName, selector || null, bound);\n    }\n  };\n\n  View.prototype.delegateEvents = function(events, keepOld) {\n    var classEvents, _i, _len, _ref;\n    if (!keepOld) {\n      this.undelegateEvents();\n    }\n    if (events) {\n      return this._delegateEvents(events);\n    }\n    _ref = utils.getAllPropertyVersions(this, 'events');\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      classEvents = _ref[_i];\n      if (typeof classEvents === 'function') {\n        throw new TypeError('View#delegateEvents: functions are not supported');\n      }\n      this._delegateEvents(classEvents);\n    }\n  };\n\n  View.prototype.undelegate = function(eventName, second, third) {\n    var event, events, handler, list, selector;\n    if (Backbone.utils) {\n      return Backbone.utils.undelegate(this, eventName, second, third);\n    }\n    if (eventName) {\n      if (typeof eventName !== 'string') {\n        throw new TypeError('View#undelegate: first argument must be a string');\n      }\n      if (arguments.length === 2) {\n        if (typeof second === 'string') {\n          selector = second;\n        } else {\n          handler = second;\n        }\n      } else if (arguments.length === 3) {\n        selector = second;\n        if (typeof selector !== 'string') {\n          throw new TypeError('View#undelegate: ' + 'second argument must be a string');\n        }\n        handler = third;\n      }\n      list = (function() {\n        var _i, _len, _ref, _results;\n        _ref = eventName.split(' ');\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          event = _ref[_i];\n          _results.push(\"\" + event + \".delegate\" + this.cid);\n        }\n        return _results;\n      }).call(this);\n      events = list.join(' ');\n      return this.$el.off(events, selector || null);\n    } else {\n      return this.$el.off(\".delegate\" + this.cid);\n    }\n  };\n\n  View.prototype.delegateListeners = function() {\n    var eventName, key, method, target, version, _i, _len, _ref, _ref1;\n    if (!this.listen) {\n      return;\n    }\n    _ref = utils.getAllPropertyVersions(this, 'listen');\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      version = _ref[_i];\n      for (key in version) {\n        method = version[key];\n        if (typeof method !== 'function') {\n          method = this[method];\n        }\n        if (typeof method !== 'function') {\n          throw new Error('View#delegateListeners: ' + (\"\" + method + \" must be function\"));\n        }\n        _ref1 = key.split(' '), eventName = _ref1[0], target = _ref1[1];\n        this.delegateListener(eventName, target, method);\n      }\n    }\n  };\n\n  View.prototype.delegateListener = function(eventName, target, callback) {\n    var prop;\n    if (target === 'model' || target === 'collection') {\n      prop = this[target];\n      if (prop) {\n        this.listenTo(prop, eventName, callback);\n      }\n    } else if (target === 'mediator') {\n      this.subscribeEvent(eventName, callback);\n    } else if (!target) {\n      this.on(eventName, callback, this);\n    }\n  };\n\n  View.prototype.registerRegion = function(name, selector) {\n    return mediator.execute('region:register', this, name, selector);\n  };\n\n  View.prototype.unregisterRegion = function(name) {\n    return mediator.execute('region:unregister', this, name);\n  };\n\n  View.prototype.unregisterAllRegions = function() {\n    return mediator.execute({\n      name: 'region:unregister',\n      silent: true\n    }, this);\n  };\n\n  View.prototype.subview = function(name, view) {\n    var byName, subviews;\n    subviews = this.subviews;\n    byName = this.subviewsByName;\n    if (name && view) {\n      this.removeSubview(name);\n      subviews.push(view);\n      byName[name] = view;\n      return view;\n    } else if (name) {\n      return byName[name];\n    }\n  };\n\n  View.prototype.removeSubview = function(nameOrView) {\n    var byName, index, name, otherName, otherView, subviews, view;\n    if (!nameOrView) {\n      return;\n    }\n    subviews = this.subviews;\n    byName = this.subviewsByName;\n    if (typeof nameOrView === 'string') {\n      name = nameOrView;\n      view = byName[name];\n    } else {\n      view = nameOrView;\n      for (otherName in byName) {\n        otherView = byName[otherName];\n        if (!(otherView === view)) {\n          continue;\n        }\n        name = otherName;\n        break;\n      }\n    }\n    if (!(name && view && view.dispose)) {\n      return;\n    }\n    view.dispose();\n    index = utils.indexOf(subviews, view);\n    if (index !== -1) {\n      subviews.splice(index, 1);\n    }\n    return delete byName[name];\n  };\n\n  View.prototype.getTemplateData = function() {\n    var data, source;\n    data = this.model ? utils.serialize(this.model) : this.collection ? {\n      items: utils.serialize(this.collection),\n      length: this.collection.length\n    } : {};\n    source = this.model || this.collection;\n    if (source) {\n      if (typeof source.isSynced === 'function' && !('synced' in data)) {\n        data.synced = source.isSynced();\n      }\n    }\n    return data;\n  };\n\n  View.prototype.getTemplateFunction = function() {\n    throw new Error('View#getTemplateFunction must be overridden');\n  };\n\n  View.prototype.render = function() {\n    var el, html, templateFunc;\n    if (this.disposed) {\n      return false;\n    }\n    templateFunc = this.getTemplateFunction();\n    if (typeof templateFunc === 'function') {\n      html = templateFunc(this.getTemplateData());\n      if (this.noWrap) {\n        el = document.createElement('div');\n        el.innerHTML = html;\n        if (el.children.length > 1) {\n          throw new Error('There must be a single top-level element when ' + 'using `noWrap`.');\n        }\n        this.undelegateEvents();\n        this.setElement(el.firstChild, true);\n      } else {\n        setHTML(($ ? this.$el : this.el), html);\n      }\n    }\n    return this;\n  };\n\n  View.prototype.attach = function() {\n    if (this.region != null) {\n      mediator.execute('region:show', this.region, this);\n    }\n    if (this.container && !document.body.contains(this.el)) {\n      attach(this);\n      return this.trigger('addedToDOM');\n    }\n  };\n\n  View.prototype.disposed = false;\n\n  View.prototype.dispose = function() {\n    var prop, properties, subview, _i, _j, _len, _len1, _ref;\n    if (this.disposed) {\n      return;\n    }\n    this.unregisterAllRegions();\n    _ref = this.subviews;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      subview = _ref[_i];\n      subview.dispose();\n    }\n    this.unsubscribeAllEvents();\n    this.off();\n    if (this.keepElement) {\n      this.undelegateEvents();\n      this.undelegate();\n      this.stopListening();\n    } else {\n      this.remove();\n    }\n    properties = ['el', '$el', 'options', 'model', 'collection', 'subviews', 'subviewsByName', '_callbacks'];\n    for (_j = 0, _len1 = properties.length; _j < _len1; _j++) {\n      prop = properties[_j];\n      delete this[prop];\n    }\n    this.disposed = true;\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  return View;\n\n})(Backbone.View);\n\n});;loader.register('chaplin/views/collection_view', function(e, r, module) {\n'use strict';\n\nvar $, Backbone, CollectionView, View, addClass, endAnimation, filterChildren, insertView, startAnimation, toggleElement, utils, _,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nView = loader('chaplin/views/view');\n\nutils = loader('chaplin/lib/utils');\n\n$ = Backbone.$;\n\nfilterChildren = function(nodeList, selector) {\n  var node, _i, _len, _results;\n  if (!selector) {\n    return nodeList;\n  }\n  _results = [];\n  for (_i = 0, _len = nodeList.length; _i < _len; _i++) {\n    node = nodeList[_i];\n    if (Backbone.utils.matchesSelector(node, selector)) {\n      _results.push(node);\n    }\n  }\n  return _results;\n};\n\ntoggleElement = (function() {\n  if ($) {\n    return function(elem, visible) {\n      return elem.toggle(visible);\n    };\n  } else {\n    return function(elem, visible) {\n      return elem.style.display = (visible ? '' : 'none');\n    };\n  }\n})();\n\naddClass = (function() {\n  if ($) {\n    return function(elem, cls) {\n      return elem.addClass(cls);\n    };\n  } else {\n    return function(elem, cls) {\n      return elem.classList.add(cls);\n    };\n  }\n})();\n\nstartAnimation = (function() {\n  if ($) {\n    return function(elem, useCssAnimation, cls) {\n      if (useCssAnimation) {\n        return addClass(elem, cls);\n      } else {\n        return elem.css('opacity', 0);\n      }\n    };\n  } else {\n    return function(elem, useCssAnimation, cls) {\n      if (useCssAnimation) {\n        return addClass(elem, cls);\n      } else {\n        return elem.style.opacity = 0;\n      }\n    };\n  }\n})();\n\nendAnimation = (function() {\n  if ($) {\n    return function(elem, duration) {\n      return elem.animate({\n        opacity: 1\n      }, duration);\n    };\n  } else {\n    return function(elem, duration) {\n      elem.style.transition = \"opacity \" + (duration / 1000) + \"s\";\n      return elem.opacity = 1;\n    };\n  }\n})();\n\ninsertView = (function() {\n  if ($) {\n    return function(list, viewEl, position, length, itemSelector) {\n      var children, childrenLength, insertInMiddle, isEnd, method;\n      insertInMiddle = (0 < position && position < length);\n      isEnd = function(length) {\n        return length === 0 || position === length;\n      };\n      if (insertInMiddle || itemSelector) {\n        children = list.children(itemSelector);\n        childrenLength = children.length;\n        if (children[position] !== viewEl) {\n          if (isEnd(childrenLength)) {\n            return list.append(viewEl);\n          } else {\n            if (position === 0) {\n              return children.eq(position).before(viewEl);\n            } else {\n              return children.eq(position - 1).after(viewEl);\n            }\n          }\n        }\n      } else {\n        method = isEnd(length) ? 'append' : 'prepend';\n        return list[method](viewEl);\n      }\n    };\n  } else {\n    return function(list, viewEl, position, length, itemSelector) {\n      var children, childrenLength, insertInMiddle, isEnd, last;\n      insertInMiddle = (0 < position && position < length);\n      isEnd = function(length) {\n        return length === 0 || position === length;\n      };\n      if (insertInMiddle || itemSelector) {\n        children = filterChildren(list.children, itemSelector);\n        childrenLength = children.length;\n        if (children[position] !== viewEl) {\n          if (isEnd(childrenLength)) {\n            return list.appendChild(viewEl);\n          } else if (position === 0) {\n            return list.insertBefore(viewEl, children[position]);\n          } else {\n            last = children[position - 1];\n            if (list.lastChild === last) {\n              return list.appendChild(viewEl);\n            } else {\n              return list.insertBefore(viewEl, last.nextElementSibling);\n            }\n          }\n        }\n      } else if (isEnd(length)) {\n        return list.appendChild(viewEl);\n      } else {\n        return list.insertBefore(viewEl, list.firstChild);\n      }\n    };\n  }\n})();\n\nmodule.exports = CollectionView = (function(_super) {\n\n  __extends(CollectionView, _super);\n\n  CollectionView.prototype.itemView = null;\n\n  CollectionView.prototype.autoRender = true;\n\n  CollectionView.prototype.renderItems = true;\n\n  CollectionView.prototype.animationDuration = 500;\n\n  CollectionView.prototype.useCssAnimation = false;\n\n  CollectionView.prototype.animationStartClass = 'animated-item-view';\n\n  CollectionView.prototype.animationEndClass = 'animated-item-view-end';\n\n  CollectionView.prototype.listSelector = null;\n\n  CollectionView.prototype.$list = null;\n\n  CollectionView.prototype.fallbackSelector = null;\n\n  CollectionView.prototype.$fallback = null;\n\n  CollectionView.prototype.loadingSelector = null;\n\n  CollectionView.prototype.$loading = null;\n\n  CollectionView.prototype.itemSelector = void 0;\n\n  CollectionView.prototype.filterer = null;\n\n  CollectionView.prototype.filterCallback = function(view, included) {\n    if ($) {\n      view.$el.stop(true, true);\n    }\n    return toggleElement(($ ? view.$el : view.el), included);\n  };\n\n  CollectionView.prototype.visibleItems = null;\n\n  CollectionView.prototype.optionNames = View.prototype.optionNames.concat(['renderItems', 'itemView']);\n\n  function CollectionView(options) {\n    this.renderAllItems = __bind(this.renderAllItems, this);\n\n    this.toggleFallback = __bind(this.toggleFallback, this);\n\n    this.itemsReset = __bind(this.itemsReset, this);\n\n    this.itemRemoved = __bind(this.itemRemoved, this);\n\n    this.itemAdded = __bind(this.itemAdded, this);\n    this.visibleItems = [];\n    CollectionView.__super__.constructor.apply(this, arguments);\n  }\n\n  CollectionView.prototype.initialize = function(options) {\n    if (options == null) {\n      options = {};\n    }\n    this.addCollectionListeners();\n    if (options.filterer != null) {\n      return this.filter(options.filterer);\n    }\n  };\n\n  CollectionView.prototype.addCollectionListeners = function() {\n    this.listenTo(this.collection, 'add', this.itemAdded);\n    this.listenTo(this.collection, 'remove', this.itemRemoved);\n    return this.listenTo(this.collection, 'reset sort', this.itemsReset);\n  };\n\n  CollectionView.prototype.getTemplateData = function() {\n    var templateData;\n    templateData = {\n      length: this.collection.length\n    };\n    if (typeof this.collection.isSynced === 'function') {\n      templateData.synced = this.collection.isSynced();\n    }\n    return templateData;\n  };\n\n  CollectionView.prototype.getTemplateFunction = function() {};\n\n  CollectionView.prototype.render = function() {\n    var listSelector;\n    CollectionView.__super__.render.apply(this, arguments);\n    listSelector = _.result(this, 'listSelector');\n    if ($) {\n      this.$list = listSelector ? this.$(listSelector) : this.$el;\n    } else {\n      this.list = listSelector ? this.find(this.listSelector) : this.el;\n    }\n    this.initFallback();\n    this.initLoadingIndicator();\n    if (this.renderItems) {\n      return this.renderAllItems();\n    }\n  };\n\n  CollectionView.prototype.itemAdded = function(item, collection, options) {\n    return this.insertView(item, this.renderItem(item), options.at);\n  };\n\n  CollectionView.prototype.itemRemoved = function(item) {\n    return this.removeViewForItem(item);\n  };\n\n  CollectionView.prototype.itemsReset = function() {\n    return this.renderAllItems();\n  };\n\n  CollectionView.prototype.initFallback = function() {\n    if (!this.fallbackSelector) {\n      return;\n    }\n    if ($) {\n      this.$fallback = this.$(this.fallbackSelector);\n    } else {\n      this.fallback = this.find(this.fallbackSelector);\n    }\n    this.on('visibilityChange', this.toggleFallback);\n    this.listenTo(this.collection, 'syncStateChange', this.toggleFallback);\n    return this.toggleFallback();\n  };\n\n  CollectionView.prototype.toggleFallback = function() {\n    var visible;\n    visible = this.visibleItems.length === 0 && (typeof this.collection.isSynced === 'function' ? this.collection.isSynced() : true);\n    return toggleElement(($ ? this.$fallback : this.fallback), visible);\n  };\n\n  CollectionView.prototype.initLoadingIndicator = function() {\n    if (!(this.loadingSelector && typeof this.collection.isSyncing === 'function')) {\n      return;\n    }\n    if ($) {\n      this.$loading = this.$(this.loadingSelector);\n    } else {\n      this.loading = this.find(this.loadingSelector);\n    }\n    this.listenTo(this.collection, 'syncStateChange', this.toggleLoadingIndicator);\n    return this.toggleLoadingIndicator();\n  };\n\n  CollectionView.prototype.toggleLoadingIndicator = function() {\n    var visible;\n    visible = this.collection.length === 0 && this.collection.isSyncing();\n    return toggleElement(($ ? this.$loading : this.loading), visible);\n  };\n\n  CollectionView.prototype.getItemViews = function() {\n    var itemViews, name, view, _ref;\n    itemViews = {};\n    if (this.subviews.length > 0) {\n      _ref = this.subviewsByName;\n      for (name in _ref) {\n        view = _ref[name];\n        if (name.slice(0, 9) === 'itemView:') {\n          itemViews[name.slice(9)] = view;\n        }\n      }\n    }\n    return itemViews;\n  };\n\n  CollectionView.prototype.filter = function(filterer, filterCallback) {\n    var hasItemViews, included, index, item, view, _i, _len, _ref,\n      _this = this;\n    if (typeof filterer === 'function' || filterer === null) {\n      this.filterer = filterer;\n    }\n    if (typeof filterCallback === 'function' || filterCallback === null) {\n      this.filterCallback = filterCallback;\n    }\n    hasItemViews = (function() {\n      var name;\n      if (_this.subviews.length > 0) {\n        for (name in _this.subviewsByName) {\n          if (name.slice(0, 9) === 'itemView:') {\n            return true;\n          }\n        }\n      }\n      return false;\n    })();\n    if (hasItemViews) {\n      _ref = this.collection.models;\n      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {\n        item = _ref[index];\n        included = typeof this.filterer === 'function' ? this.filterer(item, index) : true;\n        view = this.subview(\"itemView:\" + item.cid);\n        if (!view) {\n          throw new Error('CollectionView#filter: ' + (\"no view found for \" + item.cid));\n        }\n        this.filterCallback(view, included);\n        this.updateVisibleItems(view.model, included, false);\n      }\n    }\n    return this.trigger('visibilityChange', this.visibleItems);\n  };\n\n  CollectionView.prototype.renderAllItems = function() {\n    var cid, index, item, items, remainingViewsByCid, view, _i, _j, _len, _len1, _ref;\n    items = this.collection.models;\n    this.visibleItems = [];\n    remainingViewsByCid = {};\n    for (_i = 0, _len = items.length; _i < _len; _i++) {\n      item = items[_i];\n      view = this.subview(\"itemView:\" + item.cid);\n      if (view) {\n        remainingViewsByCid[item.cid] = view;\n      }\n    }\n    _ref = this.getItemViews();\n    for (cid in _ref) {\n      if (!__hasProp.call(_ref, cid)) continue;\n      view = _ref[cid];\n      if (!(cid in remainingViewsByCid)) {\n        this.removeSubview(\"itemView:\" + cid);\n      }\n    }\n    for (index = _j = 0, _len1 = items.length; _j < _len1; index = ++_j) {\n      item = items[index];\n      view = this.subview(\"itemView:\" + item.cid);\n      if (view) {\n        this.insertView(item, view, index, false);\n      } else {\n        this.insertView(item, this.renderItem(item), index);\n      }\n    }\n    if (items.length === 0) {\n      return this.trigger('visibilityChange', this.visibleItems);\n    }\n  };\n\n  CollectionView.prototype.renderItem = function(item) {\n    var view;\n    view = this.subview(\"itemView:\" + item.cid);\n    if (!view) {\n      view = this.initItemView(item);\n      this.subview(\"itemView:\" + item.cid, view);\n    }\n    view.render();\n    return view;\n  };\n\n  CollectionView.prototype.initItemView = function(model) {\n    if (this.itemView) {\n      return new this.itemView({\n        autoRender: false,\n        model: model\n      });\n    } else {\n      throw new Error('The CollectionView#itemView property ' + 'must be defined or the initItemView() must be overridden.');\n    }\n  };\n\n  CollectionView.prototype.insertView = function(item, view, position, enableAnimation) {\n    var elem, included, length, list,\n      _this = this;\n    if (enableAnimation == null) {\n      enableAnimation = true;\n    }\n    if (this.animationDuration === 0) {\n      enableAnimation = false;\n    }\n    if (typeof position !== 'number') {\n      position = this.collection.indexOf(item);\n    }\n    included = typeof this.filterer === 'function' ? this.filterer(item, position) : true;\n    elem = $ ? view.$el : view.el;\n    if (included && enableAnimation) {\n      startAnimation(elem, this.useCssAnimation, this.animationStartClass);\n    }\n    if (this.filterer) {\n      this.filterCallback(view, included);\n    }\n    length = this.collection.length;\n    list = $ ? this.$list : this.list;\n    insertView(list, elem, position, length, this.itemSelector);\n    view.trigger('addedToParent');\n    this.updateVisibleItems(item, included);\n    if (included && enableAnimation) {\n      if (this.useCssAnimation) {\n        setTimeout((function() {\n          return addClass(elem, _this.animationEndClass);\n        }), 0);\n      } else {\n        endAnimation(elem, this.animationDuration);\n      }\n    }\n    return view;\n  };\n\n  CollectionView.prototype.removeViewForItem = function(item) {\n    this.updateVisibleItems(item, false);\n    return this.removeSubview(\"itemView:\" + item.cid);\n  };\n\n  CollectionView.prototype.updateVisibleItems = function(item, includedInFilter, triggerEvent) {\n    var includedInVisibleItems, visibilityChanged, visibleItemsIndex;\n    if (triggerEvent == null) {\n      triggerEvent = true;\n    }\n    visibilityChanged = false;\n    visibleItemsIndex = utils.indexOf(this.visibleItems, item);\n    includedInVisibleItems = visibleItemsIndex !== -1;\n    if (includedInFilter && !includedInVisibleItems) {\n      this.visibleItems.push(item);\n      visibilityChanged = true;\n    } else if (!includedInFilter && includedInVisibleItems) {\n      this.visibleItems.splice(visibleItemsIndex, 1);\n      visibilityChanged = true;\n    }\n    if (visibilityChanged && triggerEvent) {\n      this.trigger('visibilityChange', this.visibleItems);\n    }\n    return visibilityChanged;\n  };\n\n  CollectionView.prototype.dispose = function() {\n    var prop, properties, _i, _len;\n    if (this.disposed) {\n      return;\n    }\n    properties = ['$list', '$fallback', '$loading', 'visibleItems'];\n    for (_i = 0, _len = properties.length; _i < _len; _i++) {\n      prop = properties[_i];\n      delete this[prop];\n    }\n    return CollectionView.__super__.dispose.apply(this, arguments);\n  };\n\n  return CollectionView;\n\n})(View);\n\n});;loader.register('chaplin/lib/route', function(e, r, module) {\n'use strict';\n\nvar Backbone, Controller, EventBroker, Route, utils, _,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty;\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nController = loader('chaplin/controllers/controller');\n\nutils = loader('chaplin/lib/utils');\n\nmodule.exports = Route = (function() {\n  var escapeRegExp;\n\n  Route.extend = Backbone.Model.extend;\n\n  _.extend(Route.prototype, EventBroker);\n\n  escapeRegExp = /[-[\\]{}()+?.,\\\\^$|#\\s]/g;\n\n  function Route(pattern, controller, action, options) {\n    var _ref;\n    this.pattern = pattern;\n    this.controller = controller;\n    this.action = action;\n    this.handler = __bind(this.handler, this);\n\n    this.addParamName = __bind(this.addParamName, this);\n\n    if (typeof this.pattern !== 'string') {\n      throw new Error('Route: RegExps are not supported.\\\n        Use strings with :names and `constraints` option of route');\n    }\n    this.options = options ? _.extend({}, options) : {};\n    if (this.options.name != null) {\n      this.name = this.options.name;\n    }\n    if (this.name && this.name.indexOf('#') !== -1) {\n      throw new Error('Route: \"#\" cannot be used in name');\n    }\n    if ((_ref = this.name) == null) {\n      this.name = this.controller + '#' + this.action;\n    }\n    this.paramNames = [];\n    if (this.action in Controller.prototype) {\n      throw new Error('Route: You should not use existing controller ' + 'properties as action names');\n    }\n    this.createRegExp();\n    if (typeof Object.freeze === \"function\") {\n      Object.freeze(this);\n    }\n  }\n\n  Route.prototype.matches = function(criteria) {\n    var invalidParamsCount, name, propertiesCount, property, _i, _len, _ref;\n    if (typeof criteria === 'string') {\n      return criteria === this.name;\n    } else {\n      propertiesCount = 0;\n      _ref = ['name', 'action', 'controller'];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        name = _ref[_i];\n        propertiesCount++;\n        property = criteria[name];\n        if (property && property !== this[name]) {\n          return false;\n        }\n      }\n      invalidParamsCount = propertiesCount === 1 && (name === 'action' || name === 'controller');\n      return !invalidParamsCount;\n    }\n  };\n\n  Route.prototype.reverse = function(params, query) {\n    var name, queryString, url, value, _i, _len, _ref;\n    params = this.normalizeParams(params);\n    if (params === false) {\n      return false;\n    }\n    url = this.pattern;\n    _ref = this.paramNames;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      name = _ref[_i];\n      value = params[name];\n      url = url.replace(RegExp(\"[:*]\" + name, \"g\"), value);\n    }\n    if (!query) {\n      return url;\n    }\n    if (typeof query === 'object') {\n      queryString = utils.queryParams.stringify(query);\n      return url += queryString ? '?' + queryString : '';\n    } else {\n      return url += (query[0] === '?' ? '' : '?') + query;\n    }\n  };\n\n  Route.prototype.normalizeParams = function(params) {\n    var paramIndex, paramName, paramsHash, _i, _len, _ref;\n    if (utils.isArray(params)) {\n      if (params.length < this.paramNames.length) {\n        return false;\n      }\n      paramsHash = {};\n      _ref = this.paramNames;\n      for (paramIndex = _i = 0, _len = _ref.length; _i < _len; paramIndex = ++_i) {\n        paramName = _ref[paramIndex];\n        paramsHash[paramName] = params[paramIndex];\n      }\n      if (!this.testConstraints(paramsHash)) {\n        return false;\n      }\n      params = paramsHash;\n    } else {\n      if (params == null) {\n        params = {};\n      }\n      if (!this.testParams(params)) {\n        return false;\n      }\n    }\n    return params;\n  };\n\n  Route.prototype.testConstraints = function(params) {\n    var constraint, constraints, name;\n    constraints = this.options.constraints;\n    if (constraints) {\n      for (name in constraints) {\n        if (!__hasProp.call(constraints, name)) continue;\n        constraint = constraints[name];\n        if (!constraint.test(params[name])) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  Route.prototype.testParams = function(params) {\n    var paramName, _i, _len, _ref;\n    _ref = this.paramNames;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      paramName = _ref[_i];\n      if (params[paramName] === void 0) {\n        return false;\n      }\n    }\n    return this.testConstraints(params);\n  };\n\n  Route.prototype.createRegExp = function() {\n    var pattern;\n    pattern = this.pattern.replace(escapeRegExp, '\\\\$&').replace(/(?::|\\*)(\\w+)/g, this.addParamName);\n    return this.regExp = RegExp(\"^\" + pattern + \"(?=\\\\?|$)\");\n  };\n\n  Route.prototype.addParamName = function(match, paramName) {\n    this.paramNames.push(paramName);\n    if (match.charAt(0) === ':') {\n      return '([^\\/\\?]+)';\n    } else {\n      return '(.*?)';\n    }\n  };\n\n  Route.prototype.test = function(path) {\n    var constraints, matched;\n    matched = this.regExp.test(path);\n    if (!matched) {\n      return false;\n    }\n    constraints = this.options.constraints;\n    if (constraints) {\n      return this.testConstraints(this.extractParams(path));\n    }\n    return true;\n  };\n\n  Route.prototype.handler = function(pathParams, options) {\n    var actionParams, params, path, query, route, _ref;\n    options = options ? _.extend({}, options) : {};\n    if (typeof pathParams === 'object') {\n      query = utils.queryParams.stringify(options.query);\n      params = pathParams;\n      path = this.reverse(params);\n    } else {\n      _ref = pathParams.split('?'), path = _ref[0], query = _ref[1];\n      if (!(query != null)) {\n        query = '';\n      } else {\n        options.query = utils.queryParams.parse(query);\n      }\n      params = this.extractParams(path);\n    }\n    actionParams = _.extend({}, params, this.options.params);\n    route = {\n      path: path,\n      action: this.action,\n      controller: this.controller,\n      name: this.name,\n      query: query\n    };\n    return this.publishEvent('router:match', route, actionParams, options);\n  };\n\n  Route.prototype.extractParams = function(path) {\n    var index, match, matches, paramName, params, _i, _len, _ref;\n    params = {};\n    matches = this.regExp.exec(path);\n    _ref = matches.slice(1);\n    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {\n      match = _ref[index];\n      paramName = this.paramNames.length ? this.paramNames[index] : index;\n      params[paramName] = match;\n    }\n    return params;\n  };\n\n  return Route;\n\n})();\n\n});;loader.register('chaplin/lib/router', function(e, r, module) {\n'use strict';\n\nvar Backbone, EventBroker, History, Route, Router, mediator, utils, _,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nmediator = loader('chaplin/mediator');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nHistory = loader('chaplin/lib/history');\n\nRoute = loader('chaplin/lib/route');\n\nutils = loader('chaplin/lib/utils');\n\nmodule.exports = Router = (function() {\n\n  Router.extend = Backbone.Model.extend;\n\n  _.extend(Router.prototype, EventBroker);\n\n  function Router(options) {\n    var isWebFile;\n    this.options = options != null ? options : {};\n    this.match = __bind(this.match, this);\n\n    isWebFile = window.location.protocol !== 'file:';\n    _.defaults(this.options, {\n      pushState: isWebFile,\n      root: '/'\n    });\n    this.removeRoot = new RegExp('^' + utils.escapeRegExp(this.options.root) + '(#)?');\n    this.subscribeEvent('!router:route', this.oldEventError);\n    this.subscribeEvent('!router:routeByName', this.oldEventError);\n    this.subscribeEvent('!router:changeURL', this.oldURLEventError);\n    mediator.setHandler('router:route', this.route, this);\n    mediator.setHandler('router:reverse', this.reverse, this);\n    mediator.setHandler('router:changeURL', this.changeURL, this);\n    this.createHistory();\n  }\n\n  Router.prototype.oldEventError = function() {\n    throw new Error('!router:route and !router:routeByName events were removed.\\\n  Use `Chaplin.helpers.redirectTo`');\n  };\n\n  Router.prototype.oldURLEventError = function() {\n    throw new Error('!router:changeURL event was removed.\\\n  Use mediator.execute(\"router:changeURL\")');\n  };\n\n  Router.prototype.createHistory = function() {\n    return Backbone.history = new History();\n  };\n\n  Router.prototype.startHistory = function() {\n    return Backbone.history.start(this.options);\n  };\n\n  Router.prototype.stopHistory = function() {\n    if (Backbone.History.started) {\n      return Backbone.history.stop();\n    }\n  };\n\n  Router.prototype.findHandler = function(predicate) {\n    var handler, _i, _len, _ref;\n    _ref = Backbone.history.handlers;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      handler = _ref[_i];\n      if (predicate(handler)) {\n        return handler;\n      }\n    }\n  };\n\n  Router.prototype.match = function(pattern, target, options) {\n    var action, controller, route, _ref;\n    if (options == null) {\n      options = {};\n    }\n    if (arguments.length === 2 && typeof target === 'object') {\n      options = target;\n      controller = options.controller, action = options.action;\n      if (!(controller && action)) {\n        throw new Error('Router#match must receive either target or ' + 'options.controller & options.action');\n      }\n    } else {\n      controller = options.controller, action = options.action;\n      if (controller || action) {\n        throw new Error('Router#match cannot use both target and ' + 'options.controller / options.action');\n      }\n      _ref = target.split('#'), controller = _ref[0], action = _ref[1];\n    }\n    route = new Route(pattern, controller, action, options);\n    Backbone.history.handlers.push({\n      route: route,\n      callback: route.handler\n    });\n    return route;\n  };\n\n  Router.prototype.route = function(pathDesc, params, options) {\n    var handler, path;\n    params = params ? utils.isArray(params) ? params.slice() : _.extend({}, params) : {};\n    if (typeof pathDesc === 'object') {\n      path = pathDesc.url;\n    }\n    if (path != null) {\n      path = path.replace(this.removeRoot, '');\n      handler = this.findHandler(function(handler) {\n        return handler.route.test(path);\n      });\n      options = params;\n      params = null;\n    } else {\n      options = options ? _.extend({}, options) : {};\n      handler = this.findHandler(function(handler) {\n        if (handler.route.matches(pathDesc)) {\n          params = handler.route.normalizeParams(params);\n          if (params) {\n            return true;\n          }\n        }\n        return false;\n      });\n    }\n    if (handler) {\n      _.defaults(options, {\n        changeURL: true\n      });\n      handler.callback(path || params, options);\n      return true;\n    } else {\n      throw new Error('Router#route: request was not routed');\n    }\n  };\n\n  Router.prototype.reverse = function(criteria, params, query) {\n    var handler, handlers, reversed, root, url, _i, _len;\n    root = this.options.root;\n    if ((params != null) && typeof params !== 'object') {\n      throw new TypeError('Router#reverse: params must be an array or an ' + 'object');\n    }\n    handlers = Backbone.history.handlers;\n    for (_i = 0, _len = handlers.length; _i < _len; _i++) {\n      handler = handlers[_i];\n      if (!(handler.route.matches(criteria))) {\n        continue;\n      }\n      reversed = handler.route.reverse(params, query);\n      if (reversed !== false) {\n        url = root ? root + reversed : reversed;\n        return url;\n      }\n    }\n    throw new Error('Router#reverse: invalid route specified');\n  };\n\n  Router.prototype.changeURL = function(url, options) {\n    var navigateOptions;\n    if (options == null) {\n      options = {};\n    }\n    navigateOptions = {\n      trigger: options.trigger === true,\n      replace: options.replace === true\n    };\n    return Backbone.history.navigate(url, navigateOptions);\n  };\n\n  Router.prototype.disposed = false;\n\n  Router.prototype.dispose = function() {\n    if (this.disposed) {\n      return;\n    }\n    this.stopHistory();\n    delete Backbone.history;\n    this.unsubscribeAllEvents();\n    mediator.removeHandlers(this);\n    this.disposed = true;\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  return Router;\n\n})();\n\n});;loader.register('chaplin/lib/history', function(e, r, module) {\n'use strict';\n\nvar Backbone, History, isExplorer, rootStripper, routeStripper, trailingSlash, _,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nrouteStripper = /^[#\\/]|\\s+$/g;\n\nrootStripper = /^\\/+|\\/+$/g;\n\nisExplorer = /msie [\\w.]+/;\n\ntrailingSlash = /\\/$/;\n\nHistory = (function(_super) {\n\n  __extends(History, _super);\n\n  function History() {\n    return History.__super__.constructor.apply(this, arguments);\n  }\n\n  History.prototype.getFragment = function(fragment, forcePushState) {\n    var root;\n    if (!(fragment != null)) {\n      if (this._hasPushState || !this._wantsHashChange || forcePushState) {\n        fragment = this.location.pathname + this.location.search;\n        root = this.root.replace(trailingSlash, '');\n        if (!fragment.indexOf(root)) {\n          fragment = fragment.substr(root.length);\n        }\n      } else {\n        fragment = this.getHash();\n      }\n    }\n    return fragment.replace(routeStripper, '');\n  };\n\n  History.prototype.start = function(options) {\n    var atRoot, fragment, loc;\n    if (Backbone.History.started) {\n      throw new Error('Backbone.history has already been started');\n    }\n    Backbone.History.started = true;\n    this.options = _.extend({}, {\n      root: '/'\n    }, this.options, options);\n    this.root = this.options.root;\n    this._wantsHashChange = this.options.hashChange !== false;\n    this._wantsPushState = Boolean(this.options.pushState);\n    this._hasPushState = Boolean(this.options.pushState && this.history && this.history.pushState);\n    fragment = this.getFragment();\n    this.root = ('/' + this.root + '/').replace(rootStripper, '/');\n    if (this._hasPushState) {\n      Backbone.$(window).on('popstate', this.checkUrl);\n    } else if (this._wantsHashChange && 'onhashchange' in window) {\n      Backbone.$(window).on('hashchange', this.checkUrl);\n    } else if (this._wantsHashChange) {\n      this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n    }\n    this.fragment = fragment;\n    loc = this.location;\n    atRoot = loc.pathname.replace(/[^\\/]$/, '$&/') === this.root;\n    if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {\n      this.fragment = this.getFragment(null, true);\n      this.location.replace(this.root + '#' + this.fragment);\n      return true;\n    } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {\n      this.fragment = this.getHash().replace(routeStripper, '');\n      this.history.replaceState({}, document.title, this.root + this.fragment);\n    }\n    if (!this.options.silent) {\n      return this.loadUrl();\n    }\n  };\n\n  return History;\n\n})(Backbone.History);\n\nmodule.exports = Backbone.$ ? History : Backbone.History;\n\n});;loader.register('chaplin/lib/event_broker', function(e, r, module) {\n'use strict';\n\nvar EventBroker, mediator,\n  __slice = [].slice;\n\nmediator = loader('chaplin/mediator');\n\nEventBroker = {\n  subscribeEvent: function(type, handler) {\n    if (typeof type !== 'string') {\n      throw new TypeError('EventBroker#subscribeEvent: ' + 'type argument must be a string');\n    }\n    if (typeof handler !== 'function') {\n      throw new TypeError('EventBroker#subscribeEvent: ' + 'handler argument must be a function');\n    }\n    mediator.unsubscribe(type, handler, this);\n    return mediator.subscribe(type, handler, this);\n  },\n  unsubscribeEvent: function(type, handler) {\n    if (typeof type !== 'string') {\n      throw new TypeError('EventBroker#unsubscribeEvent: ' + 'type argument must be a string');\n    }\n    if (typeof handler !== 'function') {\n      throw new TypeError('EventBroker#unsubscribeEvent: ' + 'handler argument must be a function');\n    }\n    return mediator.unsubscribe(type, handler);\n  },\n  unsubscribeAllEvents: function() {\n    return mediator.unsubscribe(null, null, this);\n  },\n  publishEvent: function() {\n    var args, type;\n    type = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n    if (typeof type !== 'string') {\n      throw new TypeError('EventBroker#publishEvent: ' + 'type argument must be a string');\n    }\n    return mediator.publish.apply(mediator, [type].concat(__slice.call(args)));\n  }\n};\n\nif (typeof Object.freeze === \"function\") {\n  Object.freeze(EventBroker);\n}\n\nmodule.exports = EventBroker;\n\n});;loader.register('chaplin/lib/support', function(e, r, module) {\n'use strict';\n\nvar support;\n\nsupport = {\n  propertyDescriptors: (function() {\n    var o;\n    if (!(typeof Object.defineProperty === 'function' && typeof Object.defineProperties === 'function')) {\n      return false;\n    }\n    try {\n      o = {};\n      Object.defineProperty(o, 'foo', {\n        value: 'bar'\n      });\n      return o.foo === 'bar';\n    } catch (error) {\n      return false;\n    }\n  })()\n};\n\nmodule.exports = support;\n\n});;loader.register('chaplin/lib/composition', function(e, r, module) {\n'use strict';\n\nvar Backbone, Composition, EventBroker, has, _,\n  __hasProp = {}.hasOwnProperty;\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nhas = Object.prototype.hasOwnProperty;\n\nmodule.exports = Composition = (function() {\n\n  Composition.extend = Backbone.Model.extend;\n\n  _.extend(Composition.prototype, Backbone.Events);\n\n  _.extend(Composition.prototype, EventBroker);\n\n  Composition.prototype.item = null;\n\n  Composition.prototype.options = null;\n\n  Composition.prototype._stale = false;\n\n  function Composition(options) {\n    if (options != null) {\n      this.options = _.extend({}, options);\n    }\n    this.item = this;\n    this.initialize(this.options);\n  }\n\n  Composition.prototype.initialize = function() {};\n\n  Composition.prototype.compose = function() {};\n\n  Composition.prototype.check = function(options) {\n    return _.isEqual(this.options, options);\n  };\n\n  Composition.prototype.stale = function(value) {\n    var item, name;\n    if (value == null) {\n      return this._stale;\n    }\n    this._stale = value;\n    for (name in this) {\n      item = this[name];\n      if (item && item !== this && typeof item === 'object' && has.call(item, 'stale')) {\n        item.stale = value;\n      }\n    }\n  };\n\n  Composition.prototype.disposed = false;\n\n  Composition.prototype.dispose = function() {\n    var obj, prop, properties, _i, _len;\n    if (this.disposed) {\n      return;\n    }\n    for (prop in this) {\n      if (!__hasProp.call(this, prop)) continue;\n      obj = this[prop];\n      if (obj && typeof obj.dispose === 'function') {\n        if (obj !== this) {\n          obj.dispose();\n          delete this[prop];\n        }\n      }\n    }\n    this.unsubscribeAllEvents();\n    this.stopListening();\n    properties = ['redirected'];\n    for (_i = 0, _len = properties.length; _i < _len; _i++) {\n      prop = properties[_i];\n      delete this[prop];\n    }\n    this.disposed = true;\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  return Composition;\n\n})();\n\n});;loader.register('chaplin/lib/sync_machine', function(e, r, module) {\n'use strict';\n\nvar STATE_CHANGE, SYNCED, SYNCING, SyncMachine, UNSYNCED, event, _fn, _i, _len, _ref;\n\nUNSYNCED = 'unsynced';\n\nSYNCING = 'syncing';\n\nSYNCED = 'synced';\n\nSTATE_CHANGE = 'syncStateChange';\n\nSyncMachine = {\n  _syncState: UNSYNCED,\n  _previousSyncState: null,\n  syncState: function() {\n    return this._syncState;\n  },\n  isUnsynced: function() {\n    return this._syncState === UNSYNCED;\n  },\n  isSynced: function() {\n    return this._syncState === SYNCED;\n  },\n  isSyncing: function() {\n    return this._syncState === SYNCING;\n  },\n  unsync: function() {\n    var _ref;\n    if ((_ref = this._syncState) === SYNCING || _ref === SYNCED) {\n      this._previousSync = this._syncState;\n      this._syncState = UNSYNCED;\n      this.trigger(this._syncState, this, this._syncState);\n      this.trigger(STATE_CHANGE, this, this._syncState);\n    }\n  },\n  beginSync: function() {\n    var _ref;\n    if ((_ref = this._syncState) === UNSYNCED || _ref === SYNCED) {\n      this._previousSync = this._syncState;\n      this._syncState = SYNCING;\n      this.trigger(this._syncState, this, this._syncState);\n      this.trigger(STATE_CHANGE, this, this._syncState);\n    }\n  },\n  finishSync: function() {\n    if (this._syncState === SYNCING) {\n      this._previousSync = this._syncState;\n      this._syncState = SYNCED;\n      this.trigger(this._syncState, this, this._syncState);\n      this.trigger(STATE_CHANGE, this, this._syncState);\n    }\n  },\n  abortSync: function() {\n    if (this._syncState === SYNCING) {\n      this._syncState = this._previousSync;\n      this._previousSync = this._syncState;\n      this.trigger(this._syncState, this, this._syncState);\n      this.trigger(STATE_CHANGE, this, this._syncState);\n    }\n  }\n};\n\n_ref = [UNSYNCED, SYNCING, SYNCED, STATE_CHANGE];\n_fn = function(event) {\n  return SyncMachine[event] = function(callback, context) {\n    if (context == null) {\n      context = this;\n    }\n    this.on(event, callback, context);\n    if (this._syncState === event) {\n      return callback.call(context);\n    }\n  };\n};\nfor (_i = 0, _len = _ref.length; _i < _len; _i++) {\n  event = _ref[_i];\n  _fn(event);\n}\n\nif (typeof Object.freeze === \"function\") {\n  Object.freeze(SyncMachine);\n}\n\nmodule.exports = SyncMachine;\n\n});;loader.register('chaplin/lib/utils', function(e, r, module) {\n'use strict';\n\nvar support, utils, _,\n  __slice = [].slice,\n  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n  __hasProp = {}.hasOwnProperty;\n\n_ = loader('underscore');\n\nsupport = loader('chaplin/lib/support');\n\nutils = {\n  beget: (function() {\n    var ctor;\n    if (typeof Object.create === 'function') {\n      return Object.create;\n    } else {\n      ctor = function() {};\n      return function(obj) {\n        ctor.prototype = obj;\n        return new ctor;\n      };\n    }\n  })(),\n  indexOf: (function() {\n    if (Array.prototype.indexOf) {\n      return function(list, index) {\n        return list.indexOf(index);\n      };\n    } else if (_.indexOf) {\n      return _.indexOf;\n    }\n  })(),\n  isArray: Array.isArray || _.isArray,\n  serialize: function(data) {\n    if (typeof data.serialize === 'function') {\n      return data.serialize();\n    } else if (typeof data.toJSON === 'function') {\n      return data.toJSON();\n    } else {\n      throw new TypeError('utils.serialize: Unknown data was passed');\n    }\n  },\n  readonly: (function() {\n    var readonlyDescriptor;\n    if (support.propertyDescriptors) {\n      readonlyDescriptor = {\n        writable: false,\n        enumerable: true,\n        configurable: false\n      };\n      return function() {\n        var obj, prop, properties, _i, _len;\n        obj = arguments[0], properties = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n        for (_i = 0, _len = properties.length; _i < _len; _i++) {\n          prop = properties[_i];\n          readonlyDescriptor.value = obj[prop];\n          Object.defineProperty(obj, prop, readonlyDescriptor);\n        }\n        return true;\n      };\n    } else {\n      return function() {\n        return false;\n      };\n    }\n  })(),\n  getPrototypeChain: function(object) {\n    var chain, _ref, _ref1, _ref2;\n    chain = [object.constructor.prototype];\n    while (object = (_ref = (_ref1 = object.constructor) != null ? _ref1.__super__ : void 0) != null ? _ref : (_ref2 = object.constructor) != null ? _ref2.superclass : void 0) {\n      chain.push(object);\n    }\n    return chain.reverse();\n  },\n  getAllPropertyVersions: function(object, property) {\n    var proto, result, value, _i, _len, _ref;\n    result = [];\n    _ref = utils.getPrototypeChain(object);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      proto = _ref[_i];\n      value = proto[property];\n      if (value && __indexOf.call(result, value) < 0) {\n        result.push(value);\n      }\n    }\n    return result;\n  },\n  upcase: function(str) {\n    return str.charAt(0).toUpperCase() + str.substring(1);\n  },\n  escapeRegExp: function(str) {\n    return String(str || '').replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n  },\n  modifierKeyPressed: function(event) {\n    return event.shiftKey || event.altKey || event.ctrlKey || event.metaKey;\n  },\n  reverse: function(criteria, params, query) {\n    return loader('chaplin/mediator').execute('router:reverse', criteria, params, query);\n  },\n  redirectTo: function(pathDesc, params, options) {\n    return loader('chaplin/mediator').execute('router:route', pathDesc, params, options);\n  },\n  queryParams: {\n    stringify: function(queryParams) {\n      var arrParam, encodedKey, key, query, stringifyKeyValuePair, value, _i, _len;\n      query = '';\n      stringifyKeyValuePair = function(encodedKey, value) {\n        if (value != null) {\n          return '&' + encodedKey + '=' + encodeURIComponent(value);\n        } else {\n          return '';\n        }\n      };\n      for (key in queryParams) {\n        if (!__hasProp.call(queryParams, key)) continue;\n        value = queryParams[key];\n        encodedKey = encodeURIComponent(key);\n        if (utils.isArray(value)) {\n          for (_i = 0, _len = value.length; _i < _len; _i++) {\n            arrParam = value[_i];\n            query += stringifyKeyValuePair(encodedKey, arrParam);\n          }\n        } else {\n          query += stringifyKeyValuePair(encodedKey, value);\n        }\n      }\n      return query && query.substring(1);\n    },\n    parse: function(queryString) {\n      var current, field, pair, pairs, params, value, _i, _len, _ref;\n      params = {};\n      if (!queryString) {\n        return params;\n      }\n      pairs = queryString.split('&');\n      for (_i = 0, _len = pairs.length; _i < _len; _i++) {\n        pair = pairs[_i];\n        if (!pair.length) {\n          continue;\n        }\n        _ref = pair.split('='), field = _ref[0], value = _ref[1];\n        if (!field.length) {\n          continue;\n        }\n        field = decodeURIComponent(field);\n        value = decodeURIComponent(value);\n        current = params[field];\n        if (current) {\n          if (current.push) {\n            current.push(value);\n          } else {\n            params[field] = [current, value];\n          }\n        } else {\n          params[field] = value;\n        }\n      }\n      return params;\n    }\n  }\n};\n\nif (typeof Object.seal === \"function\") {\n  Object.seal(utils);\n}\n\nmodule.exports = utils;\n\n});;loader.register('chaplin', function(e, r, module) {\n\nmodule.exports = {\n  Application: loader('chaplin/application'),\n  mediator: loader('chaplin/mediator'),\n  Dispatcher: loader('chaplin/dispatcher'),\n  Controller: loader('chaplin/controllers/controller'),\n  Composer: loader('chaplin/composer'),\n  Composition: loader('chaplin/lib/composition'),\n  Collection: loader('chaplin/models/collection'),\n  Model: loader('chaplin/models/model'),\n  Layout: loader('chaplin/views/layout'),\n  View: loader('chaplin/views/view'),\n  CollectionView: loader('chaplin/views/collection_view'),\n  Route: loader('chaplin/lib/route'),\n  Router: loader('chaplin/lib/router'),\n  EventBroker: loader('chaplin/lib/event_broker'),\n  support: loader('chaplin/lib/support'),\n  SyncMachine: loader('chaplin/lib/sync_machine'),\n  utils: loader('chaplin/lib/utils')\n};\n\n});\nvar regDeps = function(Backbone, _) {\n  loader.register('backbone', function(exports, require, module) {\n    module.exports = Backbone;\n  });\n  loader.register('underscore', function(exports, require, module) {\n    module.exports = _;\n  });\n};\n\nif (typeof define === 'function' && define.amd) {\n  define(['backbone', 'underscore'], function(Backbone, _) {\n    regDeps(Backbone, _);\n    return loader('chaplin');\n  });\n} else if (typeof module === 'object' && module && module.exports) {\n  regDeps(require('backbone'), require('underscore'));\n  module.exports = loader('chaplin');\n} else if (typeof require === 'function') {\n  regDeps(window.Backbone, window._ || window.Backbone.utils);\n  window.Chaplin = loader('chaplin');\n} else {\n  throw new Error('Chaplin requires Common.js or AMD modules');\n}\n\n})();","// Console-polyfill. MIT license.\n// https://github.com/paulmillr/console-polyfill\n// Make it safe to do console.log() always.\n(function (con) {\n  'use strict';\n  var prop, method;\n  var empty = {};\n  var dummy = function() {};\n  var properties = 'memory'.split(',');\n  var methods = ('assert,count,debug,dir,dirxml,error,exception,group,' +\n     'groupCollapsed,groupEnd,info,log,markTimeline,profile,profileEnd,' +\n     'time,timeEnd,trace,warn').split(',');\n  while (prop = properties.pop()) con[prop] = con[prop] || empty;\n  while (method = methods.pop()) con[method] = con[method] || dummy;\n})(window.console = window.console || {});\n","!function(e){\"object\"==typeof exports?module.exports=e():\"function\"==typeof define&&define.amd?define(e):\"undefined\"!=typeof window?window.PouchDB=e():\"undefined\"!=typeof global?global.PouchDB=e():\"undefined\"!=typeof self&&(self.PouchDB=e())}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/*globals cordova */\n\n\"use strict\";\n\nvar utils = require('./utils');\nvar merge = require('./merge');\nvar errors = require('./deps/errors');\nvar call = utils.call;\n\n/*\n * A generic pouch adapter\n */\n\n// returns first element of arr satisfying callback predicate\nfunction arrayFirst(arr, callback) {\n  for (var i = 0; i < arr.length; i++) {\n    if (callback(arr[i], i) === true) {\n      return arr[i];\n    }\n  }\n  return false;\n}\n\n// Wrapper for functions that call the bulkdocs api with a single doc,\n// if the first result is an error, return an error\nfunction yankError(callback) {\n  return function (err, results) {\n    if (err || results[0].error) {\n      call(callback, err || results[0]);\n    } else {\n      call(callback, null, results[0]);\n    }\n  };\n}\n\n// for every node in a revision tree computes its distance from the closest\n// leaf\nfunction computeHeight(revs) {\n  var height = {};\n  var edges = [];\n  merge.traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\n    var rev = pos + \"-\" + id;\n    if (isLeaf) {\n      height[rev] = 0;\n    }\n    if (prnt !== undefined) {\n      edges.push({from: prnt, to: rev});\n    }\n    return rev;\n  });\n\n  edges.reverse();\n  edges.forEach(function (edge) {\n    if (height[edge.from] === undefined) {\n      height[edge.from] = 1 + height[edge.to];\n    } else {\n      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n    }\n  });\n  return height;\n}\n\nmodule.exports = function (Pouch) {\n  return function (opts, callback) {\n    var api = {};\n\n    var customApi = Pouch.adapters[opts.adapter](opts, function (err, db) {\n      if (err) {\n        if (callback) {\n          callback(err);\n        }\n        return;\n      }\n\n      for (var j in api) {\n        if (!db.hasOwnProperty(j)) {\n          db[j] = api[j];\n        }\n      }\n\n      // Don't call Pouch.open for ALL_DBS\n      // Pouch.open saves the db's name into ALL_DBS\n      if (opts.name === Pouch.prefix + Pouch.ALL_DBS) {\n        callback(err, db);\n      } else {\n        Pouch.open(opts, function (err) {\n          callback(err, db);\n        });\n      }\n    });\n\n    var auto_compaction = (opts.auto_compaction === true);\n\n    // wraps a callback with a function that runs compaction after each edit\n    function autoCompact(callback) {\n      if (!auto_compaction) {\n        return callback;\n      }\n      return function (err, res) {\n        if (err) {\n          call(callback, err);\n        } else {\n          var count = res.length;\n          var decCount = function () {\n            count--;\n            if (!count) {\n              call(callback, null, res);\n            }\n          };\n          res.forEach(function (doc) {\n            if (doc.ok) {\n              // TODO: we need better error handling\n              compactDocument(doc.id, 1, decCount);\n            } else {\n              decCount();\n            }\n          });\n        }\n      };\n    }\n\n    api.post = function (doc, opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n      if (typeof doc !== 'object' || Array.isArray(doc)) {\n        return call(callback, errors.NOT_AN_OBJECT);\n      }\n      return customApi.bulkDocs({docs: [doc]}, opts,\n          autoCompact(yankError(callback)));\n    };\n\n    api.put = function (doc, opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n      if (typeof doc !== 'object') {\n        return call(callback, errors.NOT_AN_OBJECT);\n      }\n      if (!utils.isValidId(doc._id)) {\n        return call(callback, errors.MISSING_ID);\n      }\n      return customApi.bulkDocs({docs: [doc]}, opts,\n          autoCompact(yankError(callback)));\n    };\n\n    api.putAttachment = function (docId, attachmentId, rev, blob, type, callback) {\n      if (!api.taskqueue.ready()) {\n        api.taskqueue.addTask('putAttachment', arguments);\n        return;\n      }\n      if (typeof type === 'function') {\n        callback = type;\n        type = blob;\n        blob = rev;\n        rev = null;\n      }\n      if (typeof type === 'undefined') {\n        type = blob;\n        blob = rev;\n        rev = null;\n      }\n\n      function createAttachment(doc) {\n        doc._attachments = doc._attachments || {};\n        doc._attachments[attachmentId] = {\n          content_type: type,\n          data: blob\n        };\n        api.put(doc, callback);\n      }\n\n      api.get(docId, function (err, doc) {\n        // create new doc\n        if (err && err.error === errors.MISSING_DOC.error) {\n          createAttachment({_id: docId});\n          return;\n        }\n        if (err) {\n          call(callback, err);\n          return;\n        }\n\n        if (doc._rev !== rev) {\n          call(callback, errors.REV_CONFLICT);\n          return;\n        }\n\n        createAttachment(doc);\n      });\n    };\n\n    api.removeAttachment = function (docId, attachmentId, rev, callback) {\n      api.get(docId, function (err, obj) {\n        if (err) {\n          call(callback, err);\n          return;\n        }\n        if (obj._rev !== rev) {\n          call(callback, errors.REV_CONFLICT);\n          return;\n        }\n        if (!obj._attachments) {\n          return call(callback, null);\n        }\n        delete obj._attachments[attachmentId];\n        if (Object.keys(obj._attachments).length === 0) {\n          delete obj._attachments;\n        }\n        api.put(obj, callback);\n      });\n    };\n\n    api.remove = function (doc, opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n      if (opts === undefined) {\n        opts = {};\n      }\n      opts.was_delete = true;\n      var newDoc = {_id: doc._id, _rev: doc._rev};\n      newDoc._deleted = true;\n      return customApi.bulkDocs({docs: [newDoc]}, opts, yankError(callback));\n    };\n\n    api.revsDiff = function (req, opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n      var ids = Object.keys(req);\n      var count = 0;\n      var missing = {};\n\n      function addToMissing(id, revId) {\n        if (!missing[id]) {\n          missing[id] = {missing: []};\n        }\n        missing[id].missing.push(revId);\n      }\n\n      function processDoc(id, rev_tree) {\n        // Is this fast enough? Maybe we should switch to a set simulated by a map\n        var missingForId = req[id].slice(0);\n        merge.traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,\n          opts) {\n            var rev = pos + '-' + revHash;\n            var idx = missingForId.indexOf(rev);\n            if (idx === -1) {\n              return;\n            }\n\n            missingForId.splice(idx, 1);\n            if (opts.status !== 'available') {\n              addToMissing(id, rev);\n            }\n          });\n\n        // Traversing the tree is synchronous, so now `missingForId` contains\n        // revisions that were not found in the tree\n        missingForId.forEach(function (rev) {\n          addToMissing(id, rev);\n        });\n      }\n\n      ids.map(function (id) {\n        customApi._getRevisionTree(id, function (err, rev_tree) {\n          if (err && err.name === 'not_found' && err.message === 'missing') {\n            missing[id] = {missing: req[id]};\n          } else if (err) {\n            return call(callback, err);\n          } else {\n            processDoc(id, rev_tree);\n          }\n\n          if (++count === ids.length) {\n            return call(callback, null, missing);\n          }\n        });\n      });\n    };\n\n    // compact one document and fire callback\n    // by compacting we mean removing all revisions which\n    // are further from the leaf in revision tree than max_height\n    function compactDocument(docId, max_height, callback) {\n      customApi._getRevisionTree(docId, function (err, rev_tree) {\n        if (err) {\n          return call(callback);\n        }\n        var height = computeHeight(rev_tree);\n        var candidates = [];\n        var revs = [];\n        Object.keys(height).forEach(function (rev) {\n          if (height[rev] > max_height) {\n            candidates.push(rev);\n          }\n        });\n\n        merge.traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx, opts) {\n          var rev = pos + '-' + revHash;\n          if (opts.status === 'available' && candidates.indexOf(rev) !== -1) {\n            opts.status = 'missing';\n            revs.push(rev);\n          }\n        });\n        customApi._doCompaction(docId, rev_tree, revs, callback);\n      });\n    }\n\n    // compact the whole database using single document\n    // compaction\n    api.compact = function (opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n      api.changes({complete: function (err, res) {\n        if (err) {\n          call(callback); // TODO: silently fail\n          return;\n        }\n        var count = res.results.length;\n        if (!count) {\n          call(callback);\n          return;\n        }\n        res.results.forEach(function (row) {\n          compactDocument(row.id, 0, function () {\n            count--;\n            if (!count) {\n              call(callback);\n            }\n          });\n        });\n      }});\n    };\n\n    /* Begin api wrappers. Specific functionality to storage belongs in the _[method] */\n    api.get = function (id, opts, callback) {\n      if (!api.taskqueue.ready()) {\n        api.taskqueue.addTask('get', arguments);\n        return;\n      }\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n\n      var leaves = [];\n      function finishOpenRevs() {\n        var result = [];\n        var count = leaves.length;\n        if (!count) {\n          return call(callback, null, result);\n        }\n        // order with open_revs is unspecified\n        leaves.forEach(function (leaf) {\n          api.get(id, {rev: leaf, revs: opts.revs}, function (err, doc) {\n            if (!err) {\n              result.push({ok: doc});\n            } else {\n              result.push({missing: leaf});\n            }\n            count--;\n            if (!count) {\n              call(callback, null, result);\n            }\n          });\n        });\n      }\n\n      if (opts.open_revs) {\n        if (opts.open_revs === \"all\") {\n          customApi._getRevisionTree(id, function (err, rev_tree) {\n            if (err) {\n              // if there's no such document we should treat this\n              // situation the same way as if revision tree was empty\n              rev_tree = [];\n            }\n            leaves = merge.collectLeaves(rev_tree).map(function (leaf) {\n              return leaf.rev;\n            });\n            finishOpenRevs();\n          });\n        } else {\n          if (Array.isArray(opts.open_revs)) {\n            leaves = opts.open_revs;\n            for (var i = 0; i < leaves.length; i++) {\n              var l = leaves[i];\n              // looks like it's the only thing couchdb checks\n              if (!(typeof(l) === \"string\" && /^\\d+-/.test(l))) {\n                return call(callback, errors.error(errors.BAD_REQUEST,\n                  \"Invalid rev format\"));\n              }\n            }\n            finishOpenRevs();\n          } else {\n            return call(callback, errors.error(errors.UNKNOWN_ERROR,\n              'function_clause'));\n          }\n        }\n        return; // open_revs does not like other options\n      }\n\n      return customApi._get(id, opts, function (err, result) {\n        if (err) {\n          return call(callback, err);\n        }\n\n        var doc = result.doc;\n        var metadata = result.metadata;\n        var ctx = result.ctx;\n\n        if (opts.conflicts) {\n          var conflicts = merge.collectConflicts(metadata);\n          if (conflicts.length) {\n            doc._conflicts = conflicts;\n          }\n        }\n\n        if (opts.revs || opts.revs_info) {\n          var paths = merge.rootToLeaf(metadata.rev_tree);\n          var path = arrayFirst(paths, function (arr) {\n            return arr.ids.map(function (x) { return x.id; })\n              .indexOf(doc._rev.split('-')[1]) !== -1;\n          });\n\n          path.ids.splice(path.ids.map(function (x) {return x.id; })\n                          .indexOf(doc._rev.split('-')[1]) + 1);\n          path.ids.reverse();\n\n          if (opts.revs) {\n            doc._revisions = {\n              start: (path.pos + path.ids.length) - 1,\n              ids: path.ids.map(function (rev) {\n                return rev.id;\n              })\n            };\n          }\n          if (opts.revs_info) {\n            var pos =  path.pos + path.ids.length;\n            doc._revs_info = path.ids.map(function (rev) {\n              pos--;\n              return {\n                rev: pos + '-' + rev.id,\n                status: rev.opts.status\n              };\n            });\n          }\n        }\n\n        if (opts.local_seq) {\n          doc._local_seq = result.metadata.seq;\n        }\n\n        if (opts.attachments && doc._attachments) {\n          var attachments = doc._attachments;\n          var count = Object.keys(attachments).length;\n          if (count === 0) {\n            return call(callback, null, doc);\n          }\n          Object.keys(attachments).forEach(function (key) {\n            customApi._getAttachment(attachments[key], {encode: true, ctx: ctx}, function (err, data) {\n              doc._attachments[key].data = data;\n              if (!--count) {\n                call(callback, null, doc);\n              }\n            });\n          });\n        } else {\n          if (doc._attachments) {\n            for (var key in doc._attachments) {\n              doc._attachments[key].stub = true;\n            }\n          }\n          call(callback, null, doc);\n        }\n      });\n    };\n\n    api.getAttachment = function (docId, attachmentId, opts, callback) {\n      if (!api.taskqueue.ready()) {\n        api.taskqueue.addTask('getAttachment', arguments);\n        return;\n      }\n      if (opts instanceof Function) {\n        callback = opts;\n        opts = {};\n      }\n      customApi._get(docId, opts, function (err, res) {\n        if (err) {\n          return call(callback, err);\n        }\n        if (res.doc._attachments && res.doc._attachments[attachmentId]) {\n          opts.ctx = res.ctx;\n          customApi._getAttachment(res.doc._attachments[attachmentId], opts, callback);\n        } else {\n          return call(callback, errors.MISSING_DOC);\n        }\n      });\n    };\n\n    api.allDocs = function (opts, callback) {\n      if (!api.taskqueue.ready()) {\n        api.taskqueue.addTask('allDocs', arguments);\n        return;\n      }\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n      if ('keys' in opts) {\n        if ('startkey' in opts) {\n          call(callback, errors.error(errors.QUERY_PARSE_ERROR,\n            'Query parameter `start_key` is not compatible with multi-get'\n          ));\n          return;\n        }\n        if ('endkey' in opts) {\n          call(callback, errors.error(errors.QUERY_PARSE_ERROR,\n            'Query parameter `end_key` is not compatible with multi-get'\n          ));\n          return;\n        }\n      }\n      if (typeof opts.skip === 'undefined') {\n        opts.skip = 0;\n      }\n\n      return customApi._allDocs(opts, callback);\n    };\n\n    function processChange(doc, metadata, opts) {\n      var changeList = [{rev: doc._rev}];\n      if (opts.style === 'all_docs') {\n        changeList = merge.collectLeaves(metadata.rev_tree)\n        .map(function (x) { return {rev: x.rev}; });\n      }\n      var change = {\n        id: metadata.id,\n        changes: changeList,\n        doc: doc\n      };\n\n      if (utils.isDeleted(metadata, doc._rev)) {\n        change.deleted = true;\n      }\n      if (opts.conflicts) {\n        change.doc._conflicts = merge.collectConflicts(metadata);\n        if (!change.doc._conflicts.length) {\n          delete change.doc._conflicts;\n        }\n      }\n      return change;\n    }\n    api.changes = function (opts) {\n      if (!api.taskqueue.ready()) {\n        var task = api.taskqueue.addTask('changes', arguments);\n        return {\n          cancel: function () {\n            if (task.task) {\n              return task.task.cancel();\n            }\n            if (Pouch.DEBUG) {\n              //console.log('Cancel Changes Feed');\n            }\n            task.parameters[0].aborted = true;\n          }\n        };\n      }\n      opts = utils.extend(true, {}, opts);\n      opts.processChange = processChange;\n\n      if (!opts.since) {\n        opts.since = 0;\n      }\n      if (opts.since === 'latest') {\n        var changes;\n        api.info(function (err, info) {\n          if (!opts.aborted) {\n            opts.since = info.update_seq  - 1;\n            api.changes(opts);\n          }\n        });\n        // Return a method to cancel this method from processing any more\n        return {\n          cancel: function () {\n            if (changes) {\n              return changes.cancel();\n            }\n            if (Pouch.DEBUG) {\n              //console.log('Cancel Changes Feed');\n            }\n            opts.aborted = true;\n          }\n        };\n      }\n\n      if (opts.filter && typeof opts.filter === 'string') {\n        if (opts.filter === '_view') {\n          if (opts.view && typeof opts.view === 'string') {\n            // fetch a view from a design doc, make it behave like a filter\n            var viewName = opts.view.split('/');\n            api.get('_design/' + viewName[0], function (err, ddoc) {\n              if (ddoc && ddoc.views && ddoc.views[viewName[1]]) {\n                /*jshint evil: true */\n                var filter = eval('(function () {' + \n                                  '  return function (doc) {' + \n                                  '    var emitted = false;' + \n                                  '    var emit = function (a, b) {' + \n                                  '      emitted = true;' + \n                                  '    };' + \n                                  '    var view = ' + ddoc.views[viewName[1]].map + ';' + \n                                  '    view(doc);' + \n                                  '    if (emitted) {' + \n                                  '      return true;' + \n                                  '    }' + \n                                  '  }' + \n                                  '})()');\n                if (!opts.aborted) {\n                  opts.filter = filter;\n                  api.changes(opts);\n                }\n              } else {\n                var msg = ddoc.views ? 'missing json key: ' + viewName[1] :\n                  'missing json key: views';\n                err = err || errors.error(errors.MISSING_DOC, msg);\n                utils.call(opts.complete, err);\n              }\n            });\n          } else {\n            var err = errors.error(errors.BAD_REQUEST,\n                                  '`view` filter parameter is not provided.');\n            utils.call(opts.complete, err);\n          }\n        } else {\n          // fetch a filter from a design doc\n          var filterName = opts.filter.split('/');\n          api.get('_design/' + filterName[0], function (err, ddoc) {\n            if (ddoc && ddoc.filters && ddoc.filters[filterName[1]]) {\n              /*jshint evil: true */\n              var filter = eval('(function () { return ' +\n                                ddoc.filters[filterName[1]] + ' })()');\n              if (!opts.aborted) {\n                opts.filter = filter;\n                api.changes(opts);\n              }\n            } else {\n              var msg = (ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]\n                : 'missing json key: filters';\n              err = err || errors.error(errors.MISSING_DOC, msg);\n              utils.call(opts.complete, err);\n            }\n          });\n        }\n        // Return a method to cancel this method from processing any more\n        return {\n          cancel: function () {\n            if (Pouch.DEBUG) {\n              console.log('Cancel Changes Feed');\n            }\n            opts.aborted = true;\n          }\n        };\n      }\n\n      if (!('descending' in opts)) {\n        opts.descending = false;\n      }\n\n      // 0 and 1 should return 1 document\n      opts.limit = opts.limit === 0 ? 1 : opts.limit;\n      return customApi._changes(opts);\n    };\n\n    api.close = function (callback) {\n      if (!api.taskqueue.ready()) {\n        api.taskqueue.addTask('close', arguments);\n        return;\n      }\n      return customApi._close(callback);\n    };\n\n    api.info = function (callback) {\n      if (!api.taskqueue.ready()) {\n        api.taskqueue.addTask('info', arguments);\n        return;\n      }\n      return customApi._info(callback);\n    };\n\n    api.id = function () {\n      return customApi._id();\n    };\n\n    api.type = function () {\n      return (typeof customApi._type === 'function') ? customApi._type() : opts.adapter;\n    };\n\n    api.bulkDocs = function (req, opts, callback) {\n      if (!api.taskqueue.ready()) {\n        api.taskqueue.addTask('bulkDocs', arguments);\n        return;\n      }\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n      if (!opts) {\n        opts = {};\n      } else {\n        opts = utils.extend(true, {}, opts);\n      }\n\n      if (!req || !req.docs || req.docs.length < 1) {\n        return call(callback, errors.MISSING_BULK_DOCS);\n      }\n\n      if (!Array.isArray(req.docs)) {\n        return call(callback, errors.QUERY_PARSE_ERROR);\n      }\n\n      for (var i = 0; i < req.docs.length; ++i) {\n        if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\n          return call(callback, errors.NOT_AN_OBJECT);\n        }\n      }\n\n      req = utils.extend(true, {}, req);\n      if (!('new_edits' in opts)) {\n        opts.new_edits = true;\n      }\n\n      return customApi._bulkDocs(req, opts, autoCompact(callback));\n    };\n\n    /* End Wrappers */\n    var taskqueue = {};\n\n    taskqueue.ready = false;\n    taskqueue.queue = [];\n\n    api.taskqueue = {};\n\n    api.taskqueue.execute = function (db) {\n      if (taskqueue.ready) {\n        taskqueue.queue.forEach(function (d) {\n          d.task = db[d.name].apply(null, d.parameters);\n        });\n      }\n    };\n\n    api.taskqueue.ready = function () {\n      if (arguments.length === 0) {\n        return taskqueue.ready;\n      }\n      taskqueue.ready = arguments[0];\n    };\n\n    api.taskqueue.addTask = function (name, parameters) {\n      var task = { name: name, parameters: parameters };\n      taskqueue.queue.push(task);\n      return task;\n    };\n\n    api.replicate = {};\n\n    api.replicate.from = function (url, opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n      return Pouch.replicate(url, customApi, opts, callback);\n    };\n\n    api.replicate.to = function (dbName, opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n      return Pouch.replicate(customApi, dbName, opts, callback);\n    };\n\n    for (var j in api) {\n      if (!customApi.hasOwnProperty(j)) {\n        customApi[j] = api[j];\n      }\n    }\n\n    // Http adapter can skip setup so we force the db to be ready and execute any jobs\n    if (opts.skipSetup) {\n      api.taskqueue.ready(true);\n      api.taskqueue.execute(api);\n    }\n\n    if (utils.isCordova()) {\n      //to inform websql adapter that we can use api\n      cordova.fireWindowEvent(opts.name + \"_pouch\", {});\n    }\n    return customApi;\n  };\n};\n\n},{\"./deps/errors\":8,\"./merge\":13,\"./utils\":16}],2:[function(require,module,exports){\n\"use strict\";\n\nvar utils = require('../utils');\nvar errors = require('../deps/errors');\n\n// parseUri 1.2.2\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nfunction parseUri(str) {\n  var o = parseUri.options;\n  var m = o.parser[o.strictMode ? \"strict\" : \"loose\"].exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    uri[o.key[i]] = m[i] || \"\";\n  }\n\n  uri[o.q.name] = {};\n  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\n    if ($1) {\n      uri[o.q.name][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\nfunction encodeDocId(id) {\n  if (/^_(design|local)/.test(id)) {\n    return id;\n  }\n  return encodeURIComponent(id);\n}\n\nparseUri.options = {\n  strictMode: false,\n  key: [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\",\n        \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"],\n  q:   {\n    name:   \"queryKey\",\n    parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n  },\n  parser: {\n    strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n    loose:  /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n  }\n};\n\n// Get all the information you possibly can about the URI given by name and\n// return it as a suitable object.\nfunction getHost(name, opts) {\n  // If the given name contains \"http:\"\n  if (/http(s?):/.test(name)) {\n    // Prase the URI into all its little bits\n    var uri = parseUri(name);\n\n    // Store the fact that it is a remote URI\n    uri.remote = true;\n\n    // Store the user and password as a separate auth object\n    if (uri.user || uri.password) {\n      uri.auth = {username: uri.user, password: uri.password};\n    }\n\n    // Split the path part of the URI into parts using '/' as the delimiter\n    // after removing any leading '/' and any trailing '/'\n    var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\n    // Store the first part as the database name and remove it from the parts\n    // array\n    uri.db = parts.pop();\n\n    // Restore the path by joining all the remaining parts (all the parts\n    // except for the database name) with '/'s\n    uri.path = parts.join('/');\n    opts = opts || {};\n    uri.headers = opts.headers || {};\n\n    if (opts.auth || uri.auth) {\n      var nAuth = opts.auth || uri.auth;\n      var token = utils.btoa(nAuth.username + ':' + nAuth.password);\n      uri.headers.Authorization = 'Basic ' + token;\n    }\n\n    if (opts.headers) {\n      uri.headers = opts.headers;\n    }\n\n    return uri;\n  }\n\n  // If the given name does not contain 'http:' then return a very basic object\n  // with no host, the current path, the given name as the database name and no\n  // username/password\n  return {host: '', path: '/', db: name, auth: false};\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genDBUrl(opts, path) {\n  // If the host is remote\n  if (opts.remote) {\n    // If the host already has a path, then we need to have a path delimiter\n    // Otherwise, the path delimiter is the empty string\n    var pathDel = !opts.path ? '' : '/';\n\n    // Return the URL made up of all the host's information and the given path\n    return opts.protocol + '://' + opts.host + ':' + opts.port + '/' +\n      opts.path + pathDel + opts.db + '/' + path;\n  }\n\n  // If the host is not remote, then return the URL made up of just the\n  // database name and the given path\n  return '/' + opts.db + '/' + path;\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genUrl(opts, path) {\n  if (opts.remote) {\n    // If the host already has a path, then we need to have a path delimiter\n    // Otherwise, the path delimiter is the empty string\n    var pathDel = !opts.path ? '' : '/';\n\n    // If the host already has a path, then we need to have a path delimiter\n    // Otherwise, the path delimiter is the empty string\n    return opts.protocol + '://' + opts.host + ':' + opts.port + '/' + opts.path + pathDel + path;\n  }\n\n  return '/' + path;\n}\n\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\nfunction HttpPouch(opts, callback) {\n\n  // Parse the URI given by opts.name into an easy-to-use object\n  var host = getHost(opts.name, opts);\n\n  // Generate the database URL based on the host\n  var db_url = genDBUrl(host, '');\n\n  // The functions that will be publically available for HttpPouch\n  var api = {};\n  var ajaxOpts = opts.ajax || {};\n  function ajax(options, callback) {\n    return utils.ajax(utils.extend({}, ajaxOpts, options), callback);\n  }\n  var uuids = {\n    list: [],\n    get: function (opts, callback) {\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {count: 10};\n      }\n      var cb = function (err, body) {\n        if (err || !('uuids' in body)) {\n          utils.call(callback, err || errors.UNKNOWN_ERROR);\n        } else {\n          uuids.list = uuids.list.concat(body.uuids);\n          utils.call(callback, null, \"OK\");\n        }\n      };\n      var params = '?count=' + opts.count;\n      ajax({\n        headers: host.headers,\n        method: 'GET',\n        url: genUrl(host, '_uuids') + params\n      }, cb);\n    }\n  };\n\n  // Create a new CouchDB database based on the given opts\n  var createDB = function () {\n    ajax({headers: host.headers, method: 'PUT', url: db_url}, function (err, ret) {\n      // If we get an \"Unauthorized\" error\n      if (err && err.status === 401) {\n        // Test if the database already exists\n        ajax({headers: host.headers, method: 'HEAD', url: db_url}, function (err, ret) {\n          // If there is still an error\n          if (err) {\n            // Give the error to the callback to deal with\n            utils.call(callback, err);\n          } else {\n            // Continue as if there had been no errors\n            utils.call(callback, null, api);\n          }\n        });\n        // If there were no errros or if the only error is \"Precondition Failed\"\n        // (note: \"Precondition Failed\" occurs when we try to create a database\n        // that already exists)\n      } else if (!err || err.status === 412) {\n        // Continue as if there had been no errors\n        utils.call(callback, null, api);\n      } else {\n        utils.call(callback, errors.UNKNOWN_ERROR);\n      }\n    });\n  };\n  if (!opts.skipSetup) {\n    ajax({headers: host.headers, method: 'GET', url: db_url}, function (err, ret) {\n      //check if the db exists\n      if (err) {\n        if (err.status === 404) {\n          //if it doesn't, create it\n          createDB();\n        } else {\n          utils.call(callback, err);\n        }\n      } else {\n        //go do stuff with the db\n        utils.call(callback, null, api);\n      }\n    });\n  }\n\n  api.type = function () {\n    return 'http';\n  };\n\n  // The HttpPouch's ID is its URL\n  api.id = function () {\n    return genDBUrl(host, '');\n  };\n\n  api.request = function (options, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('request', arguments);\n      return;\n    }\n    options.headers = host.headers;\n    options.url = genDBUrl(host, options.url);\n    ajax(options, callback);\n  };\n\n  // Sends a POST request to the host calling the couchdb _compact function\n  //    version: The version of CouchDB it is running\n  api.compact = function (opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('compact', arguments);\n      return;\n    }\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    ajax({\n      headers: host.headers,\n      url: genDBUrl(host, '_compact'),\n      method: 'POST'\n    }, function () {\n      function ping() {\n        api.info(function (err, res) {\n          if (!res.compact_running) {\n            utils.call(callback, null);\n          } else {\n            setTimeout(ping, opts.interval || 200);\n          }\n        });\n      }\n      // Ping the http if it's finished compaction\n      if (typeof callback === \"function\") {\n        ping();\n      }\n    });\n  };\n\n  // Calls GET on the host, which gets back a JSON string containing\n  //    couchdb: A welcome string\n  //    version: The version of CouchDB it is running\n  api.info = function (callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('info', arguments);\n      return;\n    }\n    ajax({\n      headers: host.headers,\n      method: 'GET',\n      url: genDBUrl(host, '')\n    }, callback);\n  };\n\n  // Get the document with the given id from the database given by host.\n  // The id could be solely the _id in the database, or it may be a\n  // _design/ID or _local/ID path\n  api.get = function (id, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('get', arguments);\n      return;\n    }\n    // If no options were given, set the callback to the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    if (opts.auto_encode === undefined) {\n      opts.auto_encode = true;\n    }\n\n    // List of parameters to add to the GET request\n    var params = [];\n\n    // If it exists, add the opts.revs value to the list of parameters.\n    // If revs=true then the resulting JSON will include a field\n    // _revisions containing an array of the revision IDs.\n    if (opts.revs) {\n      params.push('revs=true');\n    }\n\n    // If it exists, add the opts.revs_info value to the list of parameters.\n    // If revs_info=true then the resulting JSON will include the field\n    // _revs_info containing an array of objects in which each object\n    // representing an available revision.\n    if (opts.revs_info) {\n      params.push('revs_info=true');\n    }\n\n    if (opts.local_seq) {\n      params.push('local_seq=true');\n    }\n    // If it exists, add the opts.open_revs value to the list of parameters.\n    // If open_revs=all then the resulting JSON will include all the leaf\n    // revisions. If open_revs=[\"rev1\", \"rev2\",...] then the resulting JSON\n    // will contain an array of objects containing data of all revisions\n    if (opts.open_revs) {\n      if (opts.open_revs !== \"all\") {\n        opts.open_revs = JSON.stringify(opts.open_revs);\n      }\n      params.push('open_revs=' + opts.open_revs);\n    }\n\n    // If it exists, add the opts.attachments value to the list of parameters.\n    // If attachments=true the resulting JSON will include the base64-encoded\n    // contents in the \"data\" property of each attachment.\n    if (opts.attachments) {\n      params.push('attachments=true');\n    }\n\n    // If it exists, add the opts.rev value to the list of parameters.\n    // If rev is given a revision number then get the specified revision.\n    if (opts.rev) {\n      params.push('rev=' + opts.rev);\n    }\n\n    // If it exists, add the opts.conflicts value to the list of parameters.\n    // If conflicts=true then the resulting JSON will include the field\n    // _conflicts containing all the conflicting revisions.\n    if (opts.conflicts) {\n      params.push('conflicts=' + opts.conflicts);\n    }\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    if (opts.auto_encode) {\n      id = encodeDocId(id);\n    }\n\n    // Set the options for the ajax call\n    var options = {\n      headers: host.headers,\n      method: 'GET',\n      url: genDBUrl(host, id + params)\n    };\n\n    // If the given id contains at least one '/' and the part before the '/'\n    // is NOT \"_design\" and is NOT \"_local\"\n    // OR\n    // If the given id contains at least two '/' and the part before the first\n    // '/' is \"_design\".\n    // TODO This second condition seems strange since if parts[0] === '_design'\n    // then we already know that parts[0] !== '_local'.\n    var parts = id.split('/');\n    if ((parts.length > 1 && parts[0] !== '_design' && parts[0] !== '_local') ||\n        (parts.length > 2 && parts[0] === '_design' && parts[0] !== '_local')) {\n      // Binary is expected back from the server\n      options.binary = true;\n    }\n\n    // Get the document\n    ajax(options, function (err, doc, xhr) {\n      // If the document does not exist, send an error to the callback\n      if (err) {\n        return utils.call(callback, err);\n      }\n\n      // Send the document to the callback\n      utils.call(callback, null, doc, xhr);\n    });\n  };\n\n  // Delete the document given by doc from the database given by host.\n  api.remove = function (doc, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('remove', arguments);\n      return;\n    }\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Delete the document\n    ajax({\n      headers: host.headers,\n      method: 'DELETE',\n      url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + doc._rev\n    }, callback);\n  };\n\n  // Get the attachment\n  api.getAttachment = function (docId, attachmentId, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    if (opts.auto_encode === undefined) {\n      opts.auto_encode = true;\n    }\n    if (opts.auto_encode) {\n      docId = encodeDocId(docId);\n    }\n    opts.auto_encode = false;\n    api.get(docId + '/' + attachmentId, opts, callback);\n  };\n\n  // Remove the attachment given by the id and rev\n  api.removeAttachment = function (docId, attachmentId, rev, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('removeAttachment', arguments);\n      return;\n    }\n    ajax({\n      headers: host.headers,\n      method: 'DELETE',\n      url: genDBUrl(host, encodeDocId(docId) + '/' + attachmentId) + '?rev=' + rev\n    }, callback);\n  };\n\n  // Add the attachment given by blob and its contentType property\n  // to the document with the given id, the revision given by rev, and\n  // add it to the database given by host.\n  api.putAttachment = function (docId, attachmentId, rev, blob, type, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('putAttachment', arguments);\n      return;\n    }\n    if (typeof type === 'function') {\n      callback = type;\n      type = blob;\n      blob = rev;\n      rev = null;\n    }\n    if (typeof type === 'undefined') {\n      type = blob;\n      blob = rev;\n      rev = null;\n    }\n    var id = encodeDocId(docId) + '/' + attachmentId;\n    var url = genDBUrl(host, id);\n    if (rev) {\n      url += '?rev=' + rev;\n    }\n\n    var opts = {\n      headers: host.headers,\n      method: 'PUT',\n      url: url,\n      processData: false,\n      body: blob,\n      timeout: 60000\n    };\n    opts.headers['Content-Type'] = type;\n    // Add the attachment\n    ajax(opts, callback);\n  };\n\n  // Add the document given by doc (in JSON string format) to the database\n  // given by host. This fails if the doc has no _id field.\n  api.put = function (doc, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('put', arguments);\n      return;\n    }\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    if (typeof doc !== 'object') {\n      return utils.call(callback, errors.NOT_AN_OBJECT);\n    }\n    if (!utils.isValidId(doc._id)) {\n      return utils.call(callback, errors.MISSING_ID);\n    }\n\n    // List of parameter to add to the PUT request\n    var params = [];\n\n    // If it exists, add the opts.new_edits value to the list of parameters.\n    // If new_edits = false then the database will NOT assign this document a\n    // new revision number\n    if (opts && typeof opts.new_edits !== 'undefined') {\n      params.push('new_edits=' + opts.new_edits);\n    }\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    if (params !== '') {\n      params = '?' + params;\n    }\n\n    // Add the document\n    ajax({\n      headers: host.headers,\n      method: 'PUT',\n      url: genDBUrl(host, encodeDocId(doc._id)) + params,\n      body: doc\n    }, callback);\n  };\n\n  // Add the document given by doc (in JSON string format) to the database\n  // given by host. This does not assume that doc is a new document (i.e. does not\n  // have a _id or a _rev field.\n  api.post = function (doc, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('post', arguments);\n      return;\n    }\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    if (typeof doc !== 'object') {\n      return utils.call(callback, errors.NOT_AN_OBJECT);\n    }\n    if (! (\"_id\" in doc)) {\n      if (uuids.list.length > 0) {\n        doc._id = uuids.list.pop();\n        api.put(doc, opts, callback);\n      } else {\n        uuids.get(function (err, resp) {\n          if (err) {\n            return utils.call(callback, errors.UNKNOWN_ERROR);\n          }\n          doc._id = uuids.list.pop();\n          api.put(doc, opts, callback);\n        });\n      }\n    } else {\n      api.put(doc, opts, callback);\n    }\n  };\n\n  // Update/create multiple documents given by req in the database\n  // given by host.\n  api.bulkDocs = function (req, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('bulkDocs', arguments);\n      return;\n    }\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    if (!opts) {\n      opts = {};\n    }\n\n    // If opts.new_edits exists add it to the document data to be\n    // send to the database.\n    // If new_edits=false then it prevents the database from creating\n    // new revision numbers for the documents. Instead it just uses\n    // the old ones. This is used in database replication.\n    if (typeof opts.new_edits !== 'undefined') {\n      req.new_edits = opts.new_edits;\n    }\n\n    // Update/create the documents\n    ajax({\n      headers: host.headers,\n      method: 'POST',\n      url: genDBUrl(host, '_bulk_docs'),\n      body: req\n    }, callback);\n  };\n\n  // Get a listing of the documents in the database given\n  // by host and ordered by increasing id.\n  api.allDocs = function (opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('allDocs', arguments);\n      return;\n    }\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // List of parameters to add to the GET request\n    var params = [];\n    var body;\n    var method = 'GET';\n\n    // TODO I don't see conflicts as a valid parameter for a\n    // _all_docs request (see http://wiki.apache.org/couchdb/HTTP_Document_API#all_docs)\n    if (opts.conflicts) {\n      params.push('conflicts=true');\n    }\n\n    // If opts.descending is truthy add it to params\n    if (opts.descending) {\n      params.push('descending=true');\n    }\n\n    // If opts.include_docs exists, add the include_docs value to the\n    // list of parameters.\n    // If include_docs=true then include the associated document with each\n    // result.\n    if (opts.include_docs) {\n      params.push('include_docs=true');\n    }\n\n    // If opts.startkey exists, add the startkey value to the list of\n    // parameters.\n    // If startkey is given then the returned list of documents will\n    // start with the document whose id is startkey.\n    if (opts.startkey) {\n      params.push('startkey=' +\n                  encodeURIComponent(JSON.stringify(opts.startkey)));\n    }\n\n    // If opts.endkey exists, add the endkey value to the list of parameters.\n    // If endkey is given then the returned list of docuemnts will\n    // end with the document whose id is endkey.\n    if (opts.endkey) {\n      params.push('endkey=' + encodeURIComponent(JSON.stringify(opts.endkey)));\n    }\n\n    // If opts.limit exists, add the limit value to the parameter list.\n    if (opts.limit) {\n      params.push('limit=' + opts.limit);\n    }\n\n    if (typeof opts.skip !== 'undefined') {\n      params.push('skip=' + opts.skip);\n    }\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    if (params !== '') {\n      params = '?' + params;\n    }\n\n    // If keys are supplied, issue a POST request to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      method = 'POST';\n      body = JSON.stringify({keys: opts.keys});\n    }\n\n    // Get the document listing\n    ajax({\n      headers: host.headers,\n      method: method,\n      url: genDBUrl(host, '_all_docs' + params),\n      body: body\n    }, callback);\n  };\n\n  // Get a list of changes made to documents in the database given by host.\n  // TODO According to the README, there should be two other methods here,\n  // api.changes.addListener and api.changes.removeListener.\n  api.changes = function (opts) {\n\n    // We internally page the results of a changes request, this means\n    // if there is a large set of changes to be returned we can start\n    // processing them quicker instead of waiting on the entire\n    // set of changes to return and attempting to process them at once\n    var CHANGES_LIMIT = 25;\n\n    if (!api.taskqueue.ready()) {\n      var task = api.taskqueue.addTask('changes', arguments);\n      return {\n        cancel: function () {\n          if (task.task) {\n            return task.task.cancel();\n          }\n          //console.log(db_url + ': Cancel Changes Feed');\n          task.parameters[0].aborted = true;\n        }\n      };\n    }\n\n    if (opts.since === 'latest') {\n      var changes;\n      api.info(function (err, info) {\n        if (!opts.aborted) {\n          opts.since = info.update_seq;\n          changes = api.changes(opts);\n        }\n      });\n      // Return a method to cancel this method from processing any more\n      return {\n        cancel: function () {\n          if (changes) {\n            return changes.cancel();\n          }\n          //console.log(db_url + ': Cancel Changes Feed');\n          opts.aborted = true;\n        }\n      };\n    }\n\n    //console.log(db_url + ': Start Changes Feed: continuous=' + opts.continuous);\n\n    var params = {};\n    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;\n    if (limit === 0) {\n      limit = 1;\n    }\n    //\n    var leftToFetch = limit;\n\n    if (opts.style) {\n      params.style = opts.style;\n    }\n\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n      params.include_docs = true;\n    }\n\n    if (opts.continuous) {\n      params.feed = 'longpoll';\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      params.filter = opts.filter;\n      if (opts.filter === '_view' && opts.view && typeof opts.view === 'string') {\n        params.view = opts.view;\n      }\n    }\n\n    // If opts.query_params exists, pass it through to the changes request.\n    // These parameters may be used by the filter on the source database.\n    if (opts.query_params && typeof opts.query_params === 'object') {\n      for (var param_name in opts.query_params) {\n        if (opts.query_params.hasOwnProperty(param_name)) {\n          params[param_name] = opts.query_params[param_name];\n        }\n      }\n    }\n\n    var xhr;\n    var lastFetchedSeq;\n    var remoteLastSeq;\n    var pagingCount;\n\n    // Get all the changes starting wtih the one immediately after the\n    // sequence number given by since.\n    var fetch = function (since, callback) {\n      params.since = since;\n      if (!opts.continuous && !pagingCount) {\n        pagingCount = remoteLastSeq;\n      }\n      params.limit = (!limit || leftToFetch > CHANGES_LIMIT) ?\n        CHANGES_LIMIT : leftToFetch;\n\n      var paramStr = '?' + Object.keys(params).map(function (k) {\n        return k + '=' + params[k];\n      }).join('&');\n\n      // Set the options for the ajax call\n      var xhrOpts = {\n        headers: host.headers,\n        method: 'GET',\n        url: genDBUrl(host, '_changes' + paramStr),\n        // _changes can take a long time to generate, especially when filtered\n        timeout: null\n      };\n      lastFetchedSeq = since;\n\n      if (opts.aborted) {\n        return;\n      }\n\n      // Get the changes\n      xhr = ajax(xhrOpts, callback);\n    };\n\n    // If opts.since exists, get all the changes from the sequence\n    // number given by opts.since. Otherwise, get all the changes\n    // from the sequence number 0.\n    var fetchTimeout = 10;\n    var fetchRetryCount = 0;\n\n    var results = {results: []};\n\n    var fetched = function (err, res) {\n      // If the result of the ajax call (res) contains changes (res.results)\n      if (res && res.results) {\n        results.last_seq = res.last_seq;\n        // For each change\n        var req = {};\n        req.query = opts.query_params;\n        res.results = res.results.filter(function (c) {\n          leftToFetch--;\n          var ret = utils.filterChange(opts)(c);\n          if (ret) {\n            results.results.push(c);\n            utils.call(opts.onChange, c);\n          }\n          return ret;\n        });\n      } else if (err) {\n        // In case of an error, stop listening for changes and call opts.complete\n        opts.aborted = true;\n        utils.call(opts.complete, err, null);\n      }\n\n      // The changes feed may have timed out with no results\n      // if so reuse last update sequence\n      if (res && res.last_seq) {\n        lastFetchedSeq = res.last_seq;\n      }\n\n      var resultsLength = res && res.results.length || 0;\n\n      pagingCount -= CHANGES_LIMIT;\n\n      var finished = (limit && leftToFetch <= 0) ||\n        (res && !resultsLength && pagingCount <= 0) ||\n        (resultsLength && res.last_seq === remoteLastSeq) ||\n        (opts.descending && lastFetchedSeq !== 0);\n\n      if (opts.continuous || !finished) {\n        // Increase retry delay exponentially as long as errors persist\n        if (err) {\n          fetchRetryCount += 1;\n        } else {\n          fetchRetryCount = 0;\n        }\n        var timeoutMultiplier = 1 << fetchRetryCount;\n        var retryWait = fetchTimeout * timeoutMultiplier;\n        var maximumWait = opts.maximumWait || 30000;\n\n        if (retryWait > maximumWait) {\n          utils.call(opts.complete, err || errors.UNKNOWN_ERROR, null);\n        }\n\n        // Queue a call to fetch again with the newest sequence number\n        setTimeout(function () { fetch(lastFetchedSeq, fetched); }, retryWait);\n      } else {\n        // We're done, call the callback\n        utils.call(opts.complete, null, results);\n      }\n    };\n\n    // If we arent doing a continuous changes request we need to know\n    // the current update_seq so we know when to stop processing the\n    // changes\n    if (opts.continuous) {\n      fetch(opts.since || 0, fetched);\n    } else {\n      api.info(function (err, res) {\n        if (err) {\n          return utils.call(opts.complete, err);\n        }\n        remoteLastSeq = res.update_seq;\n        fetch(opts.since || 0, fetched);\n      });\n    }\n\n    // Return a method to cancel this method from processing any more\n    return {\n      cancel: function () {\n        //console.log(db_url + ': Cancel Changes Feed');\n        opts.aborted = true;\n        xhr.abort();\n      }\n    };\n  };\n\n  // Given a set of document/revision IDs (given by req), tets the subset of\n  // those that do NOT correspond to revisions stored in the database.\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n  api.revsDiff = function (req, opts, callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('revsDiff', arguments);\n      return;\n    }\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Get the missing document/revision IDs\n    ajax({\n      headers: host.headers,\n      method: 'POST',\n      url: genDBUrl(host, '_revs_diff'),\n      body: req\n    }, function (err, res) {\n      utils.call(callback, err, res);\n    });\n  };\n\n  api.close = function (callback) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('close', arguments);\n      return;\n    }\n    utils.call(callback, null);\n  };\n\n  api.replicateOnServer = function (target, opts, promise) {\n    if (!api.taskqueue.ready()) {\n      api.taskqueue.addTask('replicateOnServer', arguments);\n      return promise;\n    }\n\n    var targetHost = getHost(target.id());\n    var params = {\n      source: host.db,\n      target: targetHost.protocol === host.protocol && targetHost.authority === host.authority ? targetHost.db : targetHost.source\n    };\n\n    if (opts.continuous) {\n      params.continuous = true;\n    }\n\n    if (opts.create_target) {\n      params.create_target = true;\n    }\n\n    if (opts.doc_ids) {\n      params.doc_ids = opts.doc_ids;\n    }\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      params.filter = opts.filter;\n    }\n\n    if (opts.query_params) {\n      params.query_params = opts.query_params;\n    }\n\n    var result = {};\n    var repOpts = {\n      headers: host.headers,\n      method: 'POST',\n      url: host.protocol + '://' + host.host + (host.port === 80 ? '' : (':' + host.port)) + '/_replicate',\n      body: params\n    };\n    var xhr;\n    promise.cancel = function () {\n      this.cancelled = true;\n      if (xhr && !result.ok) {\n        xhr.abort();\n      }\n      if (result._local_id) {\n        repOpts.body = {\n          replication_id: result._local_id\n        };\n      }\n      repOpts.body.cancel = true;\n      ajax(repOpts, function (err, resp, xhr) {\n        // If the replication cancel request fails, send an error to the callback\n        if (err) {\n          return utils.call(callback, err);\n        }\n        // Send the replication cancel result to the complete callback\n        utils.call(opts.complete, null, result, xhr);\n      });\n    };\n\n    if (promise.cancelled) {\n      return;\n    }\n\n    xhr = ajax(repOpts, function (err, resp, xhr) {\n      // If the replication fails, send an error to the callback\n      if (err) {\n        return utils.call(callback, err);\n      }\n\n      result.ok = true;\n\n      // Provided by CouchDB from 1.2.0 onward to cancel replication\n      if (resp._local_id) {\n        result._local_id = resp._local_id;\n      }\n\n      // Send the replication result to the complete callback\n      utils.call(opts.complete, null, resp, xhr);\n    });\n  };\n\n  return api;\n}\n\n// Delete the HttpPouch specified by the given name.\nHttpPouch.destroy = function (name, opts, callback) {\n  var host = getHost(name, opts);\n  opts = opts || {};\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts.headers = host.headers;\n  opts.method = 'DELETE';\n  opts.url = genDBUrl(host, '');\n  utils.ajax(opts, callback);\n};\n\n// HttpPouch is a valid adapter.\nHttpPouch.valid = function () {\n  return true;\n};\n\nmodule.exports = HttpPouch;\n\n},{\"../deps/errors\":8,\"../utils\":16}],3:[function(require,module,exports){\n'use strict';\n\nvar utils = require('../utils');\nvar merge = require('../merge');\nvar errors = require('../deps/errors');\nfunction idbError(callback) {\n  return function (event) {\n    utils.call(callback, errors.error(errors.IDB_ERROR, event.target, event.type));\n  };\n}\n\nfunction IdbPouch(opts, callback) {\n\n  // IndexedDB requires a versioned database structure, this is going to make\n  // it hard to dynamically create object stores if we needed to for things\n  // like views\n  var POUCH_VERSION = 1;\n\n  // The object stores created for each database\n  // DOC_STORE stores the document meta data, its revision history and state\n  var DOC_STORE = 'document-store';\n  // BY_SEQ_STORE stores a particular version of a document, keyed by its\n  // sequence id\n  var BY_SEQ_STORE = 'by-sequence';\n  // Where we store attachments\n  var ATTACH_STORE = 'attach-store';\n  // Where we store meta data\n  var META_STORE = 'meta-store';\n  // Where we detect blob support\n  var DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\n\n  var name = opts.name;\n  var req = window.indexedDB.open(name, POUCH_VERSION);\n\n  if (!('openReqList' in IdbPouch)) {\n    IdbPouch.openReqList = {};\n  }\n  IdbPouch.openReqList[name] = req;\n\n  var blobSupport = null;\n\n  var instanceId = null;\n  var api = {};\n  var idb = null;\n\n  req.onupgradeneeded = function (e) {\n    var db = e.target.result;\n    var currentVersion = e.oldVersion;\n    while (currentVersion !== e.newVersion) {\n      if (currentVersion === 0) {\n        createSchema(db);\n      }\n      currentVersion++;\n    }\n  };\n\n  function createSchema(db) {\n    db.createObjectStore(DOC_STORE, {keyPath : 'id'})\n      .createIndex('seq', 'seq', {unique: true});\n    db.createObjectStore(BY_SEQ_STORE, {autoIncrement : true})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n  }\n\n  // From http://stackoverflow.com/questions/14967647/encode-decode-image-with-base64-breaks-image (2013-04-21)\n  function fixBinary(bin) {\n    var length = bin.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    for (var i = 0; i < length; i++) {\n      arr[i] = bin.charCodeAt(i);\n    }\n    return buf;\n  }\n\n  req.onsuccess = function (e) {\n\n    idb = e.target.result;\n\n    idb.onversionchange = function () {\n      idb.close();\n    };\n\n    var txn = idb.transaction([META_STORE, DETECT_BLOB_SUPPORT_STORE],\n                              'readwrite');\n\n    var req = txn.objectStore(META_STORE).get(META_STORE);\n\n    req.onsuccess = function (e) {\n      var meta = e.target.result || {id: META_STORE};\n      if (name + '_id' in meta) {\n        instanceId = meta[name + '_id'];\n      } else {\n        instanceId = utils.uuid();\n        meta[name + '_id'] = instanceId;\n        txn.objectStore(META_STORE).put(meta);\n      }\n\n      // detect blob support\n      try {\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(utils.createBlob(), \"key\");\n        blobSupport = true;\n      } catch (err) {\n        blobSupport = false;\n      } finally {\n        utils.call(callback, null, api);\n      }\n    };\n  };\n\n  req.onerror = idbError(callback);\n\n  api.type = function () {\n    return 'idb';\n  };\n\n  // Each database needs a unique id so that we can store the sequence\n  // checkpoint without having other databases confuse itself.\n  api.id = function idb_id() {\n    return instanceId;\n  };\n\n  api._bulkDocs = function idb_bulkDocs(req, opts, callback) {\n    var newEdits = opts.new_edits;\n    var userDocs = req.docs;\n    // Parse the docs, give them a sequence number for the result\n    var docInfos = userDocs.map(function (doc, i) {\n      var newDoc = utils.parseDoc(doc, newEdits);\n      newDoc._bulk_seq = i;\n      return newDoc;\n    });\n\n    var docInfoErrors = docInfos.filter(function (docInfo) {\n      return docInfo.error;\n    });\n    if (docInfoErrors.length) {\n      return utils.call(callback, docInfoErrors[0]);\n    }\n\n    var results = [];\n    var docsWritten = 0;\n\n    function writeMetaData(e) {\n      var meta = e.target.result;\n      meta.updateSeq = (meta.updateSeq || 0) + docsWritten;\n      txn.objectStore(META_STORE).put(meta);\n    }\n\n    function processDocs() {\n      if (!docInfos.length) {\n        txn.objectStore(META_STORE).get(META_STORE).onsuccess = writeMetaData;\n        return;\n      }\n      var currentDoc = docInfos.shift();\n      var req = txn.objectStore(DOC_STORE).get(currentDoc.metadata.id);\n      req.onsuccess = function process_docRead(event) {\n        var oldDoc = event.target.result;\n        if (!oldDoc) {\n          insertDoc(currentDoc);\n        } else {\n          updateDoc(oldDoc, currentDoc);\n        }\n      };\n    }\n\n    function complete(event) {\n      var aresults = [];\n      results.sort(sortByBulkSeq);\n      results.forEach(function (result) {\n        delete result._bulk_seq;\n        if (result.error) {\n          aresults.push(result);\n          return;\n        }\n        var metadata = result.metadata;\n        var rev = merge.winningRev(metadata);\n\n        aresults.push({\n          ok: true,\n          id: metadata.id,\n          rev: rev\n        });\n\n        if (utils.isLocalId(metadata.id)) {\n          return;\n        }\n\n        IdbPouch.Changes.notify(name);\n        IdbPouch.Changes.notifyLocalWindows(name);\n      });\n      utils.call(callback, null, aresults);\n    }\n\n    function preprocessAttachment(att, finish) {\n      if (att.stub) {\n        return finish();\n      }\n      if (typeof att.data === 'string') {\n        var data;\n        try {\n          data = atob(att.data);\n        } catch (e) {\n          var err = errors.error(errors.BAD_ARG,\n                                \"Attachments need to be base64 encoded\");\n          return utils.call(callback, err);\n        }\n        att.digest = 'md5-' + utils.Crypto.MD5(data);\n        if (blobSupport) {\n          var type = att.content_type;\n          data = fixBinary(data);\n          att.data = utils.createBlob([data], {type: type});\n        }\n        return finish();\n      }\n      var reader = new FileReader();\n      reader.onloadend = function (e) {\n        att.digest = 'md5-' + utils.Crypto.MD5(this.result);\n        if (!blobSupport) {\n          att.data = btoa(this.result);\n        }\n        finish();\n      };\n      reader.readAsBinaryString(att.data);\n    }\n\n    function preprocessAttachments(callback) {\n      if (!docInfos.length) {\n        return callback();\n      }\n\n      var docv = 0;\n      docInfos.forEach(function (docInfo) {\n        var attachments = docInfo.data && docInfo.data._attachments ?\n          Object.keys(docInfo.data._attachments) : [];\n\n        if (!attachments.length) {\n          return done();\n        }\n\n        var recv = 0;\n        function attachmentProcessed() {\n          recv++;\n          if (recv === attachments.length) {\n            done();\n          }\n        }\n\n        for (var key in docInfo.data._attachments) {\n          preprocessAttachment(docInfo.data._attachments[key], attachmentProcessed);\n        }\n      });\n\n      function done() {\n        docv++;\n        if (docInfos.length === docv) {\n          callback();\n        }\n      }\n    }\n\n    function writeDoc(docInfo, callback) {\n      var err = null;\n      var recv = 0;\n      docInfo.data._id = docInfo.metadata.id;\n      docInfo.data._rev = docInfo.metadata.rev;\n\n      docsWritten++;\n\n      if (utils.isDeleted(docInfo.metadata, docInfo.metadata.rev)) {\n        docInfo.data._deleted = true;\n      }\n\n      var attachments = docInfo.data._attachments ?\n        Object.keys(docInfo.data._attachments) : [];\n\n      function collectResults(attachmentErr) {\n        if (!err) {\n          if (attachmentErr) {\n            err = attachmentErr;\n            utils.call(callback, err);\n          } else if (recv === attachments.length) {\n            finish();\n          }\n        }\n      }\n\n      function attachmentSaved(err) {\n        recv++;\n        collectResults(err);\n      }\n\n      for (var key in docInfo.data._attachments) {\n        if (!docInfo.data._attachments[key].stub) {\n          var data = docInfo.data._attachments[key].data;\n          delete docInfo.data._attachments[key].data;\n          var digest = docInfo.data._attachments[key].digest;\n          saveAttachment(docInfo, digest, data, attachmentSaved);\n        } else {\n          recv++;\n          collectResults();\n        }\n      }\n\n      function finish() {\n        docInfo.data._doc_id_rev = docInfo.data._id + \"::\" + docInfo.data._rev;\n        var dataReq = txn.objectStore(BY_SEQ_STORE).put(docInfo.data);\n        dataReq.onsuccess = function (e) {\n          //console.log(name + ': Wrote Document ', docInfo.metadata.id);\n          docInfo.metadata.seq = e.target.result;\n          // Current _rev is calculated from _rev_tree on read\n          delete docInfo.metadata.rev;\n          var metaDataReq = txn.objectStore(DOC_STORE).put(docInfo.metadata);\n          metaDataReq.onsuccess = function () {\n            results.push(docInfo);\n            utils.call(callback);\n          };\n        };\n      }\n\n      if (!attachments.length) {\n        finish();\n      }\n    }\n\n    function updateDoc(oldDoc, docInfo) {\n      var merged = merge.merge(oldDoc.rev_tree, docInfo.metadata.rev_tree[0], 1000);\n      var wasPreviouslyDeleted = utils.isDeleted(oldDoc);\n      var inConflict = (wasPreviouslyDeleted &&\n                        utils.isDeleted(docInfo.metadata)) ||\n        (!wasPreviouslyDeleted && newEdits && merged.conflicts !== 'new_leaf');\n\n      if (inConflict) {\n        results.push(makeErr(errors.REV_CONFLICT, docInfo._bulk_seq));\n        return processDocs();\n      }\n\n      docInfo.metadata.rev_tree = merged.tree;\n      writeDoc(docInfo, processDocs);\n    }\n\n    function insertDoc(docInfo) {\n      // Cant insert new deleted documents\n      if ('was_delete' in opts && utils.isDeleted(docInfo.metadata)) {\n        results.push(errors.MISSING_DOC);\n        return processDocs();\n      }\n      writeDoc(docInfo, processDocs);\n    }\n\n    // Insert sequence number into the error so we can sort later\n    function makeErr(err, seq) {\n      err._bulk_seq = seq;\n      return err;\n    }\n\n    function saveAttachment(docInfo, digest, data, callback) {\n      var objectStore = txn.objectStore(ATTACH_STORE);\n      var getReq = objectStore.get(digest).onsuccess = function (e) {\n        var originalRefs = e.target.result && e.target.result.refs || {};\n        var ref = [docInfo.metadata.id, docInfo.metadata.rev].join('@');\n        var newAtt = {\n          digest: digest,\n          body: data,\n          refs: originalRefs\n        };\n        newAtt.refs[ref] = true;\n        var putReq = objectStore.put(newAtt).onsuccess = function (e) {\n          utils.call(callback);\n        };\n      };\n    }\n\n    var txn;\n    preprocessAttachments(function () {\n      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE, META_STORE],\n                            'readwrite');\n      txn.onerror = idbError(callback);\n      txn.ontimeout = idbError(callback);\n      txn.oncomplete = complete;\n\n      processDocs();\n    });\n  };\n\n  function sortByBulkSeq(a, b) {\n    return a._bulk_seq - b._bulk_seq;\n  }\n\n  // First we look up the metadata in the ids database, then we fetch the\n  // current revision(s) from the by sequence store\n  api._get = function idb_get(id, opts, callback) {\n    var doc;\n    var metadata;\n    var err;\n    var txn;\n    if (opts.ctx) {\n      txn = opts.ctx;\n    } else {\n      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n    }\n\n    function finish() {\n      utils.call(callback, err, {doc: doc, metadata: metadata, ctx: txn});\n    }\n\n    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n      metadata = e.target.result;\n      // we can determine the result here if:\n      // 1. there is no such document\n      // 2. the document is deleted and we don't ask about specific rev\n      // When we ask with opts.rev we expect the answer to be either\n      // doc (possibly with _deleted=true) or missing error\n      if (!metadata) {\n        err = errors.MISSING_DOC;\n        return finish();\n      }\n      if (utils.isDeleted(metadata) && !opts.rev) {\n        err = errors.error(errors.MISSING_DOC, \"deleted\");\n        return finish();\n      }\n\n      var rev = merge.winningRev(metadata);\n      var key = metadata.id + '::' + (opts.rev ? opts.rev : rev);\n      var index = txn.objectStore(BY_SEQ_STORE).index('_doc_id_rev');\n\n      index.get(key).onsuccess = function (e) {\n        doc = e.target.result;\n        if (doc && doc._doc_id_rev) {\n          delete(doc._doc_id_rev);\n        }\n        if (!doc) {\n          err = errors.MISSING_DOC;\n          return finish();\n        }\n        finish();\n      };\n    };\n  };\n\n  api._getAttachment = function (attachment, opts, callback) {\n    var result;\n    var txn;\n    if (opts.ctx) {\n      txn = opts.ctx;\n    } else {\n      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n    }\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n\n    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n      var data = e.target.result.body;\n      if (opts.encode) {\n        if (blobSupport) {\n          var reader = new FileReader();\n          reader.onloadend = function (e) {\n            result = btoa(this.result);\n            utils.call(callback, null, result);\n          };\n          reader.readAsBinaryString(data);\n        } else {\n          result = data;\n          utils.call(callback, null, result);\n        }\n      } else {\n        if (blobSupport) {\n          result = data;\n        } else {\n          data = fixBinary(atob(data));\n          result = utils.createBlob([data], {type: type});\n        }\n        utils.call(callback, null, result);\n      }\n    };\n  };\n\n  api._allDocs = function idb_allDocs(opts, callback) {\n    var start = 'startkey' in opts ? opts.startkey : false;\n    var end = 'endkey' in opts ? opts.endkey : false;\n\n    var descending = 'descending' in opts ? opts.descending : false;\n    descending = descending ? 'prev' : null;\n\n    var keyRange = start && end ? window.IDBKeyRange.bound(start, end)\n      : start ? window.IDBKeyRange.lowerBound(start)\n      : end ? window.IDBKeyRange.upperBound(end) : null;\n\n    var transaction = idb.transaction([DOC_STORE, BY_SEQ_STORE], 'readonly');\n    transaction.oncomplete = function () {\n      if ('keys' in opts) {\n        opts.keys.forEach(function (key) {\n          if (key in resultsMap) {\n            results.push(resultsMap[key]);\n          } else {\n            results.push({\"key\": key, \"error\": \"not_found\"});\n          }\n        });\n        if (opts.descending) {\n          results.reverse();\n        }\n      }\n      utils.call(callback, null, {\n        total_rows: results.length,\n        offset: opts.skip,\n        rows: ('limit' in opts) ? results.slice(opts.skip, opts.limit + opts.skip) :\n          (opts.skip > 0) ? results.slice(opts.skip) : results\n      });\n    };\n\n    var oStore = transaction.objectStore(DOC_STORE);\n    var oCursor = descending ? oStore.openCursor(keyRange, descending)\n      : oStore.openCursor(keyRange);\n    var results = [];\n    var resultsMap = {};\n    oCursor.onsuccess = function (e) {\n      if (!e.target.result) {\n        return;\n      }\n      var cursor = e.target.result;\n      var metadata = cursor.value;\n      // If opts.keys is set we want to filter here only those docs with\n      // key in opts.keys. With no performance tests it is difficult to\n      // guess if iteration with filter is faster than many single requests\n      function allDocsInner(metadata, data) {\n        if (utils.isLocalId(metadata.id)) {\n          return cursor['continue']();\n        }\n        var doc = {\n          id: metadata.id,\n          key: metadata.id,\n          value: {\n            rev: merge.winningRev(metadata)\n          }\n        };\n        if (opts.include_docs) {\n          doc.doc = data;\n          doc.doc._rev = merge.winningRev(metadata);\n          if (doc.doc._doc_id_rev) {\n            delete(doc.doc._doc_id_rev);\n          }\n          if (opts.conflicts) {\n            doc.doc._conflicts = merge.collectConflicts(metadata);\n          }\n          for (var att in doc.doc._attachments) {\n            doc.doc._attachments[att].stub = true;\n          }\n        }\n        if ('keys' in opts) {\n          if (opts.keys.indexOf(metadata.id) > -1) {\n            if (utils.isDeleted(metadata)) {\n              doc.value.deleted = true;\n              doc.doc = null;\n            }\n            resultsMap[doc.id] = doc;\n          }\n        } else {\n          if (!utils.isDeleted(metadata)) {\n            results.push(doc);\n          }\n        }\n        cursor['continue']();\n      }\n\n      if (!opts.include_docs) {\n        allDocsInner(metadata);\n      } else {\n        var index = transaction.objectStore(BY_SEQ_STORE).index('_doc_id_rev');\n        var mainRev = merge.winningRev(metadata);\n        var key = metadata.id + \"::\" + mainRev;\n        index.get(key).onsuccess = function (event) {\n          allDocsInner(cursor.value, event.target.result);\n        };\n      }\n    };\n  };\n\n  api._info = function idb_info(callback) {\n    var count = 0;\n    var update_seq = 0;\n    var txn = idb.transaction([DOC_STORE, META_STORE], 'readonly');\n\n    function fetchUpdateSeq(e) {\n      update_seq = e.target.result && e.target.result.updateSeq || 0;\n    }\n\n    function countDocs(e) {\n      var cursor = e.target.result;\n      if (!cursor) {\n        txn.objectStore(META_STORE).get(META_STORE).onsuccess = fetchUpdateSeq;\n        return;\n      }\n      if (cursor.value.deleted !== true) {\n        count++;\n      }\n      cursor['continue']();\n    }\n\n    txn.oncomplete = function () {\n      callback(null, {\n        db_name: name,\n        doc_count: count,\n        update_seq: update_seq\n      });\n    };\n\n    txn.objectStore(DOC_STORE).openCursor().onsuccess = countDocs;\n  };\n\n  api._changes = function idb_changes(opts) {\n    //console.log(name + ': Start Changes Feed: continuous=' + opts.continuous);\n\n    if (opts.continuous) {\n      var id = name + ':' + utils.uuid();\n      opts.cancelled = false;\n      IdbPouch.Changes.addListener(name, id, api, opts);\n      IdbPouch.Changes.notify(name);\n      return {\n        cancel: function () {\n          //console.log(name + ': Cancel Changes Feed');\n          opts.cancelled = true;\n          IdbPouch.Changes.removeListener(name, id);\n        }\n      };\n    }\n\n    var descending = opts.descending ? 'prev' : null;\n    var last_seq = 0;\n\n    // Ignore the `since` parameter when `descending` is true\n    opts.since = opts.since && !descending ? opts.since : 0;\n\n    var results = [], resultIndices = {}, dedupResults = [];\n    var txn;\n\n    function fetchChanges() {\n      txn = idb.transaction([DOC_STORE, BY_SEQ_STORE]);\n      txn.oncomplete = onTxnComplete;\n\n      var req;\n\n      if (descending) {\n        req = txn.objectStore(BY_SEQ_STORE)\n            .openCursor(window.IDBKeyRange.lowerBound(opts.since, true), descending);\n      } else {\n        req = txn.objectStore(BY_SEQ_STORE)\n            .openCursor(window.IDBKeyRange.lowerBound(opts.since, true));\n      }\n\n      req.onsuccess = onsuccess;\n      req.onerror = onerror;\n    }\n\n    fetchChanges();\n\n    function onsuccess(event) {\n      if (!event.target.result) {\n        // Filter out null results casued by deduping\n        for (var i = 0, l = results.length; i < l; i++) {\n          var result = results[i];\n          if (result) {\n            dedupResults.push(result);\n          }\n        }\n        return false;\n      }\n\n      var cursor = event.target.result;\n\n      // Try to pre-emptively dedup to save us a bunch of idb calls\n      var changeId = cursor.value._id;\n      var changeIdIndex = resultIndices[changeId];\n      if (changeIdIndex !== undefined) {\n        results[changeIdIndex].seq = cursor.key;\n        // update so it has the later sequence number\n        results.push(results[changeIdIndex]);\n        results[changeIdIndex] = null;\n        resultIndices[changeId] = results.length - 1;\n        return cursor['continue']();\n      }\n\n      var index = txn.objectStore(DOC_STORE);\n      index.get(cursor.value._id).onsuccess = function (event) {\n        var metadata = event.target.result;\n        if (utils.isLocalId(metadata.id)) {\n          return cursor['continue']();\n        }\n\n        if (last_seq < metadata.seq) {\n          last_seq = metadata.seq;\n        }\n\n        var mainRev = merge.winningRev(metadata);\n        var key = metadata.id + \"::\" + mainRev;\n        var index = txn.objectStore(BY_SEQ_STORE).index('_doc_id_rev');\n        index.get(key).onsuccess = function (docevent) {\n          var doc = docevent.target.result;\n          delete doc['_doc_id_rev'];\n\n          doc._rev = mainRev;\n          var change = opts.processChange(doc, metadata, opts);\n          change.seq = cursor.key;\n\n          // Dedupe the changes feed\n          var changeId = change.id, changeIdIndex = resultIndices[changeId];\n          if (changeIdIndex !== undefined) {\n            results[changeIdIndex] = null;\n          }\n          results.push(change);\n          resultIndices[changeId] = results.length - 1;\n          cursor['continue']();\n        };\n      };\n    }\n\n    function onTxnComplete() {\n      utils.processChanges(opts, dedupResults, last_seq);\n    }\n\n    function onerror(error) {\n      // TODO: shouldn't we pass some params here?\n      utils.call(opts.complete);\n    }\n  };\n\n  api._close = function (callback) {\n    if (idb === null) {\n      return utils.call(callback, errors.NOT_OPEN);\n    }\n\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n    // \"Returns immediately and closes the connection in a separate thread...\"\n    idb.close();\n    utils.call(callback, null);\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    var txn = idb.transaction([DOC_STORE], 'readonly');\n    var req = txn.objectStore(DOC_STORE).get(docId);\n    req.onsuccess = function (event) {\n      var doc = event.target.result;\n      if (!doc) {\n        utils.call(callback, errors.MISSING_DOC);\n      } else {\n        utils.call(callback, null, doc.rev_tree);\n      }\n    };\n  };\n\n  // This function removes revisions of document docId\n  // which are listed in revs and sets this document\n  // revision to to rev_tree\n  api._doCompaction = function (docId, rev_tree, revs, callback) {\n    var txn = idb.transaction([DOC_STORE, BY_SEQ_STORE], 'readwrite');\n\n    var index = txn.objectStore(DOC_STORE);\n    index.get(docId).onsuccess = function (event) {\n      var metadata = event.target.result;\n      metadata.rev_tree = rev_tree;\n\n      var count = revs.length;\n      revs.forEach(function (rev) {\n        var index = txn.objectStore(BY_SEQ_STORE).index('_doc_id_rev');\n        var key = docId + \"::\" + rev;\n        index.getKey(key).onsuccess = function (e) {\n          var seq = e.target.result;\n          if (!seq) {\n            return;\n          }\n          var req = txn.objectStore(BY_SEQ_STORE)['delete'](seq);\n\n          count--;\n          if (!count) {\n            txn.objectStore(DOC_STORE).put(metadata);\n          }\n        };\n      });\n    };\n    txn.oncomplete = function () {\n      utils.call(callback);\n    };\n  };\n\n  return api;\n}\n\nIdbPouch.valid = function idb_valid() {\n  return typeof window !== 'undefined' && !!window.indexedDB;\n};\n\nIdbPouch.destroy = function idb_destroy(name, opts, callback) {\n  if (!('openReqList' in IdbPouch)) {\n    IdbPouch.openReqList = {};\n  }\n  IdbPouch.Changes.clearListeners(name);\n\n  //Close open request for \"name\" database to fix ie delay.\n  if (IdbPouch.openReqList[name] && IdbPouch.openReqList[name].result) {\n    IdbPouch.openReqList[name].result.close();\n  }\n  var req = window.indexedDB.deleteDatabase(name);\n\n  req.onsuccess = function () {\n    //Remove open request from the list.\n    if (IdbPouch.openReqList[name]) {\n      IdbPouch.openReqList[name] = null;\n    }\n    utils.call(callback, null);\n  };\n\n  req.onerror = idbError(callback);\n};\n\nIdbPouch.Changes = new utils.Changes();\n\nmodule.exports = IdbPouch;\n\n},{\"../deps/errors\":8,\"../merge\":13,\"../utils\":16}],4:[function(require,module,exports){\n'use strict';\n\nvar utils = require('../utils');\nvar merge = require('../merge');\nvar errors = require('../deps/errors');\nfunction quote(str) {\n  return \"'\" + str + \"'\";\n}\n\nfunction openDB() {\n  if (typeof window !== 'undefined') {\n    if (window.navigator && window.navigator.sqlitePlugin && window.navigator.sqlitePlugin.openDatabase) {\n      return navigator.sqlitePlugin.openDatabase.apply(navigator.sqlitePlugin, arguments);\n    } else if (window.sqlitePlugin && window.sqlitePlugin.openDatabase) {\n      return window.sqlitePlugin.openDatabase.apply(window.sqlitePlugin, arguments);\n    } else {\n      return window.openDatabase.apply(window, arguments);\n    }\n  }\n}\n\nvar POUCH_VERSION = 1;\nvar POUCH_SIZE = 5 * 1024 * 1024;\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\nvar DOC_STORE = quote('document-store');\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE = quote('by-sequence');\n// Where we store attachments\nvar ATTACH_STORE = quote('attach-store');\nvar META_STORE = quote('metadata-store');\n\nfunction unknownError(callback) {\n  return function (event) {\n    utils.call(callback, {\n      status: 500,\n      error: event.type,\n      reason: event.target\n    });\n  };\n}\nfunction idbError(callback) {\n  return function (event) {\n    utils.call(callback, errors.error(errors.WSQ_ERROR, event.target, event.type));\n  };\n}\nfunction webSqlPouch(opts, callback) {\n\n  var api = {};\n  var instanceId = null;\n  var name = opts.name;\n\n  var db = openDB(name, POUCH_VERSION, name, POUCH_SIZE);\n  if (!db) {\n    return utils.call(callback, errors.UNKNOWN_ERROR);\n  }\n\n  function dbCreated() {\n    callback(null, api);\n  }\n\n  function setup() {\n    db.transaction(function (tx) {\n      var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE +\n        ' (update_seq, dbid)';\n      var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE +\n        ' (digest, json, body BLOB)';\n      var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE +\n        ' (id unique, seq, json, winningseq)';\n      var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE +\n        ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, doc_id_rev UNIQUE, json)';\n\n      tx.executeSql(attach);\n      tx.executeSql(doc);\n      tx.executeSql(seq);\n      tx.executeSql(meta);\n\n      var updateseq = 'SELECT update_seq FROM ' + META_STORE;\n      tx.executeSql(updateseq, [], function (tx, result) {\n        if (!result.rows.length) {\n          var initSeq = 'INSERT INTO ' + META_STORE + ' (update_seq) VALUES (?)';\n          tx.executeSql(initSeq, [0]);\n          return;\n        }\n      });\n\n      var dbid = 'SELECT dbid FROM ' + META_STORE + ' WHERE dbid IS NOT NULL';\n      tx.executeSql(dbid, [], function (tx, result) {\n        if (!result.rows.length) {\n          var initDb = 'UPDATE ' + META_STORE + ' SET dbid=?';\n          instanceId = utils.uuid();\n          tx.executeSql(initDb, [instanceId]);\n          return;\n        }\n        instanceId = result.rows.item(0).dbid;\n      });\n    }, unknownError(callback), dbCreated);\n  }\n  if (utils.isCordova() && typeof window !== 'undefined') {\n    //to wait until custom api is made in pouch.adapters before doing setup\n    window.addEventListener(name + '_pouch', function cordova_init() {\n      window.removeEventListener(name + '_pouch', cordova_init, false);\n      setup();\n    }, false);\n  } else {\n    setup();\n  }\n\n\n  api.type = function () {\n    return 'websql';\n  };\n\n  api.id = function () {\n    return instanceId;\n  };\n\n  api._info = function (callback) {\n    db.transaction(function (tx) {\n      var sql = 'SELECT COUNT(id) AS count FROM ' + DOC_STORE;\n      tx.executeSql(sql, [], function (tx, result) {\n        var doc_count = result.rows.item(0).count;\n        var updateseq = 'SELECT update_seq FROM ' + META_STORE;\n        tx.executeSql(updateseq, [], function (tx, result) {\n          var update_seq = result.rows.item(0).update_seq;\n          callback(null, {\n            db_name: name,\n            doc_count: doc_count,\n            update_seq: update_seq\n          });\n        });\n      });\n    });\n  };\n\n  api._bulkDocs = function (req, opts, callback) {\n\n    var newEdits = opts.new_edits;\n    var userDocs = req.docs;\n    var docsWritten = 0;\n\n    // Parse the docs, give them a sequence number for the result\n    var docInfos = userDocs.map(function (doc, i) {\n      var newDoc = utils.parseDoc(doc, newEdits);\n      newDoc._bulk_seq = i;\n      return newDoc;\n    });\n\n    var docInfoErrors = docInfos.filter(function (docInfo) {\n      return docInfo.error;\n    });\n    if (docInfoErrors.length) {\n      return utils.call(callback, docInfoErrors[0]);\n    }\n\n    var tx;\n    var results = [];\n    var fetchedDocs = {};\n\n    function sortByBulkSeq(a, b) {\n      return a._bulk_seq - b._bulk_seq;\n    }\n\n    function complete(event) {\n      var aresults = [];\n      results.sort(sortByBulkSeq);\n      results.forEach(function (result) {\n        delete result._bulk_seq;\n        if (result.error) {\n          aresults.push(result);\n          return;\n        }\n        var metadata = result.metadata;\n        var rev = merge.winningRev(metadata);\n\n        aresults.push({\n          ok: true,\n          id: metadata.id,\n          rev: rev\n        });\n\n        if (utils.isLocalId(metadata.id)) {\n          return;\n        }\n\n        docsWritten++;\n\n        webSqlPouch.Changes.notify(name);\n        webSqlPouch.Changes.notifyLocalWindows(name);\n      });\n\n      var updateseq = 'SELECT update_seq FROM ' + META_STORE;\n      tx.executeSql(updateseq, [], function (tx, result) {\n        var update_seq = result.rows.item(0).update_seq + docsWritten;\n        var sql = 'UPDATE ' + META_STORE + ' SET update_seq=?';\n        tx.executeSql(sql, [update_seq], function () {\n          utils.call(callback, null, aresults);\n        });\n      });\n    }\n\n    function preprocessAttachment(att, finish) {\n      if (att.stub) {\n        return finish();\n      }\n      if (typeof att.data === 'string') {\n        try {\n          att.data = atob(att.data);\n        } catch (e) {\n          var err = errors.error(errors.BAD_ARG,\n                                \"Attachments need to be base64 encoded\");\n          return utils.call(callback, err);\n        }\n        att.digest = 'md5-' + utils.Crypto.MD5(att.data);\n        return finish();\n      }\n      var reader = new FileReader();\n      reader.onloadend = function (e) {\n        att.data = this.result;\n        att.digest = 'md5-' + utils.Crypto.MD5(this.result);\n        finish();\n      };\n      reader.readAsBinaryString(att.data);\n    }\n\n    function preprocessAttachments(callback) {\n      if (!docInfos.length) {\n        return callback();\n      }\n\n      var docv = 0;\n      var recv = 0;\n\n      docInfos.forEach(function (docInfo) {\n        var attachments = docInfo.data && docInfo.data._attachments ?\n          Object.keys(docInfo.data._attachments) : [];\n\n        if (!attachments.length) {\n          return done();\n        }\n\n        function processedAttachment() {\n          recv++;\n          if (recv === attachments.length) {\n            done();\n          }\n        }\n\n        for (var key in docInfo.data._attachments) {\n          preprocessAttachment(docInfo.data._attachments[key], processedAttachment);\n        }\n      });\n\n      function done() {\n        docv++;\n        if (docInfos.length === docv) {\n          callback();\n        }\n      }\n    }\n\n    function writeDoc(docInfo, callback, isUpdate) {\n\n      function finish() {\n        var data = docInfo.data;\n        var sql = 'INSERT INTO ' + BY_SEQ_STORE + ' (doc_id_rev, json) VALUES (?, ?);';\n        tx.executeSql(sql, [data._id + \"::\" + data._rev,\n                            JSON.stringify(data)], dataWritten);\n      }\n\n      function collectResults(attachmentErr) {\n        if (!err) {\n          if (attachmentErr) {\n            err = attachmentErr;\n            utils.call(callback, err);\n          } else if (recv === attachments.length) {\n            finish();\n          }\n        }\n      }\n\n      var err = null;\n      var recv = 0;\n\n      docInfo.data._id = docInfo.metadata.id;\n      docInfo.data._rev = docInfo.metadata.rev;\n\n      if (utils.isDeleted(docInfo.metadata, docInfo.metadata.rev)) {\n        docInfo.data._deleted = true;\n      }\n\n      var attachments = docInfo.data._attachments ?\n        Object.keys(docInfo.data._attachments) : [];\n\n      function attachmentSaved(err) {\n        recv++;\n        collectResults(err);\n      }\n\n      for (var key in docInfo.data._attachments) {\n        if (!docInfo.data._attachments[key].stub) {\n          var data = docInfo.data._attachments[key].data;\n          delete docInfo.data._attachments[key].data;\n          var digest = docInfo.data._attachments[key].digest;\n          saveAttachment(docInfo, digest, data, attachmentSaved);\n        } else {\n          recv++;\n          collectResults();\n        }\n      }\n\n      if (!attachments.length) {\n        finish();\n      }\n\n      function dataWritten(tx, result) {\n        var seq = docInfo.metadata.seq = result.insertId;\n        delete docInfo.metadata.rev;\n\n        var mainRev = merge.winningRev(docInfo.metadata);\n\n        var sql = isUpdate ?\n          'UPDATE ' + DOC_STORE + ' SET seq=?, json=?, winningseq=(SELECT seq FROM ' +\n          BY_SEQ_STORE + ' WHERE doc_id_rev=?) WHERE id=?' :\n          'INSERT INTO ' + DOC_STORE + ' (id, seq, winningseq, json) VALUES (?, ?, ?, ?);';\n        var metadataStr = JSON.stringify(docInfo.metadata);\n        var key = docInfo.metadata.id + \"::\" + mainRev;\n        var params = isUpdate ?\n          [seq, metadataStr, key, docInfo.metadata.id] :\n          [docInfo.metadata.id, seq, seq, metadataStr];\n        tx.executeSql(sql, params, function (tx, result) {\n          results.push(docInfo);\n          utils.call(callback, null);\n        });\n      }\n    }\n\n    function updateDoc(oldDoc, docInfo) {\n      var merged = merge.merge(oldDoc.rev_tree, docInfo.metadata.rev_tree[0], 1000);\n      var inConflict = (utils.isDeleted(oldDoc) &&\n                        utils.isDeleted(docInfo.metadata)) ||\n        (!utils.isDeleted(oldDoc) &&\n         newEdits && merged.conflicts !== 'new_leaf');\n\n      if (inConflict) {\n        results.push(makeErr(errors.REV_CONFLICT, docInfo._bulk_seq));\n        return processDocs();\n      }\n\n      docInfo.metadata.rev_tree = merged.tree;\n      writeDoc(docInfo, processDocs, true);\n    }\n\n    function insertDoc(docInfo) {\n      // Cant insert new deleted documents\n      if ('was_delete' in opts && utils.isDeleted(docInfo.metadata)) {\n        results.push(errors.MISSING_DOC);\n        return processDocs();\n      }\n      writeDoc(docInfo, processDocs, false);\n    }\n\n    function processDocs() {\n      if (!docInfos.length) {\n        return complete();\n      }\n      var currentDoc = docInfos.shift();\n      var id = currentDoc.metadata.id;\n      if (id in fetchedDocs) {\n        updateDoc(fetchedDocs[id], currentDoc);\n      } else {\n        // if we have newEdits=false then we can update the same\n        // document twice in a single bulk docs call\n        fetchedDocs[id] = currentDoc.metadata;\n        insertDoc(currentDoc);\n      }\n    }\n\n    // Insert sequence number into the error so we can sort later\n    function makeErr(err, seq) {\n      err._bulk_seq = seq;\n      return err;\n    }\n\n    function saveAttachment(docInfo, digest, data, callback) {\n      var ref = [docInfo.metadata.id, docInfo.metadata.rev].join('@');\n      var newAtt = {digest: digest};\n      var sql = 'SELECT digest, json FROM ' + ATTACH_STORE + ' WHERE digest=?';\n      tx.executeSql(sql, [digest], function (tx, result) {\n        if (!result.rows.length) {\n          newAtt.refs = {};\n          newAtt.refs[ref] = true;\n          sql = 'INSERT INTO ' + ATTACH_STORE + '(digest, json, body) VALUES (?, ?, ?)';\n          tx.executeSql(sql, [digest, JSON.stringify(newAtt), data], function () {\n            utils.call(callback, null);\n          });\n        } else {\n          newAtt.refs = JSON.parse(result.rows.item(0).json).refs;\n          sql = 'UPDATE ' + ATTACH_STORE + ' SET json=?, body=? WHERE digest=?';\n          tx.executeSql(sql, [JSON.stringify(newAtt), data, digest], function () {\n            utils.call(callback, null);\n          });\n        }\n      });\n    }\n\n    function metadataFetched(tx, results) {\n      for (var j = 0; j < results.rows.length; j++) {\n        var row = results.rows.item(j);\n        fetchedDocs[row.id] = JSON.parse(row.json);\n      }\n      processDocs();\n    }\n\n    preprocessAttachments(function () {\n      db.transaction(function (txn) {\n        tx = txn;\n        var ids = '(' + docInfos.map(function (d) {\n          return quote(d.metadata.id);\n        }).join(',') + ')';\n        var sql = 'SELECT * FROM ' + DOC_STORE + ' WHERE id IN ' + ids;\n        tx.executeSql(sql, [], metadataFetched);\n      }, unknownError(callback));\n    });\n  };\n\n  api._get = function (id, opts, callback) {\n    var doc;\n    var metadata;\n    var err;\n    if (!opts.ctx) {\n      db.transaction(function (txn) {\n        opts.ctx = txn;\n        api._get(id, opts, callback);\n      });\n      return;\n    }\n    var tx = opts.ctx;\n\n    function finish() {\n      utils.call(callback, err, {doc: doc, metadata: metadata, ctx: tx});\n    }\n\n    var sql = 'SELECT * FROM ' + DOC_STORE + ' WHERE id=?';\n    tx.executeSql(sql, [id], function (a, results) {\n      if (!results.rows.length) {\n        err = errors.MISSING_DOC;\n        return finish();\n      }\n      metadata = JSON.parse(results.rows.item(0).json);\n      if (utils.isDeleted(metadata) && !opts.rev) {\n        err = errors.error(errors.MISSING_DOC, \"deleted\");\n        return finish();\n      }\n\n      var rev = merge.winningRev(metadata);\n      var key = opts.rev ? opts.rev : rev;\n      key = metadata.id + '::' + key;\n      var sql = 'SELECT * FROM ' + BY_SEQ_STORE + ' WHERE doc_id_rev=?';\n      tx.executeSql(sql, [key], function (tx, results) {\n        if (!results.rows.length) {\n          err = errors.MISSING_DOC;\n          return finish();\n        }\n        doc = JSON.parse(results.rows.item(0).json);\n\n        finish();\n      });\n    });\n  };\n\n  function makeRevs(arr) {\n    return arr.map(function (x) { return {rev: x.rev}; });\n  }\n\n  api._allDocs = function (opts, callback) {\n    var results = [];\n    var resultsMap = {};\n    var start = 'startkey' in opts ? opts.startkey : false;\n    var end = 'endkey' in opts ? opts.endkey : false;\n    var descending = 'descending' in opts ? opts.descending : false;\n    var sql = 'SELECT ' + DOC_STORE + '.id, ' + BY_SEQ_STORE + '.seq, ' +\n      BY_SEQ_STORE + '.json AS data, ' + DOC_STORE + '.json AS metadata FROM ' +\n      BY_SEQ_STORE + ' JOIN ' + DOC_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' +\n      DOC_STORE + '.winningseq';\n\n    var sqlArgs = [];\n    if ('keys' in opts) {\n      sql += ' WHERE ' + DOC_STORE + '.id IN (' + opts.keys.map(function () {\n        return '?';\n      }).join(',') + ')';\n      sqlArgs = sqlArgs.concat(opts.keys);\n    } else {\n      if (start) {\n        sql += ' WHERE ' + DOC_STORE + '.id >= ?';\n        sqlArgs.push(start);\n      }\n      if (end) {\n        sql += (start ? ' AND ' : ' WHERE ') + DOC_STORE + '.id <= ?';\n        sqlArgs.push(end);\n      }\n      sql += ' ORDER BY ' + DOC_STORE + '.id ' + (descending ? 'DESC' : 'ASC');\n    }\n\n    db.transaction(function (tx) {\n      tx.executeSql(sql, sqlArgs, function (tx, result) {\n        for (var i = 0, l = result.rows.length; i < l; i++) {\n          var doc = result.rows.item(i);\n          var metadata = JSON.parse(doc.metadata);\n          var data = JSON.parse(doc.data);\n          if (!(utils.isLocalId(metadata.id))) {\n            doc = {\n              id: metadata.id,\n              key: metadata.id,\n              value: {rev: merge.winningRev(metadata)}\n            };\n            if (opts.include_docs) {\n              doc.doc = data;\n              doc.doc._rev = merge.winningRev(metadata);\n              if (opts.conflicts) {\n                doc.doc._conflicts = merge.collectConflicts(metadata);\n              }\n              for (var att in doc.doc._attachments) {\n                doc.doc._attachments[att].stub = true;\n              }\n            }\n            if ('keys' in opts) {\n              if (opts.keys.indexOf(metadata.id) > -1) {\n                if (utils.isDeleted(metadata)) {\n                  doc.value.deleted = true;\n                  doc.doc = null;\n                }\n                resultsMap[doc.id] = doc;\n              }\n            } else {\n              if (!utils.isDeleted(metadata)) {\n                results.push(doc);\n              }\n            }\n          }\n        }\n      });\n    }, unknownError(callback), function () {\n      if ('keys' in opts) {\n        opts.keys.forEach(function (key) {\n          if (key in resultsMap) {\n            results.push(resultsMap[key]);\n          } else {\n            results.push({\"key\": key, \"error\": \"not_found\"});\n          }\n        });\n        if (opts.descending) {\n          results.reverse();\n        }\n      }\n      utils.call(callback, null, {\n        total_rows: results.length,\n        offset: opts.skip,\n        rows: ('limit' in opts) ? results.slice(opts.skip, opts.limit + opts.skip) :\n          (opts.skip > 0) ? results.slice(opts.skip) : results\n      });\n    });\n  };\n\n  api._changes = function idb_changes(opts) {\n\n\n    //console.log(name + ': Start Changes Feed: continuous=' + opts.continuous);\n\n\n    if (opts.continuous) {\n      var id = name + ':' + utils.uuid();\n      opts.cancelled = false;\n      webSqlPouch.Changes.addListener(name, id, api, opts);\n      webSqlPouch.Changes.notify(name);\n      return {\n        cancel: function () {\n          //console.log(name + ': Cancel Changes Feed');\n          opts.cancelled = true;\n          webSqlPouch.Changes.removeListener(name, id);\n        }\n      };\n    }\n\n    var descending = opts.descending;\n\n    // Ignore the `since` parameter when `descending` is true\n    opts.since = opts.since && !descending ? opts.since : 0;\n\n    var results = [];\n    var txn;\n\n    function fetchChanges() {\n      var sql = 'SELECT ' + DOC_STORE + '.id, ' + BY_SEQ_STORE + '.seq, ' +\n        BY_SEQ_STORE + '.json AS data, ' + DOC_STORE + '.json AS metadata FROM ' +\n        BY_SEQ_STORE + ' JOIN ' + DOC_STORE + ' ON ' + BY_SEQ_STORE + '.seq = ' +\n        DOC_STORE + '.winningseq WHERE ' + DOC_STORE + '.seq > ' + opts.since +\n        ' ORDER BY ' + DOC_STORE + '.seq ' + (descending ? 'DESC' : 'ASC');\n\n      db.transaction(function (tx) {\n        tx.executeSql(sql, [], function (tx, result) {\n          var last_seq = 0;\n          for (var i = 0, l = result.rows.length; i < l; i++) {\n            var res = result.rows.item(i);\n            var metadata = JSON.parse(res.metadata);\n            if (!utils.isLocalId(metadata.id)) {\n              if (last_seq < res.seq) {\n                last_seq = res.seq;\n              }\n              var doc = JSON.parse(res.data);\n              var change = opts.processChange(doc, metadata, opts);\n              change.seq = res.seq;\n\n              results.push(change);\n            }\n          }\n          utils.processChanges(opts, results, last_seq);\n        });\n      });\n    }\n\n    fetchChanges();\n  };\n\n  api._close = function (callback) {\n    //WebSQL databases do not need to be closed\n    utils.call(callback, null);\n  };\n\n  api._getAttachment = function (attachment, opts, callback) {\n    var res;\n    var tx = opts.ctx;\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n    var sql = 'SELECT body FROM ' + ATTACH_STORE + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      var data = result.rows.item(0).body;\n      if (opts.encode) {\n        res = btoa(data);\n      } else {\n        res = utils.createBlob([data], {type: type});\n      }\n      utils.call(callback, null, res);\n    });\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    db.transaction(function (tx) {\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        if (!result.rows.length) {\n          utils.call(callback, errors.MISSING_DOC);\n        } else {\n          var data = JSON.parse(result.rows.item(0).metadata);\n          utils.call(callback, null, data.rev_tree);\n        }\n      });\n    });\n  };\n\n  api._doCompaction = function (docId, rev_tree, revs, callback) {\n    db.transaction(function (tx) {\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        if (!result.rows.length) {\n          return utils.call(callback);\n        }\n        var metadata = JSON.parse(result.rows.item(0).metadata);\n        metadata.rev_tree = rev_tree;\n\n        var sql = 'DELETE FROM ' + BY_SEQ_STORE + ' WHERE doc_id_rev IN (' +\n          revs.map(function (rev) {return quote(docId + '::' + rev); }).join(',') + ')';\n\n        tx.executeSql(sql, [], function (tx, result) {\n          var sql = 'UPDATE ' + DOC_STORE + ' SET json = ? WHERE id = ?';\n\n          tx.executeSql(sql, [JSON.stringify(metadata), docId], function (tx, result) {\n            callback();\n          });\n        });\n      });\n    });\n  };\n\n  return api;\n}\n\nwebSqlPouch.valid = function () {\n  if (typeof window !== 'undefined') {\n    if (window.navigator && window.navigator.sqlitePlugin && window.navigator.sqlitePlugin.openDatabase) {\n      return true;\n    } else if (window.sqlitePlugin && window.sqlitePlugin.openDatabase) {\n      return true;\n    } else if (window.openDatabase) {\n      return true;\n    }\n  }\n  return false;\n};\n\nwebSqlPouch.destroy = function (name, opts, callback) {\n  var db = openDB(name, POUCH_VERSION, name, POUCH_SIZE);\n  db.transaction(function (tx) {\n    tx.executeSql('DROP TABLE IF EXISTS ' + DOC_STORE, []);\n    tx.executeSql('DROP TABLE IF EXISTS ' + BY_SEQ_STORE, []);\n    tx.executeSql('DROP TABLE IF EXISTS ' + ATTACH_STORE, []);\n    tx.executeSql('DROP TABLE IF EXISTS ' + META_STORE, []);\n  }, unknownError(callback), function () {\n    utils.call(callback, null);\n  });\n};\n\nwebSqlPouch.Changes = new utils.Changes();\n\nmodule.exports = webSqlPouch;\n\n},{\"../deps/errors\":8,\"../merge\":13,\"../utils\":16}],5:[function(require,module,exports){\n\"use strict\";\n\nvar Adapter = require('./adapter')(PouchDB);\nfunction PouchDB(name, opts, callback) {\n\n  if (!(this instanceof PouchDB)) {\n    return new PouchDB(name, opts, callback);\n  }\n\n  if (typeof opts === 'function' || typeof opts === 'undefined') {\n    callback = opts;\n    opts = {};\n  }\n\n  if (typeof name === 'object') {\n    opts = name;\n    name = undefined;\n  }\n\n  if (typeof callback === 'undefined') {\n    callback = function () {};\n  }\n\n  var originalName = opts.name || name;\n  var backend = PouchDB.parseAdapter(originalName);\n  \n  opts.originalName = originalName;\n  opts.name = backend.name;\n  opts.adapter = opts.adapter || backend.adapter;\n\n  if (!PouchDB.adapters[opts.adapter]) {\n    throw 'Adapter is missing';\n  }\n\n  if (!PouchDB.adapters[opts.adapter].valid()) {\n    throw 'Invalid Adapter';\n  }\n\n  var adapter = new Adapter(opts, function (err, db) {\n    if (err) {\n      if (callback) {\n        callback(err);\n      }\n      return;\n    }\n\n    for (var plugin in PouchDB.plugins) {\n      // In future these will likely need to be async to allow the plugin\n      // to initialise\n      var pluginObj = PouchDB.plugins[plugin](db);\n      for (var api in pluginObj) {\n        // We let things like the http adapter use its own implementation\n        // as it shares a lot of code\n        if (!(api in db)) {\n          db[api] = pluginObj[api];\n        }\n      }\n    }\n    db.taskqueue.ready(true);\n    db.taskqueue.execute(db);\n    callback(null, db);\n  });\n  for (var j in adapter) {\n    this[j] = adapter[j];\n  }\n  for (var plugin in PouchDB.plugins) {\n    // In future these will likely need to be async to allow the plugin\n    // to initialise\n    var pluginObj = PouchDB.plugins[plugin](this);\n    for (var api in pluginObj) {\n      // We let things like the http adapter use its own implementation\n      // as it shares a lot of code\n      if (!(api in this)) {\n        this[api] = pluginObj[api];\n      }\n    }\n  }\n}\n\nmodule.exports = PouchDB;\n},{\"./adapter\":1}],6:[function(require,module,exports){\nvar process=require(\"__browserify_process\");\"use strict\";\n\nvar request = require('request');\nvar extend = require('./extend.js');\nvar createBlob = require('./blob.js');\nvar errors = require('./errors');\n\nfunction ajax(options, callback) {\n\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  function call(fun) {\n    /* jshint validthis: true */\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (typeof fun === typeof Function) {\n      fun.apply(this, args);\n    }\n  }\n\n  var defaultOptions = {\n    method : \"GET\",\n    headers: {},\n    json: true,\n    processData: true,\n    timeout: 10000\n  };\n\n  options = extend(true, defaultOptions, options);\n\n  function onSuccess(obj, resp, cb) {\n    if (!options.binary && !options.json && options.processData &&\n      typeof obj !== 'string') {\n      obj = JSON.stringify(obj);\n    } else if (!options.binary && options.json && typeof obj === 'string') {\n      try {\n        obj = JSON.parse(obj);\n      } catch (e) {\n        // Probably a malformed JSON from server\n        call(cb, e);\n        return;\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj = obj.map(function (v) {\n        var obj;\n        if (v.ok) {\n          return v;\n        } else if (v.error && v.error === 'conflict') {\n          obj = errors.REV_CONFLICT;\n          obj.id = v.id;\n          return obj;\n        } else if (v.missing) {\n          obj = errors.MISSING_DOC;\n          obj.missing = v.missing;\n          return obj;\n        }\n      });\n    }\n    call(cb, null, obj, resp);\n  }\n\n  function onError(err, cb) {\n    var errParsed, errObj, errType, key;\n    try {\n      errParsed = JSON.parse(err.responseText);\n      //would prefer not to have a try/catch clause\n      for (key in errors) {\n        if (errors[key].name === errParsed.error) {\n          errType = errors[key];\n          break;\n        }\n      }\n      errType = errType || errors.UNKNOWN_ERROR;\n      errObj = errors.error(errType, errParsed.reason);\n    } catch (e) {\n      errObj = errors.error(errors.UNKNOWN_ERROR);\n    }\n    call(cb, errObj);\n  }\n\n  if (process.browser && typeof XMLHttpRequest !== 'undefined') {\n    var timer, timedout = false;\n    var xhr = new XMLHttpRequest();\n\n    xhr.open(options.method, options.url);\n    xhr.withCredentials = true;\n\n    if (options.json) {\n      options.headers.Accept = 'application/json';\n      options.headers['Content-Type'] = options.headers['Content-Type'] ||\n        'application/json';\n      if (options.body && options.processData && typeof options.body !== \"string\") {\n        options.body = JSON.stringify(options.body);\n      }\n    }\n\n    if (options.binary) {\n      xhr.responseType = 'arraybuffer';\n    }\n\n    var createCookie = function (name, value, days) {\n      var expires = \"\";\n      if (days) {\n        var date = new Date();\n        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\n        expires = \"; expires=\" + date.toGMTString();\n      }\n      document.cookie = name + \"=\" + value + expires + \"; path=/\";\n    };\n\n    for (var key in options.headers) {\n      if (key === 'Cookie') {\n        var cookie = options.headers[key].split('=');\n        createCookie(cookie[0], cookie[1], 10);\n      } else {\n        xhr.setRequestHeader(key, options.headers[key]);\n      }\n    }\n\n    if (!(\"body\" in options)) {\n      options.body = null;\n    }\n\n    var abortReq = function () {\n      timedout = true;\n      xhr.abort();\n      call(onError, xhr, callback);\n    };\n\n    xhr.onreadystatechange = function () {\n      if (xhr.readyState !== 4 || timedout) {\n        return;\n      }\n      clearTimeout(timer);\n      if (xhr.status >= 200 && xhr.status < 300) {\n        var data;\n        if (options.binary) {\n          data = createBlob([xhr.response || ''], {\n            type: xhr.getResponseHeader('Content-Type')\n          });\n        } else {\n          data = xhr.responseText;\n        }\n        call(onSuccess, data, xhr, callback);\n      } else {\n        call(onError, xhr, callback);\n      }\n    };\n\n    if (options.timeout > 0) {\n      timer = setTimeout(abortReq, options.timeout);\n      xhr.upload.onprogress = xhr.onprogress = function () {\n        clearTimeout(timer);\n        timer = setTimeout(abortReq, options.timeout);\n      };\n    }\n    xhr.send(options.body);\n    return {abort: abortReq};\n\n  } else {\n\n    if (options.json) {\n      if (!options.binary) {\n        options.headers.Accept = 'application/json';\n      }\n      options.headers['Content-Type'] = options.headers['Content-Type'] ||\n        'application/json';\n    }\n\n    if (options.binary) {\n      options.encoding = null;\n      options.json = false;\n    }\n\n    if (!options.processData) {\n      options.json = false;\n    }\n\n    return request(options, function (err, response, body) {\n      if (err) {\n        err.status = response ? response.statusCode : 400;\n        return call(onError, err, callback);\n      }\n      var error;\n      var content_type = response.headers['content-type'];\n      var data = (body || '');\n\n      // CouchDB doesn't always return the right content-type for JSON data, so\n      // we check for ^{ and }$ (ignoring leading/trailing whitespace)\n      if (!options.binary && (options.json || !options.processData) &&\n          typeof data !== 'object' &&\n          (/json/.test(content_type) ||\n           (/^[\\s]*\\{/.test(data) && /\\}[\\s]*$/.test(data)))) {\n        data = JSON.parse(data);\n      }\n\n      if (response.statusCode >= 200 && response.statusCode < 300) {\n        call(onSuccess, data, response, callback);\n      }\n      else {\n        if (options.binary) {\n          data = JSON.parse(data.toString());\n        }\n        if (data.reason === 'missing') {\n          error = errors.MISSING_DOC;\n        } else if (data.reason === 'no_db_file') {\n          error = errors.error(errors.DB_MISSING, data.reason);\n        } else if (data.error === 'conflict') {\n          error = errors.REV_CONFLICT;\n        } else {\n          error = errors.error(errors.UNKNOWN_ERROR, data.reason, data.error);\n        }\n        error.status = response.statusCode;\n        call(callback, error);\n      }\n    });\n  }\n}\n\nmodule.exports = ajax;\n\n},{\"./blob.js\":7,\"./errors\":8,\"./extend.js\":9,\"__browserify_process\":19,\"request\":18}],7:[function(require,module,exports){\n\"use strict\";\n\n//Abstracts constructing a Blob object, so it also works in older\n//browsers that don't support the native Blob constructor. (i.e.\n//old QtWebKit versions, at least).\nfunction createBlob(parts, properties) {\n  parts = parts || [];\n  properties = properties || {};\n  try {\n    return new Blob(parts, properties);\n  } catch (e) {\n    if (e.name !== \"TypeError\") {\n      throw e;\n    }\n    var BlobBuilder = window.BlobBuilder || window.MSBlobBuilder || window.MozBlobBuilder || window.WebKitBlobBuilder;\n    var builder = new BlobBuilder();\n    for (var i = 0; i < parts.length; i += 1) {\n      builder.append(parts[i]);\n    }\n    return builder.getBlob(properties.type);\n  }\n}\n\nmodule.exports = createBlob;\n\n\n},{}],8:[function(require,module,exports){\n\"use strict\";\n\nfunction PouchError(opts) {\n  this.status = opts.status;\n  this.name = opts.error;\n  this.message = opts.reason;\n  this.error = true;\n}\nPouchError.prototype = new Error();\n\n\nexports.MISSING_BULK_DOCS = new PouchError({\n  status: 400,\n  error: 'bad_request',\n  reason: \"Missing JSON list of 'docs'\"\n});\nexports.MISSING_DOC = new PouchError({ \n  status: 404,\n  error: 'not_found',\n  reason: 'missing'\n});\nexports.REV_CONFLICT = new PouchError({\n  status: 409,\n  error: 'conflict',\n  reason: 'Document update conflict'\n});\nexports.INVALID_ID = new PouchError({\n  status: 400,\n  error: 'invalid_id',\n  reason: '_id field must contain a string'\n});\nexports.MISSING_ID = new PouchError({\n  status: 412,\n  error: 'missing_id',\n  reason: '_id is required for puts'\n});\nexports.RESERVED_ID = new PouchError({\n  status: 400,\n  error: 'bad_request',\n  reason: 'Only reserved document ids may start with underscore.'\n});\nexports.NOT_OPEN = new PouchError({\n  status: 412,\n  error: 'precondition_failed',\n  reason: 'Database not open so cannot close'\n});\nexports.UNKNOWN_ERROR = new PouchError({\n  status: 500,\n  error: 'unknown_error',\n  reason: 'Database encountered an unknown error'\n});\nexports.BAD_ARG = new PouchError({\n  status: 500,\n  error: 'badarg',\n  reason: 'Some query argument is invalid'\n});\nexports.INVALID_REQUEST = new PouchError({\n  status: 400,\n  error: 'invalid_request',\n  reason: 'Request was invalid'\n});\nexports.QUERY_PARSE_ERROR = new PouchError({\n  status: 400,\n  error: 'query_parse_error',\n  reason: 'Some query parameter is invalid'\n});\nexports.DOC_VALIDATION = new PouchError({\n  status: 500,\n  error: 'doc_validation',\n  reason: 'Bad special document member'\n});\nexports.BAD_REQUEST = new PouchError({\n  status: 400,\n  error: 'bad_request',\n  reason: 'Something wrong with the request'\n});\nexports.NOT_AN_OBJECT = new PouchError({\n  status: 400,\n  error: 'bad_request',\n  reason: 'Document must be a JSON object'\n});\nexports.DB_MISSING = new PouchError({\n  status: 404,\n  error: 'not_found',\n  reason: 'Database not found'\n});\nexports.IDB_ERROR = new PouchError({\n  status: 500,\n  error: 'indexed_db_went_bad',\n  reason: 'unknown'\n});\nexports.WSQ_ERROR = new PouchError({\n  status: 500,\n  error: 'web_sql_went_bad',\n  reason: 'unknown'\n});\nexports.LDB_ERROR = new PouchError({\n  status: 500,\n  error: 'levelDB_went_went_bad',\n  reason: 'unknown'\n});\nexports.error = function (error, reason, name) {\n  function CustomPouchError(msg) {\n    this.message = reason;\n    if (name) {\n      this.name = name;\n    }\n  }\n  CustomPouchError.prototype = error;\n  return new CustomPouchError(reason);\n};\n},{}],9:[function(require,module,exports){\n\"use strict\";\n\n// Extends method\n// (taken from http://code.jquery.com/jquery-1.9.0.js)\n// Populate the class2type map\nvar class2type = {};\n\nvar types = [\"Boolean\", \"Number\", \"String\", \"Function\", \"Array\", \"Date\", \"RegExp\", \"Object\", \"Error\"];\nfor (var i = 0; i < types.length; i++) {\n  var typename = types[i];\n  class2type[\"[object \" + typename + \"]\"] = typename.toLowerCase();\n}\n\nvar core_toString = class2type.toString;\nvar core_hasOwn = class2type.hasOwnProperty;\n\nfunction type(obj) {\n  if (obj === null) {\n    return String(obj);\n  }\n  return typeof obj === \"object\" || typeof obj === \"function\" ?\n    class2type[core_toString.call(obj)] || \"object\" :\n    typeof obj;\n}\n\nfunction isWindow(obj) {\n  return obj !== null && obj === obj.window;\n}\n\nfunction isPlainObject(obj) {\n  // Must be an Object.\n  // Because of IE, we also have to check the presence of the constructor property.\n  // Make sure that DOM nodes and window objects don't pass through, as well\n  if (!obj || type(obj) !== \"object\" || obj.nodeType || isWindow(obj)) {\n    return false;\n  }\n\n  try {\n    // Not own constructor property must be Object\n    if (obj.constructor &&\n      !core_hasOwn.call(obj, \"constructor\") &&\n      !core_hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\")) {\n      return false;\n    }\n  } catch ( e ) {\n    // IE8,9 Will throw exceptions on certain host objects #9897\n    return false;\n  }\n\n  // Own properties are enumerated firstly, so to speed up,\n  // if last one is own, then all properties are own.\n  var key;\n  for (key in obj) {}\n\n  return key === undefined || core_hasOwn.call(obj, key);\n}\n\n\nfunction isFunction(obj) {\n  return type(obj) === \"function\";\n}\n\nvar isArray = Array.isArray || function (obj) {\n  return type(obj) === \"array\";\n};\n\nfunction extend() {\n  var options, name, src, copy, copyIsArray, clone,\n    target = arguments[0] || {},\n    i = 1,\n    length = arguments.length,\n    deep = false;\n\n  // Handle a deep copy situation\n  if (typeof target === \"boolean\") {\n    deep = target;\n    target = arguments[1] || {};\n    // skip the boolean and the target\n    i = 2;\n  }\n\n  // Handle case when target is a string or something (possible in deep copy)\n  if (typeof target !== \"object\" && !isFunction(target)) {\n    target = {};\n  }\n\n  // extend jQuery itself if only one argument is passed\n  if (length === i) {\n    /* jshint validthis: true */\n    target = this;\n    --i;\n  }\n\n  for (; i < length; i++) {\n    // Only deal with non-null/undefined values\n    if ((options = arguments[i]) != null) {\n      // Extend the base object\n      for (name in options) {\n        src = target[name];\n        copy = options[name];\n\n        // Prevent never-ending loop\n        if (target === copy) {\n          continue;\n        }\n\n        // Recurse if we're merging plain objects or arrays\n        if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n          if (copyIsArray) {\n            copyIsArray = false;\n            clone = src && isArray(src) ? src : [];\n\n          } else {\n            clone = src && isPlainObject(src) ? src : {};\n          }\n\n          // Never move original objects, clone them\n          target[name] = extend(deep, clone, copy);\n\n        // Don't bring in undefined values\n        } else if (copy !== undefined) {\n          if (!(isArray(options) && isFunction(copy))) {\n            target[name] = copy;\n          }\n        }\n      }\n    }\n  }\n\n  // Return the modified object\n  return target;\n}\n\n\nmodule.exports = extend;\n\n\n},{}],10:[function(require,module,exports){\nvar process=require(\"__browserify_process\");\"use strict\";\n\n/**\n*\n*  MD5 (Message-Digest Algorithm)\n*\n*  For original source see http://www.webtoolkit.info/\n*  Download: 15.02.2009 from http://www.webtoolkit.info/javascript-md5.html\n*\n*  Licensed under CC-BY 2.0 License\n*  (http://creativecommons.org/licenses/by/2.0/uk/)\n*\n**/\nvar crypto = require('crypto');\n\nexports.MD5 = function (string) {\n  if (!process.browser) {\n    return crypto.createHash('md5').update(string).digest('hex');\n  }\n  function rotateLeft(lValue, iShiftBits) {\n    return (lValue<<iShiftBits) | (lValue>>>(32 - iShiftBits));\n  }\n\n  function addUnsigned(lX, lY) {\n    var lX4, lY4, lX8, lY8, lResult;\n    lX8 = (lX & 0x80000000);\n    lY8 = (lY & 0x80000000);\n    lX4 = (lX & 0x40000000);\n    lY4 = (lY & 0x40000000);\n    lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);\n    if (lX4 & lY4) {\n      return (lResult ^ 0x80000000 ^ lX8 ^ lY8);\n    }\n    if (lX4 | lY4) {\n      if (lResult & 0x40000000) {\n        return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);\n      } else {\n        return (lResult ^ 0x40000000 ^ lX8 ^ lY8);\n      }\n    } else {\n      return (lResult ^ lX8 ^ lY8);\n    }\n  }\n\n  function f(x, y, z) { return (x & y) | ((~x) & z); }\n  function g(x, y, z) { return (x & z) | (y & (~z)); }\n  function h(x, y, z) { return (x ^ y ^ z); }\n  function i(x, y, z) { return (y ^ (x | (~z))); }\n\n  function ff(a, b, c, d, x, s, ac) {\n    a = addUnsigned(a, addUnsigned(addUnsigned(f(b, c, d), x), ac));\n    return addUnsigned(rotateLeft(a, s), b);\n  }\n\n  function gg(a, b, c, d, x, s, ac) {\n    a = addUnsigned(a, addUnsigned(addUnsigned(g(b, c, d), x), ac));\n    return addUnsigned(rotateLeft(a, s), b);\n  }\n\n  function hh(a, b, c, d, x, s, ac) {\n    a = addUnsigned(a, addUnsigned(addUnsigned(h(b, c, d), x), ac));\n    return addUnsigned(rotateLeft(a, s), b);\n  }\n\n  function ii(a, b, c, d, x, s, ac) {\n    a = addUnsigned(a, addUnsigned(addUnsigned(i(b, c, d), x), ac));\n    return addUnsigned(rotateLeft(a, s), b);\n  }\n\n  function convertToWordArray(string) {\n    var lWordCount;\n    var lMessageLength = string.length;\n    var lNumberOfWords_temp1 = lMessageLength + 8;\n    var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;\n    var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;\n    var lWordArray = new Array(lNumberOfWords - 1);\n    var lBytePosition = 0;\n    var lByteCount = 0;\n    while (lByteCount < lMessageLength) {\n      lWordCount = (lByteCount - (lByteCount % 4)) / 4;\n      lBytePosition = (lByteCount % 4) * 8;\n      lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));\n      lByteCount++;\n    }\n    lWordCount = (lByteCount - (lByteCount % 4)) / 4;\n    lBytePosition = (lByteCount % 4) * 8;\n    lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);\n    lWordArray[lNumberOfWords - 2] = lMessageLength<<3;\n    lWordArray[lNumberOfWords - 1] = lMessageLength>>>29;\n    return lWordArray;\n  }\n\n  function wordToHex(lValue) {\n    var   wordToHexValue = \"\",   wordToHexValue_temp = \"\", lByte, lCount;\n    for (lCount = 0;lCount <= 3;lCount++) {\n      lByte = (lValue>>>(lCount * 8)) & 255;\n      wordToHexValue_temp = \"0\" + lByte.toString(16);\n      wordToHexValue = wordToHexValue + wordToHexValue_temp.substr(wordToHexValue_temp.length - 2, 2);\n    }\n    return   wordToHexValue;\n  }\n\n  //**\tfunction Utf8Encode(string) removed. Aready defined in pidcrypt_utils.js\n\n  var x = [];\n  var k, AA, BB, CC, DD, a, b, c, d;\n  var S11 = 7, S12 = 12, S13 = 17, S14 = 22;\n  var S21 = 5, S22 = 9,  S23 = 14, S24 = 20;\n  var S31 = 4, S32 = 11, S33 = 16, S34 = 23;\n  var S41 = 6, S42 = 10, S43 = 15, S44 = 21;\n\n  //\tstring = Utf8Encode(string); #function call removed\n\n  x = convertToWordArray(string);\n\n  a = 0x67452301;\n  b = 0xEFCDAB89;\n  c = 0x98BADCFE;\n  d = 0x10325476;\n\n  for (k = 0;k < x.length;k += 16) {\n    AA = a;\n    BB = b;\n    CC = c;\n    DD = d;\n    a = ff(a, b, c, d, x[k + 0],  S11, 0xD76AA478);\n    d = ff(d, a, b, c, x[k + 1],  S12, 0xE8C7B756);\n    c = ff(c, d, a, b, x[k + 2],  S13, 0x242070DB);\n    b = ff(b, c, d, a, x[k + 3],  S14, 0xC1BDCEEE);\n    a = ff(a, b, c, d, x[k + 4],  S11, 0xF57C0FAF);\n    d = ff(d, a, b, c, x[k + 5],  S12, 0x4787C62A);\n    c = ff(c, d, a, b, x[k + 6],  S13, 0xA8304613);\n    b = ff(b, c, d, a, x[k + 7],  S14, 0xFD469501);\n    a = ff(a, b, c, d, x[k + 8],  S11, 0x698098D8);\n    d = ff(d, a, b, c, x[k + 9],  S12, 0x8B44F7AF);\n    c = ff(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);\n    b = ff(b, c, d, a, x[k + 11], S14, 0x895CD7BE);\n    a = ff(a, b, c, d, x[k + 12], S11, 0x6B901122);\n    d = ff(d, a, b, c, x[k + 13], S12, 0xFD987193);\n    c = ff(c, d, a, b, x[k + 14], S13, 0xA679438E);\n    b = ff(b, c, d, a, x[k + 15], S14, 0x49B40821);\n    a = gg(a, b, c, d, x[k + 1],  S21, 0xF61E2562);\n    d = gg(d, a, b, c, x[k + 6],  S22, 0xC040B340);\n    c = gg(c, d, a, b, x[k + 11], S23, 0x265E5A51);\n    b = gg(b, c, d, a, x[k + 0],  S24, 0xE9B6C7AA);\n    a = gg(a, b, c, d, x[k + 5],  S21, 0xD62F105D);\n    d = gg(d, a, b, c, x[k + 10], S22, 0x2441453);\n    c = gg(c, d, a, b, x[k + 15], S23, 0xD8A1E681);\n    b = gg(b, c, d, a, x[k + 4],  S24, 0xE7D3FBC8);\n    a = gg(a, b, c, d, x[k + 9],  S21, 0x21E1CDE6);\n    d = gg(d, a, b, c, x[k + 14], S22, 0xC33707D6);\n    c = gg(c, d, a, b, x[k + 3],  S23, 0xF4D50D87);\n    b = gg(b, c, d, a, x[k + 8],  S24, 0x455A14ED);\n    a = gg(a, b, c, d, x[k + 13], S21, 0xA9E3E905);\n    d = gg(d, a, b, c, x[k + 2],  S22, 0xFCEFA3F8);\n    c = gg(c, d, a, b, x[k + 7],  S23, 0x676F02D9);\n    b = gg(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);\n    a = hh(a, b, c, d, x[k + 5],  S31, 0xFFFA3942);\n    d = hh(d, a, b, c, x[k + 8],  S32, 0x8771F681);\n    c = hh(c, d, a, b, x[k + 11], S33, 0x6D9D6122);\n    b = hh(b, c, d, a, x[k + 14], S34, 0xFDE5380C);\n    a = hh(a, b, c, d, x[k + 1],  S31, 0xA4BEEA44);\n    d = hh(d, a, b, c, x[k + 4],  S32, 0x4BDECFA9);\n    c = hh(c, d, a, b, x[k + 7],  S33, 0xF6BB4B60);\n    b = hh(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);\n    a = hh(a, b, c, d, x[k + 13], S31, 0x289B7EC6);\n    d = hh(d, a, b, c, x[k + 0],  S32, 0xEAA127FA);\n    c = hh(c, d, a, b, x[k + 3],  S33, 0xD4EF3085);\n    b = hh(b, c, d, a, x[k + 6],  S34, 0x4881D05);\n    a = hh(a, b, c, d, x[k + 9],  S31, 0xD9D4D039);\n    d = hh(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);\n    c = hh(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);\n    b = hh(b, c, d, a, x[k + 2],  S34, 0xC4AC5665);\n    a = ii(a, b, c, d, x[k + 0],  S41, 0xF4292244);\n    d = ii(d, a, b, c, x[k + 7],  S42, 0x432AFF97);\n    c = ii(c, d, a, b, x[k + 14], S43, 0xAB9423A7);\n    b = ii(b, c, d, a, x[k + 5],  S44, 0xFC93A039);\n    a = ii(a, b, c, d, x[k + 12], S41, 0x655B59C3);\n    d = ii(d, a, b, c, x[k + 3],  S42, 0x8F0CCC92);\n    c = ii(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);\n    b = ii(b, c, d, a, x[k + 1],  S44, 0x85845DD1);\n    a = ii(a, b, c, d, x[k + 8],  S41, 0x6FA87E4F);\n    d = ii(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);\n    c = ii(c, d, a, b, x[k + 6],  S43, 0xA3014314);\n    b = ii(b, c, d, a, x[k + 13], S44, 0x4E0811A1);\n    a = ii(a, b, c, d, x[k + 4],  S41, 0xF7537E82);\n    d = ii(d, a, b, c, x[k + 11], S42, 0xBD3AF235);\n    c = ii(c, d, a, b, x[k + 2],  S43, 0x2AD7D2BB);\n    b = ii(b, c, d, a, x[k + 9],  S44, 0xEB86D391);\n    a = addUnsigned(a, AA);\n    b = addUnsigned(b, BB);\n    c = addUnsigned(c, CC);\n    d = addUnsigned(d, DD);\n  }\n  var temp = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);\n  return temp.toLowerCase();\n};\n},{\"__browserify_process\":19,\"crypto\":18}],11:[function(require,module,exports){\n\"use strict\";\n\n// BEGIN Math.uuid.js\n\n/*!\nMath.uuid.js (v1.4)\nhttp://www.broofa.com\nmailto:robert@broofa.com\n\nCopyright (c) 2010 Robert Kieffer\nDual licensed under the MIT and GPL licenses.\n*/\n\n/*\n * Generate a random uuid.\n *\n * USAGE: Math.uuid(length, radix)\n *   length - the desired number of characters\n *   radix  - the number of allowable values for each character.\n *\n * EXAMPLES:\n *   // No arguments  - returns RFC4122, version 4 ID\n *   >>> Math.uuid()\n *   \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\n *\n *   // One argument - returns ID of the specified length\n *   >>> Math.uuid(15)     // 15 character ID (default base=62)\n *   \"VcydxgltxrVZSTV\"\n *\n *   // Two arguments - returns ID of the specified length, and radix. (Radix must be <= 62)\n *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)\n *   \"01001010\"\n *   >>> Math.uuid(8, 10) // 8 character ID (base=10)\n *   \"47473046\"\n *   >>> Math.uuid(8, 16) // 8 character ID (base=16)\n *   \"098F4D35\"\n */\n\n\nfunction uuid(len, radix) {\n  var chars = uuid.CHARS;\n  var uuidInner = [];\n  var i;\n\n  radix = radix || chars.length;\n\n  if (len) {\n    // Compact form\n    for (i = 0; i < len; i++) {\n      uuidInner[i] = chars[0 | Math.random() * radix];\n    }\n  } else {\n    // rfc4122, version 4 form\n    var r;\n\n    // rfc4122 requires these characters\n    uuidInner[8] = uuidInner[13] = uuidInner[18] = uuidInner[23] = '-';\n    uuidInner[14] = '4';\n\n    // Fill in random data.  At i==19 set the high bits of clock sequence as\n    // per rfc4122, sec. 4.1.5\n    for (i = 0; i < 36; i++) {\n      if (!uuidInner[i]) {\n        r = 0 | Math.random() * 16;\n        uuidInner[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r];\n      }\n    }\n  }\n\n  return uuidInner.join('');\n}\n\nuuid.CHARS = (\n  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' +\n  'abcdefghijklmnopqrstuvwxyz'\n).split('');\n\nmodule.exports = uuid;\n\n\n},{}],12:[function(require,module,exports){\nvar process=require(\"__browserify_process\");\"use strict\";\n\nvar PouchDB = require('./setup');\n\nmodule.exports = PouchDB;\n\nPouchDB.ajax = require('./deps/ajax');\nPouchDB.extend = require('./deps/extend');\nPouchDB.utils = require('./utils');\nPouchDB.Errors = require('./deps/errors');\nPouchDB.replicate = require('./replicate').replicate;\nPouchDB.version = require('./version');\nvar httpAdapter = require('./adapters/http');\nPouchDB.adapter('http', httpAdapter);\nPouchDB.adapter('https', httpAdapter);\n\nPouchDB.adapter('idb', require('./adapters/idb'));\nPouchDB.adapter('websql', require('./adapters/websql'));\nPouchDB.plugin('mapreduce', require('pouchdb-mapreduce'));\n\nif (!process.browser) {\n  var ldbAdapter = require('./adapters/leveldb');\n  PouchDB.adapter('ldb', ldbAdapter);\n  PouchDB.adapter('leveldb', ldbAdapter);\n}\n\n},{\"./adapters/http\":2,\"./adapters/idb\":3,\"./adapters/leveldb\":18,\"./adapters/websql\":4,\"./deps/ajax\":6,\"./deps/errors\":8,\"./deps/extend\":9,\"./replicate\":14,\"./setup\":15,\"./utils\":16,\"./version\":17,\"__browserify_process\":19,\"pouchdb-mapreduce\":20}],13:[function(require,module,exports){\n'use strict';\n\nvar extend = require('./deps/extend');\n\n\n// for a better overview of what this is doing, read:\n// https://github.com/apache/couchdb/blob/master/src/couchdb/couch_key_tree.erl\n//\n// But for a quick intro, CouchDB uses a revision tree to store a documents\n// history, A -> B -> C, when a document has conflicts, that is a branch in the\n// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format\n//\n// KeyTree = [Path ... ]\n// Path = {pos: position_from_root, ids: Tree}\n// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]\n\n// Turn a path as a flat array into a tree with a single branch\nfunction pathToTree(path) {\n  var doc = path.shift();\n  var root = [doc.id, doc.opts, []];\n  var leaf = root;\n  var nleaf;\n\n  while (path.length) {\n    doc = path.shift();\n    nleaf = [doc.id, doc.opts, []];\n    leaf[2].push(nleaf);\n    leaf = nleaf;\n  }\n  return root;\n}\n\n// Merge two trees together\n// The roots of tree1 and tree2 must be the same revision\nfunction mergeTree(in_tree1, in_tree2) {\n  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n  var conflicts = false;\n  while (queue.length > 0) {\n    var item = queue.pop();\n    var tree1 = item.tree1;\n    var tree2 = item.tree2;\n\n    if (tree1[1].status || tree2[1].status) {\n      tree1[1].status = (tree1[1].status ===  'available' ||\n                         tree2[1].status === 'available') ? 'available' : 'missing';\n    }\n\n    for (var i = 0; i < tree2[2].length; i++) {\n      if (!tree1[2][0]) {\n        conflicts = 'new_leaf';\n        tree1[2][0] = tree2[2][i];\n        continue;\n      }\n\n      var merged = false;\n      for (var j = 0; j < tree1[2].length; j++) {\n        if (tree1[2][j][0] === tree2[2][i][0]) {\n          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n          merged = true;\n        }\n      }\n      if (!merged) {\n        conflicts = 'new_branch';\n        tree1[2].push(tree2[2][i]);\n        tree1[2].sort();\n      }\n    }\n  }\n  return {conflicts: conflicts, tree: in_tree1};\n}\n\nfunction doMerge(tree, path, dontExpand) {\n  var restree = [];\n  var conflicts = false;\n  var merged = false;\n  var res, branch;\n\n  if (!tree.length) {\n    return {tree: [path], conflicts: 'new_leaf'};\n  }\n\n  tree.forEach(function (branch) {\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n      // Paths start at the same position and have the same root, so they need\n      // merged\n      res = mergeTree(branch.ids, path.ids);\n      restree.push({pos: branch.pos, ids: res.tree});\n      conflicts = conflicts || res.conflicts;\n      merged = true;\n    } else if (dontExpand !== true) {\n      // The paths start at a different position, take the earliest path and\n      // traverse up until it as at the same point from root as the path we want to\n      // merge.  If the keys match we return the longer path with the other merged\n      // After stemming we dont want to expand the trees\n\n      var t1 = branch.pos < path.pos ? branch : path;\n      var t2 = branch.pos < path.pos ? path : branch;\n      var diff = t2.pos - t1.pos;\n\n      var candidateParents = [];\n\n      var trees = [];\n      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n      while (trees.length > 0) {\n        var item = trees.pop();\n        if (item.diff === 0) {\n          if (item.ids[0] === t2.ids[0]) {\n            candidateParents.push(item);\n          }\n          continue;\n        }\n        if (!item.ids) {\n          continue;\n        }\n        /*jshint loopfunc:true */\n        item.ids[2].forEach(function (el, idx) {\n          trees.push({ids: el, diff: item.diff - 1, parent: item.ids, parentIdx: idx});\n        });\n      }\n\n      var el = candidateParents[0];\n\n      if (!el) {\n        restree.push(branch);\n      } else {\n        res = mergeTree(el.ids, t2.ids);\n        el.parent[2][el.parentIdx] = res.tree;\n        restree.push({pos: t1.pos, ids: t1.ids});\n        conflicts = conflicts || res.conflicts;\n        merged = true;\n      }\n    } else {\n      restree.push(branch);\n    }\n  });\n\n  // We didnt find\n  if (!merged) {\n    restree.push(path);\n  }\n\n  restree.sort(function (a, b) {\n    return a.pos - b.pos;\n  });\n\n  return {\n    tree: restree,\n    conflicts: conflicts || 'internal_node'\n  };\n}\n\n// To ensure we dont grow the revision tree infinitely, we stem old revisions\nfunction stem(tree, depth) {\n  // First we break out the tree into a complete list of root to leaf paths,\n  // we cut off the start of the path and generate a new set of flat trees\n  var stemmedPaths = PouchMerge.rootToLeaf(tree).map(function (path) {\n    var stemmed = path.ids.slice(-depth);\n    return {\n      pos: path.pos + (path.ids.length - stemmed.length),\n      ids: pathToTree(stemmed)\n    };\n  });\n  // Then we remerge all those flat trees together, ensuring that we dont\n  // connect trees that would go beyond the depth limit\n  return stemmedPaths.reduce(function (prev, current, i, arr) {\n    return doMerge(prev, current, true).tree;\n  }, [stemmedPaths.shift()]);\n}\n\nvar PouchMerge = {};\n\nPouchMerge.merge = function (tree, path, depth) {\n  // Ugh, nicer way to not modify arguments in place?\n  tree = extend(true, [], tree);\n  path = extend(true, {}, path);\n  var newTree = doMerge(tree, path);\n  return {\n    tree: stem(newTree.tree, depth),\n    conflicts: newTree.conflicts\n  };\n};\n\n// We fetch all leafs of the revision tree, and sort them based on tree length\n// and whether they were deleted, undeleted documents with the longest revision\n// tree (most edits) win\n// The final sort algorithm is slightly documented in a sidebar here:\n// http://guide.couchdb.org/draft/conflicts.html\nPouchMerge.winningRev = function (metadata) {\n  var leafs = [];\n  PouchMerge.traverseRevTree(metadata.rev_tree,\n                              function (isLeaf, pos, id, something, opts) {\n    if (isLeaf) {\n      leafs.push({pos: pos, id: id, deleted: !!opts.deleted});\n    }\n  });\n  leafs.sort(function (a, b) {\n    if (a.deleted !== b.deleted) {\n      return a.deleted > b.deleted ? 1 : -1;\n    }\n    if (a.pos !== b.pos) {\n      return b.pos - a.pos;\n    }\n    return a.id < b.id ? 1 : -1;\n  });\n\n  return leafs[0].pos + '-' + leafs[0].id;\n};\n\n// Pretty much all below can be combined into a higher order function to\n// traverse revisions\n// The return value from the callback will be passed as context to all\n// children of that node\nPouchMerge.traverseRevTree = function (revs, callback) {\n  var toVisit = [];\n\n  revs.forEach(function (tree) {\n    toVisit.push({pos: tree.pos, ids: tree.ids});\n  });\n  while (toVisit.length > 0) {\n    var node = toVisit.pop();\n    var pos = node.pos;\n    var tree = node.ids;\n    var newCtx = callback(tree[2].length === 0, pos, tree[0], node.ctx, tree[1]);\n    /*jshint loopfunc: true */\n    tree[2].forEach(function (branch) {\n      toVisit.push({pos: pos + 1, ids: branch, ctx: newCtx});\n    });\n  }\n};\n\nPouchMerge.collectLeaves = function (revs) {\n  var leaves = [];\n  PouchMerge.traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n    if (isLeaf) {\n      leaves.unshift({rev: pos + \"-\" + id, pos: pos, opts: opts});\n    }\n  });\n  leaves.sort(function (a, b) {\n    return b.pos - a.pos;\n  });\n  leaves.map(function (leaf) { delete leaf.pos; });\n  return leaves;\n};\n\n// returns revs of all conflicts that is leaves such that\n// 1. are not deleted and\n// 2. are different than winning revision\nPouchMerge.collectConflicts = function (metadata) {\n  var win = PouchMerge.winningRev(metadata);\n  var leaves = PouchMerge.collectLeaves(metadata.rev_tree);\n  var conflicts = [];\n  leaves.forEach(function (leaf) {\n    if (leaf.rev !== win && !leaf.opts.deleted) {\n      conflicts.push(leaf.rev);\n    }\n  });\n  return conflicts;\n};\n\nPouchMerge.rootToLeaf = function (tree) {\n  var paths = [];\n  PouchMerge.traverseRevTree(tree, function (isLeaf, pos, id, history, opts) {\n    history = history ? history.slice(0) : [];\n    history.push({id: id, opts: opts});\n    if (isLeaf) {\n      var rootPos = pos + 1 - history.length;\n      paths.unshift({pos: rootPos, ids: history});\n    }\n    return history;\n  });\n  return paths;\n};\n\n\nmodule.exports = PouchMerge;\n\n},{\"./deps/extend\":9}],14:[function(require,module,exports){\nvar process=require(\"__browserify_process\");'use strict';\n\nvar PouchUtils = require('./utils');\nvar Pouch = require('./index');\n\n// We create a basic promise so the caller can cancel the replication possibly\n// before we have actually started listening to changes etc\nfunction Promise() {\n  var that = this;\n  this.cancelled = false;\n  this.cancel = function () {\n    that.cancelled = true;\n  };\n}\n\n// The RequestManager ensures that only one database request is active at\n// at time, it ensures we dont max out simultaneous HTTP requests and makes\n// the replication process easier to reason about\n\nfunction RequestManager(promise) {\n  var queue = [];\n  var api = {};\n  var processing = false;\n\n  // Add a new request to the queue, if we arent currently processing anything\n  // then process it immediately\n  api.enqueue = function (fun, args) {\n    queue.push({fun: fun, args: args});\n    if (!processing) {\n      api.process();\n    }\n  };\n\n  // Process the next request\n  api.process = function () {\n    if (processing || !queue.length || promise.cancelled) {\n      return;\n    }\n    processing = true;\n    var task = queue.shift();\n    process.nextTick(function () {\n      task.fun.apply(null, task.args);\n    });\n  };\n\n  // We need to be notified whenever a request is complete to process\n  // the next request\n  api.notifyRequestComplete = function () {\n    processing = false;\n    api.process();\n  };\n\n  return api;\n}\n\n// TODO: check CouchDB's replication id generation, generate a unique id particular\n// to this replication\n\nfunction genReplicationId(src, target, opts) {\n  var filterFun = opts.filter ? opts.filter.toString() : '';\n  return '_local/' + PouchUtils.Crypto.MD5(src.id() + target.id() + filterFun);\n}\n\n// A checkpoint lets us restart replications from when they were last cancelled\n\nfunction fetchCheckpoint(src, target, id, callback) {\n  target.get(id, function (err, targetDoc) {\n    if (err && err.status === 404) {\n      callback(null, 0);\n    } else if (err) {\n      callback(err);\n    } else {\n      src.get(id, function (err, sourceDoc) {\n        if (err && err.status === 404 || (!err && (targetDoc.last_seq !== sourceDoc.last_seq))) {\n          callback(null, 0);\n        } else if (err) {\n          callback(err);\n        } else {\n          callback(null, sourceDoc.last_seq);\n        }\n      });\n    }\n  });\n}\n\nfunction writeCheckpoint(src, target, id, checkpoint, callback) {\n  function updateCheckpoint(db, callback) {\n    db.get(id, function (err, doc) {\n      if (err && err.status === 404) {\n        doc = {_id: id};\n      }\n      doc.last_seq = checkpoint;\n      db.put(doc, callback);\n    });\n  }\n  updateCheckpoint(target, function (err, doc) {\n    updateCheckpoint(src, function (err, doc) {\n      callback();\n    });\n  });\n}\n\nfunction replicate(src, target, opts, promise) {\n\n  var requests = new RequestManager(promise);\n  var writeQueue = [];\n  var repId = genReplicationId(src, target, opts);\n  var results = [];\n  var completed = false;\n  var pendingRevs = 0;\n  var last_seq = 0;\n  var continuous = opts.continuous || false;\n  var doc_ids = opts.doc_ids;\n  var result = {\n    ok: true,\n    start_time: new Date(),\n    docs_read: 0,\n    docs_written: 0\n  };\n\n  function docsWritten(err, res, len) {\n    if (opts.onChange) {\n      for (var i = 0; i < len; i++) {\n        /*jshint validthis:true */\n        opts.onChange.apply(this, [result]);\n      }\n    }\n    pendingRevs -= len;\n    result.docs_written += len;\n\n    writeCheckpoint(src, target, repId, last_seq, function (err, res) {\n      requests.notifyRequestComplete();\n      isCompleted();\n    });\n  }\n\n  function writeDocs() {\n    if (!writeQueue.length) {\n      return requests.notifyRequestComplete();\n    }\n    var len = writeQueue.length;\n    target.bulkDocs({docs: writeQueue}, {new_edits: false}, function (err, res) {\n      docsWritten(err, res, len);\n    });\n    writeQueue = [];\n  }\n\n  function eachRev(id, rev) {\n    src.get(id, {revs: true, rev: rev, attachments: true}, function (err, doc) {\n      result.docs_read++;\n      requests.notifyRequestComplete();\n      writeQueue.push(doc);\n      requests.enqueue(writeDocs);\n    });\n  }\n\n  function onRevsDiff(diffCounts) {\n    return function (err, diffs) {\n      requests.notifyRequestComplete();\n      if (err) {\n        if (continuous) {\n          promise.cancel();\n        }\n        PouchUtils.call(opts.complete, err, null);\n        return;\n      }\n\n      // We already have all diffs passed in `diffCounts`\n      if (Object.keys(diffs).length === 0) {\n        for (var docid in diffCounts) {\n          pendingRevs -= diffCounts[docid];\n        }\n        isCompleted();\n        return;\n      }\n\n      var _enqueuer = function (rev) {\n        requests.enqueue(eachRev, [id, rev]);\n      };\n\n      for (var id in diffs) {\n        var diffsAlreadyHere = diffCounts[id] - diffs[id].missing.length;\n        pendingRevs -= diffsAlreadyHere;\n        diffs[id].missing.forEach(_enqueuer);\n      }\n    };\n  }\n\n  function fetchRevsDiff(diff, diffCounts) {\n    target.revsDiff(diff, onRevsDiff(diffCounts));\n  }\n\n  function onChange(change) {\n    last_seq = change.seq;\n    results.push(change);\n    var diff = {};\n    diff[change.id] = change.changes.map(function (x) { return x.rev; });\n    var counts = {};\n    counts[change.id] = change.changes.length;\n    pendingRevs += change.changes.length;\n    requests.enqueue(fetchRevsDiff, [diff, counts]);\n  }\n\n  function complete() {\n    completed = true;\n    isCompleted();\n  }\n\n  function isCompleted() {\n    if (completed && pendingRevs === 0) {\n      result.end_time = new Date();\n      PouchUtils.call(opts.complete, null, result);\n    }\n  }\n\n  fetchCheckpoint(src, target, repId, function (err, checkpoint) {\n\n    if (err) {\n      return PouchUtils.call(opts.complete, err);\n    }\n\n    last_seq = checkpoint;\n\n    // Was the replication cancelled by the caller before it had a chance\n    // to start. Shouldnt we be calling complete?\n    if (promise.cancelled) {\n      return;\n    }\n\n    var repOpts = {\n      continuous: continuous,\n      since: last_seq,\n      style: 'all_docs',\n      onChange: onChange,\n      complete: complete,\n      doc_ids: doc_ids\n    };\n\n    if (opts.filter) {\n      repOpts.filter = opts.filter;\n    }\n\n    if (opts.query_params) {\n      repOpts.query_params = opts.query_params;\n    }\n\n    var changes = src.changes(repOpts);\n\n    if (opts.continuous) {\n      var cancel = promise.cancel;\n      promise.cancel = function () {\n        cancel();\n        changes.cancel();\n      };\n    }\n  });\n\n}\n\nfunction toPouch(db, callback) {\n  if (typeof db === 'string') {\n    return new Pouch(db, callback);\n  }\n  callback(null, db);\n}\n\nexports.replicate = function (src, target, opts, callback) {\n  if (opts instanceof Function) {\n    callback = opts;\n    opts = {};\n  }\n  if (opts === undefined) {\n    opts = {};\n  }\n  if (!opts.complete) {\n    opts.complete = callback;\n  }\n  var replicateRet = new Promise();\n  toPouch(src, function (err, src) {\n    if (err) {\n      return PouchUtils.call(callback, err);\n    }\n    toPouch(target, function (err, target) {\n      if (err) {\n        return PouchUtils.call(callback, err);\n      }\n      if (opts.server) {\n        if (typeof src.replicateOnServer !== 'function') {\n          return PouchUtils.call(callback, { error: 'Server replication not supported for ' + src.type() + ' adapter' });\n        }\n        if (src.type() !== target.type()) {\n          return PouchUtils.call(callback, { error: 'Server replication for different adapter types (' + src.type() + ' and ' + target.type() + ') is not supported' });\n        }\n        src.replicateOnServer(target, opts, replicateRet);\n      } else {\n        replicate(src, target, opts, replicateRet);\n      }\n    });\n  });\n  return replicateRet;\n};\n\n},{\"./index\":12,\"./utils\":16,\"__browserify_process\":19}],15:[function(require,module,exports){\n\"use strict\";\n\nvar PouchDB = require(\"./constructor\");\n\nPouchDB.adapters = {};\nPouchDB.plugins = {};\n\nPouchDB.prefix = '_pouch_';\n\nPouchDB.parseAdapter = function (name) {\n  var match = name.match(/([a-z\\-]*):\\/\\/(.*)/);\n  var adapter;\n  if (match) {\n    // the http adapter expects the fully qualified name\n    name = /http(s?)/.test(match[1]) ? match[1] + '://' + match[2] : match[2];\n    adapter = match[1];\n    if (!PouchDB.adapters[adapter].valid()) {\n      throw 'Invalid adapter';\n    }\n    return {name: name, adapter: match[1]};\n  }\n\n  var preferredAdapters = ['idb', 'leveldb', 'websql'];\n  for (var i = 0; i < preferredAdapters.length; ++i) {\n    if (preferredAdapters[i] in PouchDB.adapters) {\n      adapter = PouchDB.adapters[preferredAdapters[i]];\n      var use_prefix = 'use_prefix' in adapter ? adapter.use_prefix : true;\n\n      return {\n        name: use_prefix ? PouchDB.prefix + name : name,\n        adapter: preferredAdapters[i]\n      };\n    }\n  }\n\n  throw 'No valid adapter found';\n};\n\nPouchDB.destroy = function (name, opts, callback) {\n  if (typeof opts === 'function' || typeof opts === 'undefined') {\n    callback = opts;\n    opts = {};\n  }\n\n  if (typeof name === 'object') {\n    opts = name;\n    name = undefined;\n  }\n\n  if (typeof callback === 'undefined') {\n    callback = function () {};\n  }\n  var backend = PouchDB.parseAdapter(opts.name || name);\n  var dbName = backend.name;\n\n  var cb = function (err, response) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    for (var plugin in PouchDB.plugins) {\n      PouchDB.plugins[plugin]._delete(dbName);\n    }\n    //console.log(dbName + ': Delete Database');\n\n    // call destroy method of the particular adaptor\n    PouchDB.adapters[backend.adapter].destroy(dbName, opts, callback);\n  };\n\n  // remove PouchDB from allDBs\n  PouchDB.removeFromAllDbs(backend, cb);\n};\n\nPouchDB.removeFromAllDbs = function (opts, callback) {\n  // Only execute function if flag is enabled\n  if (!PouchDB.enableAllDbs) {\n    callback();\n    return;\n  }\n\n  // skip http and https adaptors for allDbs\n  var adapter = opts.adapter;\n  if (adapter === \"http\" || adapter === \"https\") {\n    callback();\n    return;\n  }\n\n  // remove db from PouchDB.ALL_DBS\n  new PouchDB(PouchDB.allDBName(opts.adapter), function (err, db) {\n    if (err) {\n      // don't fail when allDbs fail\n      //console.error(err);\n      callback();\n      return;\n    }\n    // check if db has been registered in PouchDB.ALL_DBS\n    var dbname = PouchDB.dbName(opts.adapter, opts.name);\n    db.get(dbname, function (err, doc) {\n      if (err) {\n        callback();\n      } else {\n        db.remove(doc, function (err, response) {\n          if (err) {\n            //console.error(err);\n          }\n          callback();\n        });\n      }\n    });\n  });\n\n};\n\nPouchDB.adapter = function (id, obj) {\n  if (obj.valid()) {\n    PouchDB.adapters[id] = obj;\n  }\n};\n\nPouchDB.plugin = function (id, obj) {\n  PouchDB.plugins[id] = obj;\n};\n\n// flag to toggle allDbs (off by default)\nPouchDB.enableAllDbs = false;\n\n// name of database used to keep track of databases\nPouchDB.ALL_DBS = \"_allDbs\";\nPouchDB.dbName = function (adapter, name) {\n  return [adapter, \"-\", name].join('');\n};\nPouchDB.realDBName = function (adapter, name) {\n  return [adapter, \"://\", name].join('');\n};\nPouchDB.allDBName = function (adapter) {\n  return [adapter, \"://\", PouchDB.prefix + PouchDB.ALL_DBS].join('');\n};\n\nPouchDB.open = function (opts, callback) {\n  // Only register pouch with allDbs if flag is enabled\n  if (!PouchDB.enableAllDbs) {\n    callback();\n    return;\n  }\n\n  var adapter = opts.adapter;\n  // skip http and https adaptors for allDbs\n  if (adapter === \"http\" || adapter === \"https\") {\n    callback();\n    return;\n  }\n\n  new PouchDB(PouchDB.allDBName(adapter), function (err, db) {\n    if (err) {\n      // don't fail when allDb registration fails\n      //console.error(err);\n      callback();\n      return;\n    }\n\n    // check if db has been registered in PouchDB.ALL_DBS\n    var dbname = PouchDB.dbName(adapter, opts.name);\n    db.get(dbname, function (err, response) {\n      if (err && err.status === 404) {\n        db.put({\n          _id: dbname,\n          dbname: opts.originalName\n        }, function (err) {\n            if (err) {\n              //console.error(err);\n            }\n\n            callback();\n          });\n      } else {\n        callback();\n      }\n    });\n  });\n};\n\nPouchDB.allDbs = function (callback) {\n  var accumulate = function (adapters, all_dbs) {\n    if (adapters.length === 0) {\n      // remove duplicates\n      var result = [];\n      all_dbs.forEach(function (doc) {\n        var exists = result.some(function (db) {\n          return db.id === doc.id;\n        });\n\n        if (!exists) {\n          result.push(doc);\n        }\n      });\n\n      // return an array of dbname\n      callback(null, result.map(function (row) {\n          return row.doc.dbname;\n        }));\n      return;\n    }\n\n    var adapter = adapters.shift();\n\n    // skip http and https adaptors for allDbs\n    if (adapter === \"http\" || adapter === \"https\") {\n      accumulate(adapters, all_dbs);\n      return;\n    }\n\n    new PouchDB(PouchDB.allDBName(adapter), function (err, db) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      db.allDocs({include_docs: true}, function (err, response) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        // append from current adapter rows\n        all_dbs.unshift.apply(all_dbs, response.rows);\n\n        // code to clear allDbs.\n        // response.rows.forEach(function (row) {\n        //   db.remove(row.doc, function () {\n        //     //console.log(arguments);\n        //   });\n        // });\n\n        // recurse\n        accumulate(adapters, all_dbs);\n      });\n    });\n  };\n  var adapters = Object.keys(PouchDB.adapters);\n  accumulate(adapters, []);\n};\n\nmodule.exports = PouchDB;\n\n},{\"./constructor\":5}],16:[function(require,module,exports){\n/*jshint strict: false */\n/*global chrome */\n\nvar merge = require('./merge');\nexports.extend = require('./deps/extend');\nexports.ajax = require('./deps/ajax');\nexports.createBlob = require('./deps/blob');\nvar uuid = require('./deps/uuid');\nexports.Crypto = require('./deps/md5.js');\nvar buffer = require('./deps/buffer');\nvar errors = require('./deps/errors');\n\n// List of top level reserved words for doc\nvar reservedWords = [\n  '_id',\n  '_rev',\n  '_attachments',\n  '_deleted',\n  '_revisions',\n  '_revs_info',\n  '_conflicts',\n  '_deleted_conflicts',\n  '_local_seq',\n  '_rev_tree'\n];\nexports.uuids = function (count, options) {\n\n  if (typeof(options) !== 'object') {\n    options = {};\n  }\n\n  var length = options.length;\n  var radix = options.radix;\n  var uuids = [];\n\n  while (uuids.push(uuid(length, radix)) < count) { }\n\n  return uuids;\n};\n\n// Give back one UUID\nexports.uuid = function (options) {\n  return exports.uuids(1, options)[0];\n};\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or '_local'\n//   - any other string value is a valid id\nexports.isValidId = function (id) {\n  if (!id || (typeof id !== 'string')) {\n    return false;\n  }\n  if (/^_/.test(id)) {\n    return (/^_(design|local)/).test(id);\n  }\n  return true;\n};\n\nfunction isChromeApp() {\n  return (typeof chrome !== \"undefined\" &&\n          typeof chrome.storage !== \"undefined\" &&\n          typeof chrome.storage.local !== \"undefined\");\n}\n\n// Pretty dumb name for a function, just wraps callback calls so we dont\n// to if (callback) callback() everywhere\nexports.call = function (fun) {\n  if (typeof fun === typeof Function) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    fun.apply(this, args);\n  }\n};\n\nexports.isLocalId = function (id) {\n  return (/^_local/).test(id);\n};\n\n// check if a specific revision of a doc has been deleted\n//  - metadata: the metadata object from the doc store\n//  - rev: (optional) the revision to check. defaults to winning revision\nexports.isDeleted = function (metadata, rev) {\n  if (!rev) {\n    rev = merge.winningRev(metadata);\n  }\n  if (rev.indexOf('-') >= 0) {\n    rev = rev.split('-')[1];\n  }\n  var deleted = false;\n  merge.traverseRevTree(metadata.rev_tree, function (isLeaf, pos, id, acc, opts) {\n    if (id === rev) {\n      deleted = !!opts.deleted;\n    }\n  });\n\n  return deleted;\n};\n\nexports.filterChange = function (opts) {\n  return function (change) {\n    var req = {};\n    var hasFilter = opts.filter && typeof opts.filter === 'function';\n\n    req.query = opts.query_params;\n    if (opts.filter && hasFilter && !opts.filter.call(this, change.doc, req)) {\n      return false;\n    }\n    if (opts.doc_ids && opts.doc_ids.indexOf(change.id) === -1) {\n      return false;\n    }\n    if (!opts.include_docs) {\n      delete change.doc;\n    } else {\n      for (var att in change.doc._attachments) {\n        change.doc._attachments[att].stub = true;\n      }\n    }\n    return true;\n  };\n};\n\nexports.processChanges = function (opts, changes, last_seq) {\n  // TODO: we should try to filter and limit as soon as possible\n  changes = changes.filter(exports.filterChange(opts));\n  if (opts.limit) {\n    if (opts.limit < changes.length) {\n      changes.length = opts.limit;\n    }\n  }\n  changes.forEach(function (change) {\n    exports.call(opts.onChange, change);\n  });\n  exports.call(opts.complete, null, {results: changes, last_seq: last_seq});\n};\n\n// Preprocess documents, parse their revisions, assign an id and a\n// revision for new writes that are missing them, etc\nexports.parseDoc = function (doc, newEdits) {\n  var error = null;\n  var nRevNum;\n  var newRevId;\n  var revInfo;\n  var opts = {status: 'available'};\n  if (doc._deleted) {\n    opts.deleted = true;\n  }\n\n  if (newEdits) {\n    if (!doc._id) {\n      doc._id = exports.uuid();\n    }\n    newRevId = exports.uuid({length: 32, radix: 16}).toLowerCase();\n    if (doc._rev) {\n      revInfo = /^(\\d+)-(.+)$/.exec(doc._rev);\n      if (!revInfo) {\n        throw \"invalid value for property '_rev'\";\n      }\n      doc._rev_tree = [{\n        pos: parseInt(revInfo[1], 10),\n        ids: [revInfo[2], {status: 'missing'}, [[newRevId, opts, []]]]\n      }];\n      nRevNum = parseInt(revInfo[1], 10) + 1;\n    } else {\n      doc._rev_tree = [{\n        pos: 1,\n        ids : [newRevId, opts, []]\n      }];\n      nRevNum = 1;\n    }\n  } else {\n    if (doc._revisions) {\n      doc._rev_tree = [{\n        pos: doc._revisions.start - doc._revisions.ids.length + 1,\n        ids: doc._revisions.ids.reduce(function (acc, x) {\n          if (acc === null) {\n            return [x, opts, []];\n          } else {\n            return [x, {status: 'missing'}, [acc]];\n          }\n        }, null)\n      }];\n      nRevNum = doc._revisions.start;\n      newRevId = doc._revisions.ids[0];\n    }\n    if (!doc._rev_tree) {\n      revInfo = /^(\\d+)-(.+)$/.exec(doc._rev);\n      if (!revInfo) {\n        return errors.BAD_ARG;\n      }\n      nRevNum = parseInt(revInfo[1], 10);\n      newRevId = revInfo[2];\n      doc._rev_tree = [{\n        pos: parseInt(revInfo[1], 10),\n        ids: [revInfo[2], opts, []]\n      }];\n    }\n  }\n\n  if (typeof doc._id !== 'string') {\n    error = errors.INVALID_ID;\n  }\n  else if (!exports.isValidId(doc._id)) {\n    error = errors.RESERVED_ID;\n  }\n\n  for (var key in doc) {\n    if (doc.hasOwnProperty(key) && key[0] === '_' && reservedWords.indexOf(key) === -1) {\n      error = exports.extend({}, errors.DOC_VALIDATION);\n      error.reason += ': ' + key;\n    }\n  }\n\n  doc._id = decodeURIComponent(doc._id);\n  doc._rev = [nRevNum, newRevId].join('-');\n\n  if (error) {\n    return error;\n  }\n\n  return Object.keys(doc).reduce(function (acc, key) {\n    if (/^_/.test(key) && key !== '_attachments') {\n      acc.metadata[key.slice(1)] = doc[key];\n    } else {\n      acc.data[key] = doc[key];\n    }\n    return acc;\n  }, {metadata : {}, data : {}});\n};\n\nexports.isCordova = function () {\n  return (typeof cordova !== \"undefined\" ||\n          typeof PhoneGap !== \"undefined\" ||\n          typeof phonegap !== \"undefined\");\n};\n\nexports.Changes = function () {\n\n  var api = {};\n  var listeners = {};\n\n  if (isChromeApp()) {\n    chrome.storage.onChanged.addListener(function (e) {\n      // make sure it's event addressed to us\n      if (e.db_name != null) {\n        api.notify(e.db_name.newValue);//object only has oldValue, newValue members\n      }\n    });\n  } else if (typeof window !== 'undefined') {\n    window.addEventListener(\"storage\", function (e) {\n      api.notify(e.key);\n    });\n  }\n\n  api.addListener = function (db_name, id, db, opts) {\n    if (!listeners[db_name]) {\n      listeners[db_name] = {};\n    }\n    listeners[db_name][id] = {\n      db: db,\n      opts: opts\n    };\n  };\n\n  api.removeListener = function (db_name, id) {\n    if (listeners[db_name]) {\n      delete listeners[db_name][id];\n    }\n  };\n\n  api.clearListeners = function (db_name) {\n    delete listeners[db_name];\n  };\n\n  api.notifyLocalWindows = function (db_name) {\n    //do a useless change on a storage thing\n    //in order to get other windows's listeners to activate\n    if (!isChromeApp()) {\n      localStorage[db_name] = (localStorage[db_name] === \"a\") ? \"b\" : \"a\";\n    } else {\n      chrome.storage.local.set({db_name: db_name});\n    }\n  };\n\n  api.notify = function (db_name) {\n    if (!listeners[db_name]) { return; }\n\n    Object.keys(listeners[db_name]).forEach(function (i) {\n      var opts = listeners[db_name][i].opts;\n      listeners[db_name][i].db.changes({\n        include_docs: opts.include_docs,\n        conflicts: opts.conflicts,\n        continuous: false,\n        descending: false,\n        filter: opts.filter,\n        view: opts.view,\n        since: opts.since,\n        query_params: opts.query_params,\n        onChange: function (c) {\n          if (c.seq > opts.since && !opts.cancelled) {\n            opts.since = c.seq;\n            exports.call(opts.onChange, c);\n          }\n        }\n      });\n    });\n  };\n\n  return api;\n};\n\nif (typeof window === 'undefined' || !('atob' in window)) {\n  exports.atob = function (str) {\n    var base64 = new buffer(str, 'base64');\n    // Node.js will just skip the characters it can't encode instead of\n    // throwing and exception\n    if (base64.toString('base64') !== str) {\n      throw (\"Cannot base64 encode full string\");\n    }\n    return base64.toString('binary');\n  };\n} else {\n  exports.atob = function (str) {\n    return atob(str);\n  };\n}\n\nif (typeof window === 'undefined' || !('btoa' in window)) {\n  exports.btoa = function (str) {\n    return new buffer(str, 'binary').toString('base64');\n  };\n} else {\n  exports.btoa = function (str) {\n    return btoa(str);\n  };\n}\n\n\nmodule.exports = exports;\n\n},{\"./deps/ajax\":6,\"./deps/blob\":7,\"./deps/buffer\":18,\"./deps/errors\":8,\"./deps/extend\":9,\"./deps/md5.js\":10,\"./deps/uuid\":11,\"./merge\":13}],17:[function(require,module,exports){\nmodule.exports = '1.1.0';\n\n},{}],18:[function(require,module,exports){\n\n},{}],19:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n\n},{}],20:[function(require,module,exports){\n/*global Pouch: true, pouchCollate: true */\n\n\"use strict\";\n\nvar pouchCollate = require('pouchdb-collate');\n\n// This is the first implementation of a basic plugin, we register the\n// plugin object with pouch and it is mixin'd to each database created\n// (regardless of adapter), adapters can override plugins by providing\n// their own implementation. functions on the plugin object that start\n// with _ are reserved function that are called by pouchdb for special\n// notifications.\n\n// If we wanted to store incremental views we can do it here by listening\n// to the changes feed (keeping track of our last update_seq between page loads)\n// and storing the result of the map function (possibly using the upcoming\n// extracted adapter functions)\n\n\n\nfunction MapReduce(db) {\n  if(!(this instanceof MapReduce)){\n    return new MapReduce(db);\n  }\n  function viewQuery(fun, options) {\n    if (!options.complete) {\n      return;\n    }\n\n    if (!options.skip) {\n      options.skip = 0;\n    }\n\n    if (!fun.reduce) {\n      options.reduce = false;\n    }\n\n    function sum(values) {\n      return values.reduce(function (a, b) { return a + b; }, 0);\n    }\n\n    var builtInReduce = {\n      \"_sum\": function (keys, values){\n        return sum(values);\n      },\n\n      \"_count\": function (keys, values, rereduce){\n        if (rereduce){\n          return sum(values);\n        } else {\n          return values.length;\n        }\n      },\n\n      \"_stats\": function (keys, values, rereduce) {\n        return {\n          'sum': sum(values),\n          'min': Math.min.apply(null, values),\n          'max': Math.max.apply(null, values),\n          'count': values.length,\n          'sumsqr': (function () {\n            var _sumsqr = 0;\n            for(var idx in values) {\n              if (typeof values[idx] === 'number') {\n              _sumsqr += values[idx] * values[idx];\n              }\n            }\n            return _sumsqr;\n          })()\n        };\n      }\n    };\n\n    var results = [];\n    var current = null;\n    var num_started= 0;\n    var completed= false;\n\n    function emit(key, val) {\n      var viewRow = {\n        id: current.doc._id,\n        key: key,\n        value: val\n      };\n\n      if (options.startkey && pouchCollate(key, options.startkey) < 0) return;\n      if (options.endkey && pouchCollate(key, options.endkey) > 0) return;\n      if (typeof options.key !== 'undefined' && pouchCollate(key, options.key) !== 0) return;\n\n      num_started++;\n      if (options.include_docs) {\n        //in this special case, join on _id (issue #106)\n        if (val && typeof val === 'object' && val._id){\n          db.get(val._id,\n              function (_, joined_doc){\n                if (joined_doc) {\n                  viewRow.doc = joined_doc;\n                }\n                results.push(viewRow);\n                checkComplete();\n              });\n          return;\n        } else {\n          viewRow.doc = current.doc;\n        }\n      }\n      results.push(viewRow);\n    };\n\n    // ugly way to make sure references to 'emit' in map/reduce bind to the\n    // above emit\n    eval('fun.map = ' + fun.map.toString() + ';');\n    if (fun.reduce) {\n      if (builtInReduce[fun.reduce]) {\n        fun.reduce = builtInReduce[fun.reduce];\n      }\n\n      eval('fun.reduce = ' + fun.reduce.toString() + ';');\n    }\n\n    //only proceed once all documents are mapped and joined\n    function checkComplete() {\n      if (completed && results.length == num_started){\n        results.sort(function (a, b) {\n          return pouchCollate(a.key, b.key);\n        });\n        if (options.descending) {\n          results.reverse();\n        }\n        if (options.reduce === false) {\n          return options.complete(null, {\n            total_rows: results.length,\n            offset: options.skip,\n            rows: ('limit' in options) ? results.slice(options.skip, options.limit + options.skip) :\n              (options.skip > 0) ? results.slice(options.skip) : results\n          });\n        }\n\n        var groups = [];\n        results.forEach(function (e) {\n          var last = groups[groups.length-1] || null;\n          if (last && pouchCollate(last.key[0][0], e.key) === 0) {\n            last.key.push([e.key, e.id]);\n            last.value.push(e.value);\n            return;\n          }\n          groups.push({key: [[e.key, e.id]], value: [e.value]});\n        });\n        groups.forEach(function (e) {\n          e.value = fun.reduce(e.key, e.value);\n          e.value = (typeof e.value === 'undefined') ? null : e.value;\n          e.key = e.key[0][0];\n        });\n\n        options.complete(null, {\n          total_rows: groups.length,\n          offset: options.skip,\n          rows: ('limit' in options) ? groups.slice(options.skip, options.limit + options.skip) :\n            (options.skip > 0) ? groups.slice(options.skip) : groups\n        });\n      }\n    };\n\n    db.changes({\n      conflicts: true,\n      include_docs: true,\n      onChange: function (doc) {\n        if (!('deleted' in doc)) {\n          current = {doc: doc.doc};\n          fun.map.call(this, doc.doc);\n        }\n      },\n      complete: function () {\n        completed= true;\n        checkComplete();\n      }\n    });\n  }\n\n  function httpQuery(fun, opts, callback) {\n\n    // List of parameters to add to the PUT request\n    var params = [];\n    var body = undefined;\n    var method = 'GET';\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    if (typeof opts.reduce !== 'undefined') {\n      params.push('reduce=' + opts.reduce);\n    }\n    if (typeof opts.include_docs !== 'undefined') {\n      params.push('include_docs=' + opts.include_docs);\n    }\n    if (typeof opts.limit !== 'undefined') {\n      params.push('limit=' + opts.limit);\n    }\n    if (typeof opts.descending !== 'undefined') {\n      params.push('descending=' + opts.descending);\n    }\n    if (typeof opts.startkey !== 'undefined') {\n      params.push('startkey=' + encodeURIComponent(JSON.stringify(opts.startkey)));\n    }\n    if (typeof opts.endkey !== 'undefined') {\n      params.push('endkey=' + encodeURIComponent(JSON.stringify(opts.endkey)));\n    }\n    if (typeof opts.key !== 'undefined') {\n      params.push('key=' + encodeURIComponent(JSON.stringify(opts.key)));\n    }\n    if (typeof opts.group !== 'undefined') {\n      params.push('group=' + opts.group);\n    }\n    if (typeof opts.group_level !== 'undefined') {\n      params.push('group_level=' + opts.group_level);\n    }\n    if (typeof opts.skip !== 'undefined') {\n      params.push('skip=' + opts.skip);\n    }\n\n    // If keys are supplied, issue a POST request to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      method = 'POST';\n      body = JSON.stringify({keys:opts.keys});\n    }\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = fun.split('/');\n      db.request({\n        method: method,\n        url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n        body: body\n      }, callback);\n      return;\n    }\n\n    // We are using a temporary view, terrible for performance but good for testing\n    var queryObject = JSON.parse(JSON.stringify(fun, function (key, val) {\n      if (typeof val === 'function') {\n        return val + ''; // implicitly `toString` it\n      }\n      return val;\n    }));\n\n    db.request({\n      method:'POST',\n      url: '_temp_view' + params,\n      body: queryObject\n    }, callback);\n  }\n\n  this.query = function(fun, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    if (callback) {\n      opts.complete = callback;\n    }\n\n    if (db.type() === 'http') {\n    if (typeof fun === 'function'){\n      return httpQuery({map: fun}, opts, callback);\n    }\n    return httpQuery(fun, opts, callback);\n    }\n\n    if (typeof fun === 'object') {\n      return viewQuery(fun, opts);\n    }\n\n    if (typeof fun === 'function') {\n      return viewQuery({map: fun}, opts);\n    }\n\n    var parts = fun.split('/');\n    db.get('_design/' + parts[0], function (err, doc) {\n      if (err) {\n        if (callback) callback(err);\n        return;\n      }\n\n      if (!doc.views[parts[1]]) {\n        if (callback) callback({ error: 'not_found', reason: 'missing_named_view' });\n        return;\n      }\n\n      viewQuery({\n        map: doc.views[parts[1]].map,\n        reduce: doc.views[parts[1]].reduce\n      }, opts);\n    });\n  }\n\n};\n\n// Deletion is a noop since we dont store the results of the view\nMapReduce._delete = function () { };\nmodule.exports = MapReduce;\n\n},{\"pouchdb-collate\":21}],21:[function(require,module,exports){\n'use strict';\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = pouchCollate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = pouchCollate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = pouchCollate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  if (id.indexOf(typeof x) !== -1) {\n    if (x === null) {\n      return 1;\n    }\n    return id.indexOf(typeof x) + 2;\n  }\n  if (Array.isArray(x)) {\n    return 4.5;\n  }\n  if (typeof x === 'undefined') {\n    // CouchDB indexes both null/undefined as null\n    return 1;\n  }\n}\nmodule.exports = pouchCollate;\nfunction pouchCollate(a, b) {\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  if (a === null || typeof a === 'undefined') {\n    return 0;\n  }\n  if (typeof a === 'number') {\n    return a - b;\n  }\n  if (typeof a === 'boolean') {\n    return a === b ? 0 : (a < b ? -1 : 1);\n  }\n  if (typeof a === 'string') {\n    return stringCollate(a, b);\n  }\n  if (Array.isArray(a)) {\n    return arrayCollate(a, b);\n  }\n  if (typeof a === 'object') {\n    return objectCollate(a, b);\n  }\n};;\n},{}]},{},[12])\n(12)\n});","/*! backbone-pouch - v1.3.0 - 2013-10-18\n* http://jo.github.io/backbone-pouch/\n* Copyright (c) 2013 Johannes J. Schmidt; Licensed MIT */\n(function(root) {\n  'use strict';\n  \n  var BackbonePouch;\n  if (typeof exports === 'object') {\n    BackbonePouch = exports;\n  } else {\n    BackbonePouch = root.BackbonePouch = {};\n  }\n\n  var methodMap = {\n    'create': 'post',\n    'update': 'put',\n    'patch':  'put',\n    'delete': 'remove'\n  };\n\n  BackbonePouch.defaults = {\n    fetch: 'allDocs',\n    listen: false,\n    options: {\n      post: {},\n      put: {},\n      get: {},\n      remove: {},\n      allDocs: {},\n      query: {},\n      spatial: {},\n      changes: {\n        continuous: true\n      }\n    }\n  };\n\n  // inspired from https://github.com/Raynos/xtend\n  function extend() {\n    var target = {};\n\n    for (var i = 0; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      if (typeof source !== 'object') {\n        continue;\n      }\n\n      for (var name in source) {\n        if (typeof source[name] === 'object' && typeof target[name] === 'object') {\n          target[name] = extend(target[name] || {}, source[name]);\n        } else {\n          target[name] = source[name];\n        }\n      }\n    }\n\n    return target;\n  }\n\n  // backbone-pouch sync adapter\n  BackbonePouch.sync = function(defaults) {\n    defaults = defaults || {};\n    defaults = extend(BackbonePouch.defaults, defaults);\n\n    var adapter = function(method, model, options) {\n      options = options || {};\n      options = extend(defaults, model && model.pouch || {}, options);\n\n      // This is to get the options (especially options.db)\n      // by calling model.sync() without arguments.\n      if (typeof method !== 'string') {\n        return options;\n      }\n\n      // ensure we have a pouch db adapter\n      if (!options.db) {\n        throw new Error('A \"db\" property must be specified');\n      }\n\n      function callback(err, response) {\n        if (err) {\n          return options.error && options.error(err);\n        }\n        if (method === 'create' || method === 'update' || method === 'patch') {\n          response = {\n            _id: response.id,\n            _rev: response.rev\n          };\n        }\n        if (method === 'delete') {\n          response = {};\n        }\n        if (method === 'read') {\n          if (options.listen) {\n            // TODO:\n            // * implement for model\n            // * allow overwriding of since.\n            options.db.info(function(err, info) {\n              // get changes since info.update_seq\n              options.db.changes(_.extend({}, options.options.changes, {\n                since: info.update_seq,\n                onChange: function(change) {\n                  var todo = model.get(change.id);\n\n                  if (change.deleted) {\n                    if (todo) {\n                      todo.destroy();\n                    }\n                  } else {\n                    if (todo) {\n                      todo.set(change.doc);\n                    } else {\n                      model.add(change.doc);\n                    }\n                  }\n\n                  // call original onChange if present\n                  if (typeof options.options.changes.onChange === 'function') {\n                    options.options.changes.onChange(change);\n                  }\n                }\n              }));\n            });\n          }\n        }\n        return options.success && options.success(response);\n      }\n\n      model.trigger('request', model, options.db, options);\n\n      if (method === 'read') {\n        // get single model\n        if (model.id) {\n          return options.db.get(model.id, options.options.get, callback);\n        }\n        // query view or spatial index\n        if (options.fetch === 'query' || options.fetch === 'spatial') {\n          if (!options.options[options.fetch].fun) {\n            throw new Error('A \"' + options.fetch + '.fun\" object must be specified');\n          }\n          return options.db[options.fetch](options.options[options.fetch].fun, options.options[options.fetch], callback);\n        }\n        // allDocs or spatial query\n        options.db[options.fetch](options.options[options.fetch], callback);\n      } else {\n        options.db[methodMap[method]](model.toJSON(), options.options[methodMap[method]], callback);\n      }\n\n      return options;\n    };\n\n    adapter.defaults = defaults;\n\n    return adapter;\n  };\n\n  BackbonePouch.attachments = function(defaults) {\n    defaults = defaults || {};\n\n    function getPouch(model) {\n      if (model.pouch && model.pouch.db) {\n        return model.pouch.db;\n      }\n      if (model.collection && model.collection.pouch && model.collection.pouch.db) {\n        return model.collection.pouch.db;\n      }\n      \n      if (defaults.db) {\n        return defaults.db;\n      }\n      \n      var options = model.sync();\n      if (options.db) {\n        return options.db;\n      }\n\n      // TODO: ask sync adapter\n        \n      throw new Error('A \"db\" property must be specified');\n    }\n\n    return {\n      attachments: function(filter) {\n        var atts = this.get('_attachments') || {};\n        if (filter) {\n          return _.filter(_.keys(atts), function(key) {\n            if (typeof filter === 'function') {\n              return filter(key, atts[key]);\n            }\n            \n            return atts[key].content_type.match(filter);\n          });\n        }\n        return _.keys(atts);\n      },\n      attachment: function(name, done) {\n        // TODO: first look at the _attachments stub,\n        // maybe there the data is already there\n        var db = getPouch(this);\n        return db.getAttachment(this.id, name, done);\n      },\n      attach: function(blob, name, type, done) {\n        if (typeof name === 'function') {\n          done = name;\n          name = undefined;\n          type = undefined;\n        }\n        if (typeof type === 'function') {\n          done = type;\n          type = undefined;\n        }\n        name = name || blob.filename;\n        type = type || blob.type;\n\n        // If I do not already have an id, give me one\n        if (!this.id) {\n          this.set({ _id: Math.uuid() }, { silent: true });\n        }\n        \n        var db = getPouch(this);\n        var that = this;\n        return db.putAttachment(this.id, name, this.get('_rev'), blob, type, function(err, response) {\n          if (!err && response.rev) {\n            var atts = that.get('_attachments') || {};\n            atts[name] = {\n              content_type: type,\n              stub: true\n            };\n            that.set({ _rev: response.rev, _attachments: atts }, { silent: true });\n          }\n          done(err, response);\n        });\n      }\n    };\n  };\n}(this));\n","(function(e){if(\"function\"==typeof bootstrap)bootstrap(\"jade\",e);else if(\"object\"==typeof exports)module.exports=e();else if(\"function\"==typeof define&&define.amd)define(e);else if(\"undefined\"!=typeof ses){if(!ses.ok())return;ses.makeJade=e}else\"undefined\"!=typeof window?window.jade=e():global.jade=e()})(function(){var define,ses,bootstrap,module,exports;\nreturn (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\n/*!\n * Jade - runtime\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Lame Array.isArray() polyfill for now.\n */\n\nif (!Array.isArray) {\n  Array.isArray = function(arr){\n    return '[object Array]' == Object.prototype.toString.call(arr);\n  };\n}\n\n/**\n * Lame Object.keys() polyfill for now.\n */\n\nif (!Object.keys) {\n  Object.keys = function(obj){\n    var arr = [];\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        arr.push(key);\n      }\n    }\n    return arr;\n  }\n}\n\n/**\n * Merge two attribute objects giving precedence\n * to values in object `b`. Classes are special-cased\n * allowing for arrays and merging/joining appropriately\n * resulting in a string.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n * @api private\n */\n\nexports.merge = function merge(a, b) {\n  var ac = a['class'];\n  var bc = b['class'];\n\n  if (ac || bc) {\n    ac = ac || [];\n    bc = bc || [];\n    if (!Array.isArray(ac)) ac = [ac];\n    if (!Array.isArray(bc)) bc = [bc];\n    a['class'] = ac.concat(bc).filter(nulls);\n  }\n\n  for (var key in b) {\n    if (key != 'class') {\n      a[key] = b[key];\n    }\n  }\n\n  return a;\n};\n\n/**\n * Filter null `val`s.\n *\n * @param {*} val\n * @return {Boolean}\n * @api private\n */\n\nfunction nulls(val) {\n  return val != null && val !== '';\n}\n\n/**\n * join array as classes.\n *\n * @param {*} val\n * @return {String}\n * @api private\n */\n\nfunction joinClasses(val) {\n  return Array.isArray(val) ? val.map(joinClasses).filter(nulls).join(' ') : val;\n}\n\n/**\n * Render the given attributes object.\n *\n * @param {Object} obj\n * @param {Object} escaped\n * @return {String}\n * @api private\n */\n\nexports.attrs = function attrs(obj, escaped){\n  var buf = []\n    , terse = obj.terse;\n\n  delete obj.terse;\n  var keys = Object.keys(obj)\n    , len = keys.length;\n\n  if (len) {\n    buf.push('');\n    for (var i = 0; i < len; ++i) {\n      var key = keys[i]\n        , val = obj[key];\n\n      if ('boolean' == typeof val || null == val) {\n        if (val) {\n          terse\n            ? buf.push(key)\n            : buf.push(key + '=\"' + key + '\"');\n        }\n      } else if (0 == key.indexOf('data') && 'string' != typeof val) {\n        buf.push(key + \"='\" + JSON.stringify(val) + \"'\");\n      } else if ('class' == key) {\n        if (escaped && escaped[key]){\n          if (val = exports.escape(joinClasses(val))) {\n            buf.push(key + '=\"' + val + '\"');\n          }\n        } else {\n          if (val = joinClasses(val)) {\n            buf.push(key + '=\"' + val + '\"');\n          }\n        }\n      } else if (escaped && escaped[key]) {\n        buf.push(key + '=\"' + exports.escape(val) + '\"');\n      } else {\n        buf.push(key + '=\"' + val + '\"');\n      }\n    }\n  }\n\n  return buf.join(' ');\n};\n\n/**\n * Escape the given string of `html`.\n *\n * @param {String} html\n * @return {String}\n * @api private\n */\n\nexports.escape = function escape(html){\n  return String(html)\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;');\n};\n\n/**\n * Re-throw the given `err` in context to the\n * the jade in `filename` at the given `lineno`.\n *\n * @param {Error} err\n * @param {String} filename\n * @param {String} lineno\n * @api private\n */\n\nexports.rethrow = function rethrow(err, filename, lineno, str){\n  if (!(err instanceof Error)) throw err;\n  if ((typeof window != 'undefined' || !filename) && !str) {\n    err.message += ' on line ' + lineno;\n    throw err;\n  }\n  try {\n    str =  str || require('fs').readFileSync(filename, 'utf8')\n  } catch (ex) {\n    rethrow(err, null, lineno)\n  }\n  var context = 3\n    , lines = str.split('\\n')\n    , start = Math.max(lineno - context, 0)\n    , end = Math.min(lines.length, lineno + context);\n\n  // Error context\n  var context = lines.slice(start, end).map(function(line, i){\n    var curr = i + start + 1;\n    return (curr == lineno ? '  > ' : '    ')\n      + curr\n      + '| '\n      + line;\n  }).join('\\n');\n\n  // Alter exception message\n  err.path = filename;\n  err.message = (filename || 'Jade') + ':' + lineno\n    + '\\n' + context + '\\n\\n' + err.message;\n  throw err;\n};\n\n},{\"fs\":2}],2:[function(require,module,exports){\n// nothing to see here... no file methods for the browser\n\n},{}]},{},[1])(1)\n});\n;\n"]}